"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
var require_use_sync_external_store_shim_production = __commonJS({
  "../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports2) {
    "use strict";
    var React157 = require("react");
    function is2(x2, y) {
      return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is2;
    var useState54 = React157.useState;
    var useEffect63 = React157.useEffect;
    var useLayoutEffect12 = React157.useLayoutEffect;
    var useDebugValue2 = React157.useDebugValue;
    function useSyncExternalStore$2(subscribe2, getSnapshot) {
      var value = getSnapshot(), _useState = useState54({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect12(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe2, value, getSnapshot]
      );
      useEffect63(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe2(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe2]
      );
      useDebugValue2(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error2) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe2, getSnapshot) {
      return getSnapshot();
    }
    var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports2.useSyncExternalStore = void 0 !== React157.useSyncExternalStore ? React157.useSyncExternalStore : shim;
  }
});

// ../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && function() {
      function is2(x2, y) {
        return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot) {
        didWarnOld18Alpha || void 0 === React157.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState54({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect12(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe2, value, getSnapshot]
        );
        useEffect63(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe2]
        );
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React157 = require("react"), objectIs = "function" === typeof Object.is ? Object.is : is2, useState54 = React157.useState, useEffect63 = React157.useEffect, useLayoutEffect12 = React157.useLayoutEffect, useDebugValue2 = React157.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports2.useSyncExternalStore = void 0 !== React157.useSyncExternalStore ? React157.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }
});

// ../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_use_sync_external_store_shim_production();
    } else {
      module2.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js
var require_use_sync_external_store_with_selector_production = __commonJS({
  "../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js"(exports2) {
    "use strict";
    var React157 = require("react");
    function is2(x2, y) {
      return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is2;
    var useSyncExternalStore3 = React157.useSyncExternalStore;
    var useRef51 = React157.useRef;
    var useEffect63 = React157.useEffect;
    var useMemo26 = React157.useMemo;
    var useDebugValue2 = React157.useDebugValue;
    exports2.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual2) {
      var instRef = useRef51(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else
        inst = instRef.current;
      instRef = useMemo26(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector(nextSnapshot);
              if (void 0 !== isEqual2 && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual2(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual2]
      );
      var value = useSyncExternalStore3(subscribe2, instRef[0], instRef[1]);
      useEffect63(
        function() {
          inst.hasValue = true;
          inst.value = value;
        },
        [value]
      );
      useDebugValue2(value);
      return value;
    };
  }
});

// ../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = __commonJS({
  "../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && function() {
      function is2(x2, y) {
        return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React157 = require("react"), objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore3 = React157.useSyncExternalStore, useRef51 = React157.useRef, useEffect63 = React157.useEffect, useMemo26 = React157.useMemo, useDebugValue2 = React157.useDebugValue;
      exports2.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual2) {
        var instRef = useRef51(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else
          inst = instRef.current;
        instRef = useMemo26(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual2 && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual2(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual2]
        );
        var value = useSyncExternalStore3(subscribe2, instRef[0], instRef[1]);
        useEffect63(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue2(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }
});

// ../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/with-selector.js
var require_with_selector = __commonJS({
  "../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/with-selector.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_use_sync_external_store_with_selector_production();
    } else {
      module2.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Accordion: () => Accordion2,
  AccordionContent: () => AccordionContent2,
  AccordionItem: () => AccordionItem2,
  AccordionTrigger: () => AccordionTrigger2,
  Alert: () => Alert,
  AlertDescription: () => AlertDescription,
  AlertDialog: () => AlertDialog2,
  AlertDialogAction: () => AlertDialogAction2,
  AlertDialogCancel: () => AlertDialogCancel2,
  AlertDialogContent: () => AlertDialogContent2,
  AlertDialogDescription: () => AlertDialogDescription2,
  AlertDialogFooter: () => AlertDialogFooter,
  AlertDialogHeader: () => AlertDialogHeader,
  AlertDialogOverlay: () => AlertDialogOverlay2,
  AlertDialogPortal: () => AlertDialogPortal2,
  AlertDialogTitle: () => AlertDialogTitle2,
  AlertDialogTrigger: () => AlertDialogTrigger2,
  AlertTitle: () => AlertTitle,
  AspectRatio: () => AspectRatio2,
  Avatar: () => Avatar2,
  AvatarFallback: () => AvatarFallback2,
  AvatarImage: () => AvatarImage2,
  Badge: () => Badge,
  Breadcrumb: () => Breadcrumb,
  BreadcrumbEllipsis: () => BreadcrumbEllipsis,
  BreadcrumbItem: () => BreadcrumbItem,
  BreadcrumbLink: () => BreadcrumbLink,
  BreadcrumbList: () => BreadcrumbList,
  BreadcrumbPage: () => BreadcrumbPage,
  BreadcrumbSeparator: () => BreadcrumbSeparator,
  Button: () => Button,
  Calendar: () => Calendar2,
  Card: () => Card,
  CardContent: () => CardContent,
  CardDescription: () => CardDescription,
  CardFooter: () => CardFooter,
  CardHeader: () => CardHeader,
  CardTitle: () => CardTitle,
  Carousel: () => Carousel,
  CarouselContent: () => CarouselContent,
  CarouselItem: () => CarouselItem,
  CarouselNext: () => CarouselNext,
  CarouselPrevious: () => CarouselPrevious,
  Chart: () => Chart,
  ChartContainer: () => ChartContainer,
  ChartLegend: () => ChartLegend,
  ChartLegendContent: () => ChartLegendContent,
  ChartStyle: () => ChartStyle,
  ChartTooltip: () => ChartTooltip,
  ChartTooltipContent: () => ChartTooltipContent,
  Checkbox: () => Checkbox2,
  Collapsible: () => Collapsible2,
  CollapsibleContent: () => CollapsibleContent2,
  CollapsibleTrigger: () => CollapsibleTrigger2,
  Command: () => Command,
  CommandDialog: () => CommandDialog,
  CommandEmpty: () => CommandEmpty,
  CommandGroup: () => CommandGroup,
  CommandInput: () => CommandInput,
  CommandItem: () => CommandItem,
  CommandList: () => CommandList,
  CommandSeparator: () => CommandSeparator,
  CommandShortcut: () => CommandShortcut,
  ContextMenu: () => ContextMenu2,
  ContextMenuCheckboxItem: () => ContextMenuCheckboxItem2,
  ContextMenuContent: () => ContextMenuContent2,
  ContextMenuGroup: () => ContextMenuGroup2,
  ContextMenuItem: () => ContextMenuItem2,
  ContextMenuLabel: () => ContextMenuLabel2,
  ContextMenuPortal: () => ContextMenuPortal2,
  ContextMenuRadioGroup: () => ContextMenuRadioGroup2,
  ContextMenuRadioItem: () => ContextMenuRadioItem2,
  ContextMenuSeparator: () => ContextMenuSeparator2,
  ContextMenuShortcut: () => ContextMenuShortcut,
  ContextMenuSub: () => ContextMenuSub2,
  ContextMenuSubContent: () => ContextMenuSubContent2,
  ContextMenuSubTrigger: () => ContextMenuSubTrigger2,
  ContextMenuTrigger: () => ContextMenuTrigger2,
  DatePicker: () => DatePicker,
  DatePickerWithRange: () => DatePickerWithRange,
  Dialog: () => Dialog3,
  DialogClose: () => DialogClose3,
  DialogContent: () => DialogContent3,
  DialogDescription: () => DialogDescription3,
  DialogFooter: () => DialogFooter,
  DialogHeader: () => DialogHeader,
  DialogOverlay: () => DialogOverlay3,
  DialogPortal: () => DialogPortal3,
  DialogTitle: () => DialogTitle3,
  DialogTrigger: () => DialogTrigger3,
  Drawer: () => Drawer2,
  DrawerClose: () => DrawerClose,
  DrawerContent: () => DrawerContent,
  DrawerDescription: () => DrawerDescription,
  DrawerFooter: () => DrawerFooter,
  DrawerHeader: () => DrawerHeader,
  DrawerOverlay: () => DrawerOverlay,
  DrawerPortal: () => DrawerPortal,
  DrawerTitle: () => DrawerTitle,
  DrawerTrigger: () => DrawerTrigger,
  DropdownMenu: () => DropdownMenu2,
  DropdownMenuCheckboxItem: () => DropdownMenuCheckboxItem2,
  DropdownMenuContent: () => DropdownMenuContent2,
  DropdownMenuGroup: () => DropdownMenuGroup2,
  DropdownMenuItem: () => DropdownMenuItem2,
  DropdownMenuLabel: () => DropdownMenuLabel2,
  DropdownMenuPortal: () => DropdownMenuPortal2,
  DropdownMenuRadioGroup: () => DropdownMenuRadioGroup2,
  DropdownMenuRadioItem: () => DropdownMenuRadioItem2,
  DropdownMenuSeparator: () => DropdownMenuSeparator2,
  DropdownMenuShortcut: () => DropdownMenuShortcut,
  DropdownMenuSub: () => DropdownMenuSub2,
  DropdownMenuSubContent: () => DropdownMenuSubContent2,
  DropdownMenuSubTrigger: () => DropdownMenuSubTrigger2,
  DropdownMenuTrigger: () => DropdownMenuTrigger2,
  Form: () => Form,
  FormControl: () => FormControl,
  FormDescription: () => FormDescription,
  FormField: () => FormField,
  FormItem: () => FormItem,
  FormLabel: () => FormLabel,
  FormMessage: () => FormMessage,
  HoverCard: () => HoverCard2,
  HoverCardContent: () => HoverCardContent2,
  HoverCardTrigger: () => HoverCardTrigger2,
  Input: () => Input,
  InputOTP: () => InputOTP,
  InputOTPGroup: () => InputOTPGroup,
  InputOTPSeparator: () => InputOTPSeparator,
  InputOTPSlot: () => InputOTPSlot,
  Kanban: () => Kanban,
  Label: () => Label4,
  Menubar: () => Menubar2,
  MenubarCheckboxItem: () => MenubarCheckboxItem2,
  MenubarContent: () => MenubarContent2,
  MenubarGroup: () => MenubarGroup2,
  MenubarItem: () => MenubarItem2,
  MenubarLabel: () => MenubarLabel2,
  MenubarMenu: () => MenubarMenu2,
  MenubarPortal: () => MenubarPortal2,
  MenubarRadioGroup: () => MenubarRadioGroup2,
  MenubarRadioItem: () => MenubarRadioItem2,
  MenubarSeparator: () => MenubarSeparator2,
  MenubarShortcut: () => MenubarShortcut,
  MenubarSub: () => MenubarSub2,
  MenubarSubContent: () => MenubarSubContent2,
  MenubarSubTrigger: () => MenubarSubTrigger2,
  MenubarTrigger: () => MenubarTrigger2,
  NavigationMenu: () => NavigationMenu2,
  NavigationMenuContent: () => NavigationMenuContent2,
  NavigationMenuIndicator: () => NavigationMenuIndicator2,
  NavigationMenuItem: () => NavigationMenuItem2,
  NavigationMenuLink: () => NavigationMenuLink2,
  NavigationMenuList: () => NavigationMenuList2,
  NavigationMenuTrigger: () => NavigationMenuTrigger2,
  NavigationMenuViewport: () => NavigationMenuViewport2,
  Pagination: () => Pagination,
  PaginationContent: () => PaginationContent,
  PaginationEllipsis: () => PaginationEllipsis,
  PaginationItem: () => PaginationItem,
  PaginationLink: () => PaginationLink,
  PaginationNext: () => PaginationNext,
  PaginationPrevious: () => PaginationPrevious,
  Popover: () => Popover2,
  PopoverContent: () => PopoverContent2,
  PopoverTrigger: () => PopoverTrigger2,
  Progress: () => Progress2,
  RadioGroup: () => RadioGroup4,
  RadioGroupItem: () => RadioGroupItem2,
  ResizableHandle: () => ResizableHandle,
  ResizablePanel: () => ResizablePanel,
  ResizablePanelGroup: () => ResizablePanelGroup,
  ScrollArea: () => ScrollArea2,
  ScrollBar: () => ScrollBar,
  Select: () => Select3,
  SelectContent: () => SelectContent2,
  SelectGroup: () => SelectGroup2,
  SelectItem: () => SelectItem2,
  SelectLabel: () => SelectLabel2,
  SelectScrollDownButton: () => SelectScrollDownButton2,
  SelectScrollUpButton: () => SelectScrollUpButton2,
  SelectSeparator: () => SelectSeparator2,
  SelectTrigger: () => SelectTrigger2,
  SelectValue: () => SelectValue2,
  Separator: () => Separator4,
  Sheet: () => Sheet,
  SheetClose: () => SheetClose,
  SheetContent: () => SheetContent,
  SheetDescription: () => SheetDescription,
  SheetFooter: () => SheetFooter,
  SheetHeader: () => SheetHeader,
  SheetOverlay: () => SheetOverlay,
  SheetPortal: () => SheetPortal,
  SheetTitle: () => SheetTitle,
  SheetTrigger: () => SheetTrigger,
  Sidebar: () => Sidebar,
  SidebarContent: () => SidebarContent,
  SidebarFooter: () => SidebarFooter,
  SidebarGroup: () => SidebarGroup,
  SidebarGroupAction: () => SidebarGroupAction,
  SidebarGroupContent: () => SidebarGroupContent,
  SidebarGroupLabel: () => SidebarGroupLabel,
  SidebarHeader: () => SidebarHeader,
  SidebarInput: () => SidebarInput,
  SidebarInset: () => SidebarInset,
  SidebarMenu: () => SidebarMenu,
  SidebarMenuAction: () => SidebarMenuAction,
  SidebarMenuBadge: () => SidebarMenuBadge,
  SidebarMenuButton: () => SidebarMenuButton,
  SidebarMenuItem: () => SidebarMenuItem,
  SidebarMenuSkeleton: () => SidebarMenuSkeleton,
  SidebarMenuSub: () => SidebarMenuSub,
  SidebarMenuSubButton: () => SidebarMenuSubButton,
  SidebarMenuSubItem: () => SidebarMenuSubItem,
  SidebarProvider: () => SidebarProvider,
  SidebarRail: () => SidebarRail,
  SidebarSeparator: () => SidebarSeparator,
  SidebarTrigger: () => SidebarTrigger,
  Skeleton: () => Skeleton,
  Slider: () => Slider2,
  Switch: () => Switch2,
  Table: () => Table,
  TableBody: () => TableBody,
  TableCaption: () => TableCaption,
  TableCell: () => TableCell,
  TableFooter: () => TableFooter,
  TableHead: () => TableHead,
  TableHeader: () => TableHeader,
  TableRow: () => TableRow,
  Tabs: () => Tabs2,
  TabsContent: () => TabsContent2,
  TabsList: () => TabsList2,
  TabsTrigger: () => TabsTrigger2,
  Textarea: () => Textarea,
  Toast: () => Toast2,
  ToastAction: () => ToastAction2,
  ToastClose: () => ToastClose2,
  ToastDescription: () => ToastDescription2,
  ToastProvider: () => ToastProvider2,
  ToastTitle: () => ToastTitle2,
  ToastViewport: () => ToastViewport2,
  Toaster: () => Toaster,
  ToasterProvider: () => ToasterProvider,
  Toggle: () => Toggle2,
  ToggleGroup: () => ToggleGroup2,
  ToggleGroupItem: () => ToggleGroupItem2,
  Tooltip: () => Tooltip2,
  TooltipContent: () => TooltipContent2,
  TooltipProvider: () => TooltipProvider2,
  TooltipTrigger: () => TooltipTrigger2,
  TreeView: () => TreeView,
  badgeVariants: () => badgeVariants,
  buttonVariants: () => buttonVariants,
  navigationMenuTriggerStyle: () => navigationMenuTriggerStyle,
  reducer: () => reducer3,
  toast: () => toast2,
  toggleVariants: () => toggleVariants,
  useFormField: () => useFormField,
  useIsMobile: () => useIsMobile2,
  useSidebar: () => useSidebar,
  useToast: () => useToast2
});
module.exports = __toCommonJS(src_exports);

// src/components/accordion.tsx
var React14 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-accordion@1.2.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19._75iv7dzo2eeijrwf27x6fzgyre/node_modules/@radix-ui/react-accordion/dist/index.mjs
var import_react2 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-context@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-context/dist/index.mjs
var React = __toESM(require("react"), 1);
var import_jsx_runtime = require("react/jsx-runtime");
function createContext2(rootComponentName, defaultContext) {
  const Context = React.createContext(defaultContext);
  const Provider4 = (props2) => {
    const _a = props2, { children } = _a, context = __objRest(_a, ["children"]);
    const value = React.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context.Provider, { value, children });
  };
  Provider4.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React.useContext(Context);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider4, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider4 = (props2) => {
      var _b;
      const _a = props2, { scope, children } = _a, context = __objRest(_a, ["scope", "children"]);
      const Context = ((_b = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _b[index2]) || BaseContext;
      const value = React.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context.Provider, { value, children });
    };
    Provider4.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const context = React.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider4, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: __spreadProps(__spreadValues({}, scope), { [scopeName]: contexts }) }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return __spreadValues(__spreadValues({}, nextScopes2), currentScope);
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../../node_modules/.pnpm/@radix-ui+react-collection@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19_nzbl2gfimp5wr5r2scllbfcfna/node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React2 = __toESM(require("react"), 1);
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    return ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref2) => {
      const cleanup = setRef(ref2, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React2.useCallback(composeRefs(...refs), refs);
}

// ../../node_modules/.pnpm/@radix-ui+react-slot@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var React3 = __toESM(require("react"), 1);
var import_jsx_runtime2 = require("react/jsx-runtime");
var Slot = React3.forwardRef((props2, forwardedRef) => {
  const _a = props2, { children } = _a, slotProps = __objRest(_a, ["children"]);
  const childrenArray = React3.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React3.Children.count(newElement) > 1)
          return React3.Children.only(null);
        return React3.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(SlotClone, __spreadProps(__spreadValues({}, slotProps), { ref: forwardedRef, children: React3.isValidElement(newElement) ? React3.cloneElement(newElement, void 0, newChildren) : null }));
  }
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(SlotClone, __spreadProps(__spreadValues({}, slotProps), { ref: forwardedRef, children }));
});
Slot.displayName = "Slot";
var SlotClone = React3.forwardRef((props2, forwardedRef) => {
  const _a = props2, { children } = _a, slotProps = __objRest(_a, ["children"]);
  if (React3.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return React3.cloneElement(children, __spreadProps(__spreadValues({}, mergeProps(slotProps, children.props)), {
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    }));
  }
  return React3.Children.count(children) > 1 ? React3.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
};
function isSlottable(child) {
  return React3.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = __spreadValues({}, childProps);
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue);
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return __spreadValues(__spreadValues({}, slotProps), overrideProps);
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/@radix-ui+react-collection@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19_nzbl2gfimp5wr5r2scllbfcfna/node_modules/@radix-ui/react-collection/dist/index.mjs
var import_jsx_runtime3 = require("react/jsx-runtime");
function createCollection(name) {
  const PROVIDER_NAME3 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope10] = createContextScope(PROVIDER_NAME3);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME3,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props2) => {
    const { scope, children } = props2;
    const ref2 = import_react.default.useRef(null);
    const itemMap = import_react.default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref2, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME3;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = import_react.default.forwardRef(
    (props2, forwardedRef) => {
      const { scope, children } = props2;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = import_react.default.forwardRef(
    (props2, forwardedRef) => {
      const _a = props2, { scope, children } = _a, itemData = __objRest(_a, ["scope", "children"]);
      const ref2 = import_react.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref2);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react.default.useEffect(() => {
        context.itemMap.set(ref2, __spreadValues({ ref: ref2 }, itemData));
        return () => void context.itemMap.delete(ref2);
      });
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Slot, __spreadProps(__spreadValues({}, { [ITEM_DATA_ATTR]: "" }), { ref: composedRefs, children }));
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection10(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection10,
    createCollectionScope10
  ];
}

// ../../node_modules/.pnpm/@radix-ui+primitive@1.1.1/node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// ../../node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React6 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React5 = __toESM(require("react"), 1);
function useCallbackRef(callback) {
  const callbackRef = React5.useRef(callback);
  React5.useEffect(() => {
    callbackRef.current = callback;
  });
  return React5.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}

// ../../node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef(onChange);
  const setValue = React6.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop)
          handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React6.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React6.useRef(value);
  const handleChange = useCallbackRef(onChange);
  React6.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}

// ../../node_modules/.pnpm/@radix-ui+react-primitive@2.0.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19._xrumbflr3c5wmiguaumgxn7vly/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React7 = __toESM(require("react"), 1);
var ReactDOM = __toESM(require("react-dom"), 1);
var import_jsx_runtime4 = require("react/jsx-runtime");
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React7.forwardRef((props2, forwardedRef) => {
    const _a = props2, { asChild } = _a, primitiveProps = __objRest(_a, ["asChild"]);
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Comp, __spreadProps(__spreadValues({}, primitiveProps), { ref: forwardedRef }));
  });
  Node2.displayName = `Primitive.${node}`;
  return __spreadProps(__spreadValues({}, primitive), { [node]: Node2 });
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// ../../node_modules/.pnpm/@radix-ui+react-collapsible@1.1.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@1_bqqarj2kcu5slwhouruqmsyy7u/node_modules/@radix-ui/react-collapsible/dist/index.mjs
var React11 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React8 = __toESM(require("react"), 1);
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React8.useLayoutEffect : () => {
};

// ../../node_modules/.pnpm/@radix-ui+react-presence@1.1.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1_gvl7e3dlxvrffhindlh3ujyr7y/node_modules/@radix-ui/react-presence/dist/index.mjs
var React22 = __toESM(require("react"), 1);
var React9 = __toESM(require("react"), 1);
function useStateMachine(initialState, machine) {
  return React9.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState != null ? nextState : state;
  }, initialState);
}
var Presence = (props2) => {
  const { present, children } = props2;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref2 = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref: ref2 }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React22.useState();
  const stylesRef = React22.useRef({});
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    var _a;
    if (node) {
      let timeoutId;
      const ownerWindow = (_a = node.ownerDocument.defaultView) != null ? _a : window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node2) => {
      if (node2)
        stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/@radix-ui+react-id@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-id/dist/index.mjs
var React10 = __toESM(require("react"), 1);
var useReactId = React10["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React10.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId)
      setId((reactId) => reactId != null ? reactId : String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/.pnpm/@radix-ui+react-collapsible@1.1.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@1_bqqarj2kcu5slwhouruqmsyy7u/node_modules/@radix-ui/react-collapsible/dist/index.mjs
var import_jsx_runtime5 = require("react/jsx-runtime");
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = React11.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange
    } = _a, collapsibleProps = __objRest(_a, [
      "__scopeCollapsible",
      "open",
      "defaultOpen",
      "disabled",
      "onOpenChange"
    ]);
    const [open = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId(),
        open,
        onOpenToggle: React11.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          Primitive.div,
          __spreadProps(__spreadValues({
            "data-state": getState(open),
            "data-disabled": disabled ? "" : void 0
          }, collapsibleProps), {
            ref: forwardedRef
          })
        )
      }
    );
  }
);
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME = "CollapsibleTrigger";
var CollapsibleTrigger = React11.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeCollapsible } = _a, triggerProps = __objRest(_a, ["__scopeCollapsible"]);
    const context = useCollapsibleContext(TRIGGER_NAME, __scopeCollapsible);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled
      }, triggerProps), {
        ref: forwardedRef,
        onClick: composeEventHandlers(props2.onClick, context.onOpenToggle)
      })
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME;
var CONTENT_NAME = "CollapsibleContent";
var CollapsibleContent = React11.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { forceMount } = _a, contentProps = __objRest(_a, ["forceMount"]);
    const context = useCollapsibleContext(CONTENT_NAME, props2.__scopeCollapsible);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Presence, { present: forceMount || context.open, children: ({ present }) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(CollapsibleContentImpl, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef, present })) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME;
var CollapsibleContentImpl = React11.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeCollapsible, present, children } = _a, contentProps = __objRest(_a, ["__scopeCollapsible", "present", "children"]);
  const context = useCollapsibleContext(CONTENT_NAME, __scopeCollapsible);
  const [isPresent, setIsPresent] = React11.useState(present);
  const ref2 = React11.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const heightRef = React11.useRef(0);
  const height = heightRef.current;
  const widthRef = React11.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React11.useRef(isOpen);
  const originalStylesRef = React11.useRef(void 0);
  React11.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect2(() => {
    const node = ref2.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    Primitive.div,
    __spreadProps(__spreadValues({
      "data-state": getState(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen
    }, contentProps), {
      ref: composedRefs,
      style: __spreadValues({
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0
      }, props2.style),
      children: isOpen && children
    })
  );
});
function getState(open) {
  return open ? "open" : "closed";
}
var Root = Collapsible;
var Trigger = CollapsibleTrigger;
var Content = CollapsibleContent;

// ../../node_modules/.pnpm/@radix-ui+react-direction@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-direction/dist/index.mjs
var React12 = __toESM(require("react"), 1);
var import_jsx_runtime6 = require("react/jsx-runtime");
var DirectionContext = React12.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React12.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// ../../node_modules/.pnpm/@radix-ui+react-accordion@1.2.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19._75iv7dzo2eeijrwf27x6fzgyre/node_modules/@radix-ui/react-accordion/dist/index.mjs
var import_jsx_runtime7 = require("react/jsx-runtime");
var ACCORDION_NAME = "Accordion";
var ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
var [Collection, useCollection, createCollectionScope] = createCollection(ACCORDION_NAME);
var [createAccordionContext, createAccordionScope] = createContextScope(ACCORDION_NAME, [
  createCollectionScope,
  createCollapsibleScope
]);
var useCollapsibleScope = createCollapsibleScope();
var Accordion = import_react2.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { type } = _a, accordionProps = __objRest(_a, ["type"]);
    const singleProps = accordionProps;
    const multipleProps = accordionProps;
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Collection.Provider, { scope: props2.__scopeAccordion, children: type === "multiple" ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AccordionImplMultiple, __spreadProps(__spreadValues({}, multipleProps), { ref: forwardedRef })) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AccordionImplSingle, __spreadProps(__spreadValues({}, singleProps), { ref: forwardedRef })) });
  }
);
Accordion.displayName = ACCORDION_NAME;
var [AccordionValueProvider, useAccordionValueContext] = createAccordionContext(ACCORDION_NAME);
var [AccordionCollapsibleProvider, useAccordionCollapsibleContext] = createAccordionContext(
  ACCORDION_NAME,
  { collapsible: false }
);
var AccordionImplSingle = import_react2.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      value: valueProp,
      defaultValue,
      onValueChange = () => {
      },
      collapsible = false
    } = _a, accordionSingleProps = __objRest(_a, [
      "value",
      "defaultValue",
      "onValueChange",
      "collapsible"
    ]);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      AccordionValueProvider,
      {
        scope: props2.__scopeAccordion,
        value: value ? [value] : [],
        onItemOpen: setValue,
        onItemClose: import_react2.default.useCallback(() => collapsible && setValue(""), [collapsible, setValue]),
        children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AccordionCollapsibleProvider, { scope: props2.__scopeAccordion, collapsible, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AccordionImpl, __spreadProps(__spreadValues({}, accordionSingleProps), { ref: forwardedRef })) })
      }
    );
  }
);
var AccordionImplMultiple = import_react2.default.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    }
  } = _a, accordionMultipleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange"
  ]);
  const [value = [], setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const handleItemOpen = import_react2.default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleItemClose = import_react2.default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    AccordionValueProvider,
    {
      scope: props2.__scopeAccordion,
      value,
      onItemOpen: handleItemOpen,
      onItemClose: handleItemClose,
      children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AccordionCollapsibleProvider, { scope: props2.__scopeAccordion, collapsible: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AccordionImpl, __spreadProps(__spreadValues({}, accordionMultipleProps), { ref: forwardedRef })) })
    }
  );
});
var [AccordionImplProvider, useAccordionContext] = createAccordionContext(ACCORDION_NAME);
var AccordionImpl = import_react2.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAccordion, disabled, dir, orientation = "vertical" } = _a, accordionProps = __objRest(_a, ["__scopeAccordion", "disabled", "dir", "orientation"]);
    const accordionRef = import_react2.default.useRef(null);
    const composedRefs = useComposedRefs(accordionRef, forwardedRef);
    const getItems = useCollection(__scopeAccordion);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const handleKeyDown = composeEventHandlers(props2.onKeyDown, (event) => {
      var _a2;
      if (!ACCORDION_KEYS.includes(event.key))
        return;
      const target = event.target;
      const triggerCollection = getItems().filter((item) => {
        var _a3;
        return !((_a3 = item.ref.current) == null ? void 0 : _a3.disabled);
      });
      const triggerIndex = triggerCollection.findIndex((item) => item.ref.current === target);
      const triggerCount = triggerCollection.length;
      if (triggerIndex === -1)
        return;
      event.preventDefault();
      let nextIndex = triggerIndex;
      const homeIndex = 0;
      const endIndex = triggerCount - 1;
      const moveNext = () => {
        nextIndex = triggerIndex + 1;
        if (nextIndex > endIndex) {
          nextIndex = homeIndex;
        }
      };
      const movePrev = () => {
        nextIndex = triggerIndex - 1;
        if (nextIndex < homeIndex) {
          nextIndex = endIndex;
        }
      };
      switch (event.key) {
        case "Home":
          nextIndex = homeIndex;
          break;
        case "End":
          nextIndex = endIndex;
          break;
        case "ArrowRight":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              moveNext();
            } else {
              movePrev();
            }
          }
          break;
        case "ArrowDown":
          if (orientation === "vertical") {
            moveNext();
          }
          break;
        case "ArrowLeft":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              movePrev();
            } else {
              moveNext();
            }
          }
          break;
        case "ArrowUp":
          if (orientation === "vertical") {
            movePrev();
          }
          break;
      }
      const clampedIndex = nextIndex % triggerCount;
      (_a2 = triggerCollection[clampedIndex].ref.current) == null ? void 0 : _a2.focus();
    });
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      AccordionImplProvider,
      {
        scope: __scopeAccordion,
        disabled,
        direction: dir,
        orientation,
        children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Collection.Slot, { scope: __scopeAccordion, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
          Primitive.div,
          __spreadProps(__spreadValues({}, accordionProps), {
            "data-orientation": orientation,
            ref: composedRefs,
            onKeyDown: disabled ? void 0 : handleKeyDown
          })
        ) })
      }
    );
  }
);
var ITEM_NAME = "AccordionItem";
var [AccordionItemProvider, useAccordionItemContext] = createAccordionContext(ITEM_NAME);
var AccordionItem = import_react2.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAccordion, value } = _a, accordionItemProps = __objRest(_a, ["__scopeAccordion", "value"]);
    const accordionContext = useAccordionContext(ITEM_NAME, __scopeAccordion);
    const valueContext = useAccordionValueContext(ITEM_NAME, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    const triggerId = useId();
    const open = value && valueContext.value.includes(value) || false;
    const disabled = accordionContext.disabled || props2.disabled;
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      AccordionItemProvider,
      {
        scope: __scopeAccordion,
        open,
        disabled,
        triggerId,
        children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
          Root,
          __spreadProps(__spreadValues(__spreadValues({
            "data-orientation": accordionContext.orientation,
            "data-state": getState2(open)
          }, collapsibleScope), accordionItemProps), {
            ref: forwardedRef,
            disabled,
            open,
            onOpenChange: (open2) => {
              if (open2) {
                valueContext.onItemOpen(value);
              } else {
                valueContext.onItemClose(value);
              }
            }
          })
        )
      }
    );
  }
);
AccordionItem.displayName = ITEM_NAME;
var HEADER_NAME = "AccordionHeader";
var AccordionHeader = import_react2.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAccordion } = _a, headerProps = __objRest(_a, ["__scopeAccordion"]);
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(HEADER_NAME, __scopeAccordion);
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      Primitive.h3,
      __spreadProps(__spreadValues({
        "data-orientation": accordionContext.orientation,
        "data-state": getState2(itemContext.open),
        "data-disabled": itemContext.disabled ? "" : void 0
      }, headerProps), {
        ref: forwardedRef
      })
    );
  }
);
AccordionHeader.displayName = HEADER_NAME;
var TRIGGER_NAME2 = "AccordionTrigger";
var AccordionTrigger = import_react2.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAccordion } = _a, triggerProps = __objRest(_a, ["__scopeAccordion"]);
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(TRIGGER_NAME2, __scopeAccordion);
    const collapsibleContext = useAccordionCollapsibleContext(TRIGGER_NAME2, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Collection.ItemSlot, { scope: __scopeAccordion, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      Trigger,
      __spreadProps(__spreadValues(__spreadValues({
        "aria-disabled": itemContext.open && !collapsibleContext.collapsible || void 0,
        "data-orientation": accordionContext.orientation,
        id: itemContext.triggerId
      }, collapsibleScope), triggerProps), {
        ref: forwardedRef
      })
    ) });
  }
);
AccordionTrigger.displayName = TRIGGER_NAME2;
var CONTENT_NAME2 = "AccordionContent";
var AccordionContent = import_react2.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAccordion } = _a, contentProps = __objRest(_a, ["__scopeAccordion"]);
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(CONTENT_NAME2, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      Content,
      __spreadProps(__spreadValues(__spreadValues({
        role: "region",
        "aria-labelledby": itemContext.triggerId,
        "data-orientation": accordionContext.orientation
      }, collapsibleScope), contentProps), {
        ref: forwardedRef,
        style: __spreadValues({
          ["--radix-accordion-content-height"]: "var(--radix-collapsible-content-height)",
          ["--radix-accordion-content-width"]: "var(--radix-collapsible-content-width)"
        }, props2.style)
      })
    );
  }
);
AccordionContent.displayName = CONTENT_NAME2;
function getState2(open) {
  return open ? "open" : "closed";
}
var Root2 = Accordion;
var Item = AccordionItem;
var Header = AccordionHeader;
var Trigger2 = AccordionTrigger;
var Content2 = AccordionContent;

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/createLucideIcon.js
var import_react4 = require("react");

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/shared/src/utils.js
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/Icon.js
var import_react3 = require("react");

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/Icon.js
var Icon = (0, import_react3.forwardRef)(
  (_a, ref2) => {
    var _b = _a, {
      color = "currentColor",
      size: size4 = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode
    } = _b, rest = __objRest(_b, [
      "color",
      "size",
      "strokeWidth",
      "absoluteStrokeWidth",
      "className",
      "children",
      "iconNode"
    ]);
    return (0, import_react3.createElement)(
      "svg",
      __spreadValues(__spreadProps(__spreadValues({
        ref: ref2
      }, defaultAttributes), {
        width: size4,
        height: size4,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size4) : strokeWidth,
        className: mergeClasses("lucide", className)
      }), rest),
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react3.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/createLucideIcon.js
var createLucideIcon = (iconName, iconNode) => {
  const Component = (0, import_react4.forwardRef)(
    (_a, ref2) => {
      var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
      return (0, import_react4.createElement)(Icon, __spreadValues({
        ref: ref2,
        iconNode,
        className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className)
      }, props2));
    }
  );
  Component.displayName = `${iconName}`;
  return Component;
};

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/arrow-left.js
var ArrowLeft = createLucideIcon("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/arrow-right.js
var ArrowRight = createLucideIcon("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/calendar.js
var Calendar = createLucideIcon("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/check.js
var Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/chevron-down.js
var ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/chevron-left.js
var ChevronLeft = createLucideIcon("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/chevron-right.js
var ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/chevron-up.js
var ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/circle.js
var Circle = createLucideIcon("Circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/dot.js
var Dot = createLucideIcon("Dot", [
  ["circle", { cx: "12.1", cy: "12.1", r: "1", key: "18d7e5" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/ellipsis.js
var Ellipsis = createLucideIcon("Ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/grip-vertical.js
var GripVertical = createLucideIcon("GripVertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/panel-left.js
var PanelLeft = createLucideIcon("PanelLeft", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/plus.js
var Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/search.js
var Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.454.0_react@19.1.0/node_modules/lucide-react/dist/esm/icons/x.js
var X = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);

// src/components/accordion.tsx
var import_utils3 = require("@nubras/utils");
var import_jsx_runtime8 = require("react/jsx-runtime");
var Accordion2 = Root2;
var AccordionItem2 = React14.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    Item,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils3.cn)("border-b", className)
    }, props2)
  );
});
AccordionItem2.displayName = "AccordionItem";
var AccordionTrigger2 = React14.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Header, { className: "flex", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
    Trigger2,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils3.cn)(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )
    }, props2), {
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ChevronDown, { className: "h-4 w-4 shrink-0 transition-transform duration-200" })
      ]
    })
  ) });
});
AccordionTrigger2.displayName = Trigger2.displayName;
var AccordionContent2 = React14.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    Content2,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: (0, import_utils3.cn)("pb-4 pt-0", className), children })
    })
  );
});
AccordionContent2.displayName = Content2.displayName;

// src/components/alert-dialog.tsx
var React33 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-alert-dialog@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_qxh3tjqk2zftj2zrxvdlrm4eau/node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var React29 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-dialog@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_ih5myezhnzujhsjbmme6yjh3km/node_modules/@radix-ui/react-dialog/dist/index.mjs
var React28 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.3_@types+react-dom@19.1.3_@types+react@19.1.3__@types+r_4flhfd5ze2rlie4y5nn7ndo2fq/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React16 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React15 = __toESM(require("react"), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React15.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.3_@types+react-dom@19.1.3_@types+react@19.1.3__@types+r_4flhfd5ze2rlie4y5nn7ndo2fq/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime9 = require("react/jsx-runtime");
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React16.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React16.forwardRef(
  (props2, forwardedRef) => {
    var _b;
    const _a = props2, {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss
    } = _a, layerProps = __objRest(_a, [
      "disableOutsidePointerEvents",
      "onEscapeKeyDown",
      "onPointerDownOutside",
      "onFocusOutside",
      "onInteractOutside",
      "onDismiss"
    ]);
    const context = React16.useContext(DismissableLayerContext);
    const [node, setNode] = React16.useState(null);
    const ownerDocument = (_b = node == null ? void 0 : node.ownerDocument) != null ? _b : globalThis == null ? void 0 : globalThis.document;
    const [, force] = React16.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch)
        return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React16.useEffect(() => {
      if (!node)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React16.useEffect(() => {
      return () => {
        if (!node)
          return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React16.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      Primitive.div,
      __spreadProps(__spreadValues({}, layerProps), {
        ref: composedRefs,
        style: __spreadValues({
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0
        }, props2.style),
        onFocusCapture: composeEventHandlers(props2.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props2.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props2.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      })
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React16.forwardRef((props2, forwardedRef) => {
  const context = React16.useContext(DismissableLayerContext);
  const ref2 = React16.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  React16.useEffect(() => {
    const node = ref2.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Primitive.div, __spreadProps(__spreadValues({}, props2), { ref: composedRefs }));
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React16.useRef(false);
  const handleClickRef = React16.useRef(() => {
  });
  React16.useEffect(() => {
    const handlePointerDown2 = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown2);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown2);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React16.useRef(false);
  React16.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root3 = DismissableLayer;
var Branch = DismissableLayerBranch;

// ../../node_modules/.pnpm/@radix-ui+react-focus-scope@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@1_7ldtznv6np3mbmniijdhtaffby/node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React17 = __toESM(require("react"), 1);
var import_jsx_runtime10 = require("react/jsx-runtime");
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React17.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp
  } = _a, scopeProps = __objRest(_a, [
    "loop",
    "trapped",
    "onMountAutoFocus",
    "onUnmountAutoFocus"
  ]);
  const [container, setContainer] = React17.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React17.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React17.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React17.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React17.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement != null ? previouslyFocusedElement : document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React17.useCallback(
    (event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Primitive.div, __spreadProps(__spreadValues({ tabIndex: -1 }, scopeProps), { ref: composedRefs, onKeyDown: handleKeyDown }));
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../../node_modules/.pnpm/@radix-ui+react-portal@1.1.3_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_a4jjzuybjqen4iy677fzzepuxe/node_modules/@radix-ui/react-portal/dist/index.mjs
var React18 = __toESM(require("react"), 1);
var import_react_dom = __toESM(require("react-dom"), 1);
var import_jsx_runtime11 = require("react/jsx-runtime");
var PORTAL_NAME = "Portal";
var Portal = React18.forwardRef((props2, forwardedRef) => {
  var _b;
  const _a = props2, { container: containerProp } = _a, portalProps = __objRest(_a, ["container"]);
  const [mounted, setMounted] = React18.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_b = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _b.body);
  return container ? import_react_dom.default.createPortal(/* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Primitive.div, __spreadProps(__spreadValues({}, portalProps), { ref: forwardedRef })), container) : null;
});
Portal.displayName = PORTAL_NAME;

// ../../node_modules/.pnpm/@radix-ui+react-focus-guards@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React19 = __toESM(require("react"), 1);
var count2 = 0;
function useFocusGuards() {
  React19.useEffect(() => {
    var _a, _b;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_a = edgeGuards[0]) != null ? _a : createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_b = edgeGuards[1]) != null ? _b : createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n3 = arguments.length; i < n3; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/Combination.js
var React27 = __toESM(require("react"));

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/UI.js
var React23 = __toESM(require("react"));

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.3_react@19.1.0/node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
  return ref2;
}

// ../../node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.3_react@19.1.0/node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react5 = require("react");
function useCallbackRef2(initialValue, callback) {
  var ref2 = (0, import_react5.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref2.value;
        },
        set current(value) {
          var last = ref2.value;
          if (last !== value) {
            ref2.value = value;
            ref2.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref2.callback = callback;
  return ref2.facade;
}

// ../../node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.3_react@19.1.0/node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React20 = __toESM(require("react"));
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React20.useLayoutEffect : React20.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref2) {
      return assignRef(ref2, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref2) {
        if (!nextRefs_1.has(ref2)) {
          assignRef(ref2, null);
        }
      });
      nextRefs_1.forEach(function(ref2) {
        if (!prevRefs_1.has(ref2)) {
          assignRef(ref2, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// ../../node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.1.3_react@19.1.0/node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../../node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.1.3_react@19.1.0/node_modules/use-sidecar/dist/es2015/exports.js
var React21 = __toESM(require("react"));
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React21.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React23.forwardRef(function(props2, parentRef) {
  var ref2 = React23.useRef(null);
  var _a = React23.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props2.forwardProps, children = props2.children, className = props2.className, removeScrollBar = props2.removeScrollBar, enabled2 = props2.enabled, shards = props2.shards, sideCar = props2.sideCar, noIsolation = props2.noIsolation, inert = props2.inert, allowPinchZoom = props2.allowPinchZoom, _b = props2.as, Container = _b === void 0 ? "div" : _b, gapMode = props2.gapMode, rest = __rest(props2, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref2, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React23.createElement(
    React23.Fragment,
    null,
    enabled2 && React23.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref2, gapMode }),
    forwardProps ? React23.cloneElement(React23.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React23.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React26 = __toESM(require("react"));

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React25 = __toESM(require("react"));

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.3_react@19.1.0/node_modules/react-style-singleton/dist/es2015/hook.js
var React24 = __toESM(require("react"));

// ../../node_modules/.pnpm/get-nonce@1.0.1/node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.3_react@19.1.0/node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce2 = getNonce();
  if (nonce2) {
    tag.setAttribute("nonce", nonce2);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.3_react@19.1.0/node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React24.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.3_react@19.1.0/node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet2 = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet2;
};

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter2 = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter2) ? counter2 : 0;
};
var useLockAttribute = function() {
  React25.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React25.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React25.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable2 = elementCouldBeScrolled(axis, current);
    if (isScrollable2) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position2 = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref2) {
  return ref2 && "current" in ref2 ? ref2.current : ref2;
};
var deltaCompare = function(x2, y) {
  return x2[0] === y[0] && x2[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props2) {
  var shouldPreventQueue = React26.useRef([]);
  var touchStartRef = React26.useRef([0, 0]);
  var activeAxis = React26.useRef();
  var id = React26.useState(idCounter++)[0];
  var Style2 = React26.useState(styleSingleton)[0];
  var lastProps = React26.useRef(props2);
  React26.useEffect(function() {
    lastProps.current = props2;
  }, [props2]);
  React26.useEffect(function() {
    if (props2.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props2.lockRef.current], (props2.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props2.inert, props2.lockRef.current, props2.shards]);
  var shouldCancelEvent = React26.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React26.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop2 = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop2) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React26.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React26.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React26.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  var scrollTouchMove = React26.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  React26.useEffect(function() {
    lockStack.push(Style2);
    props2.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props2.removeScrollBar, inert = props2.inert;
  return React26.createElement(
    React26.Fragment,
    null,
    inert ? React26.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React26.createElement(RemoveScrollBar, { gapMode: props2.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/.pnpm/react-remove-scroll@2.6.3_@types+react@19.1.3_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React27.forwardRef(function(props2, ref2) {
  return React27.createElement(RemoveScroll, __assign({}, props2, { ref: ref2, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/.pnpm/aria-hidden@1.2.4/node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/.pnpm/@radix-ui+react-dialog@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_ih5myezhnzujhsjbmme6yjh3km/node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime12 = require("react/jsx-runtime");
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props2) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props2;
  const triggerRef = React28.useRef(null);
  const contentRef = React28.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React28.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME3 = "DialogTrigger";
var DialogTrigger = React28.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, triggerProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext(TRIGGER_NAME3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState3(context.open)
      }, triggerProps), {
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props2.onClick, context.onOpenToggle)
      })
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME3;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props2) => {
  const { __scopeDialog, forceMount, children, container } = props2;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React28.Children.map(children, (child) => /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React28.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props2.__scopeDialog);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, overlayProps = __objRest(_a, ["forceMount"]);
    const context = useDialogContext(OVERLAY_NAME, props2.__scopeDialog);
    return context.modal ? /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(DialogOverlayImpl, __spreadProps(__spreadValues({}, overlayProps), { ref: forwardedRef })) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React28.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, overlayProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
        Primitive.div,
        __spreadProps(__spreadValues({
          "data-state": getState3(context.open)
        }, overlayProps), {
          ref: forwardedRef,
          style: __spreadValues({ pointerEvents: "auto" }, overlayProps.style)
        })
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React28.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME3, props2.__scopeDialog);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, contentProps = __objRest(_a, ["forceMount"]);
    const context = useDialogContext(CONTENT_NAME3, props2.__scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(DialogContentModal, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) : /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(DialogContentNonModal, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React28.forwardRef(
  (props2, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props2.__scopeDialog);
    const contentRef = React28.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React28.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      DialogContentImpl,
      __spreadProps(__spreadValues({}, props2), {
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props2.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props2.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props2.onFocusOutside,
          (event) => event.preventDefault()
        )
      })
    );
  }
);
var DialogContentNonModal = React28.forwardRef(
  (props2, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props2.__scopeDialog);
    const hasInteractedOutsideRef = React28.useRef(false);
    const hasPointerDownOutsideRef = React28.useRef(false);
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      DialogContentImpl,
      __spreadProps(__spreadValues({}, props2), {
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props2.onCloseAutoFocus) == null ? void 0 : _a.call(props2, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props2.onInteractOutside) == null ? void 0 : _a.call(props2, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      })
    );
  }
);
var DialogContentImpl = React28.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus } = _a, contentProps = __objRest(_a, ["__scopeDialog", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]);
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React28.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            DismissableLayer,
            __spreadProps(__spreadValues({
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState3(context.open)
            }, contentProps), {
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            })
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React28.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, titleProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Primitive.h2, __spreadProps(__spreadValues({ id: context.titleId }, titleProps), { ref: forwardedRef }));
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React28.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, descriptionProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Primitive.p, __spreadProps(__spreadValues({ id: context.descriptionId }, descriptionProps), { ref: forwardedRef }));
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React28.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, closeProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button"
      }, closeProps), {
        ref: forwardedRef,
        onClick: composeEventHandlers(props2.onClick, () => context.onOpenChange(false))
      })
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState3(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React28.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React28.useEffect(() => {
    var _a;
    const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root4 = Dialog;
var Trigger3 = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content3 = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;

// ../../node_modules/.pnpm/@radix-ui+react-alert-dialog@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_qxh3tjqk2zftj2zrxvdlrm4eau/node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var import_jsx_runtime13 = require("react/jsx-runtime");
var ROOT_NAME = "AlertDialog";
var [createAlertDialogContext, createAlertDialogScope] = createContextScope(ROOT_NAME, [
  createDialogScope
]);
var useDialogScope = createDialogScope();
var AlertDialog = (props2) => {
  const _a = props2, { __scopeAlertDialog } = _a, alertDialogProps = __objRest(_a, ["__scopeAlertDialog"]);
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Root4, __spreadProps(__spreadValues(__spreadValues({}, dialogScope), alertDialogProps), { modal: true }));
};
AlertDialog.displayName = ROOT_NAME;
var TRIGGER_NAME4 = "AlertDialogTrigger";
var AlertDialogTrigger = React29.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAlertDialog } = _a, triggerProps = __objRest(_a, ["__scopeAlertDialog"]);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Trigger3, __spreadProps(__spreadValues(__spreadValues({}, dialogScope), triggerProps), { ref: forwardedRef }));
  }
);
AlertDialogTrigger.displayName = TRIGGER_NAME4;
var PORTAL_NAME3 = "AlertDialogPortal";
var AlertDialogPortal = (props2) => {
  const _a = props2, { __scopeAlertDialog } = _a, portalProps = __objRest(_a, ["__scopeAlertDialog"]);
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Portal2, __spreadValues(__spreadValues({}, dialogScope), portalProps));
};
AlertDialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME2 = "AlertDialogOverlay";
var AlertDialogOverlay = React29.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAlertDialog } = _a, overlayProps = __objRest(_a, ["__scopeAlertDialog"]);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Overlay, __spreadProps(__spreadValues(__spreadValues({}, dialogScope), overlayProps), { ref: forwardedRef }));
  }
);
AlertDialogOverlay.displayName = OVERLAY_NAME2;
var CONTENT_NAME4 = "AlertDialogContent";
var [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME4);
var AlertDialogContent = React29.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAlertDialog, children } = _a, contentProps = __objRest(_a, ["__scopeAlertDialog", "children"]);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const contentRef = React29.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const cancelRef = React29.useRef(null);
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
      WarningProvider,
      {
        contentName: CONTENT_NAME4,
        titleName: TITLE_NAME2,
        docsSlug: "alert-dialog",
        children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
          Content3,
          __spreadProps(__spreadValues(__spreadValues({
            role: "alertdialog"
          }, dialogScope), contentProps), {
            ref: composedRefs,
            onOpenAutoFocus: composeEventHandlers(contentProps.onOpenAutoFocus, (event) => {
              var _a2;
              event.preventDefault();
              (_a2 = cancelRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
            }),
            onPointerDownOutside: (event) => event.preventDefault(),
            onInteractOutside: (event) => event.preventDefault(),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Slottable, { children }),
              /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(DescriptionWarning2, { contentRef })
            ]
          })
        ) })
      }
    );
  }
);
AlertDialogContent.displayName = CONTENT_NAME4;
var TITLE_NAME2 = "AlertDialogTitle";
var AlertDialogTitle = React29.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAlertDialog } = _a, titleProps = __objRest(_a, ["__scopeAlertDialog"]);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Title, __spreadProps(__spreadValues(__spreadValues({}, dialogScope), titleProps), { ref: forwardedRef }));
  }
);
AlertDialogTitle.displayName = TITLE_NAME2;
var DESCRIPTION_NAME2 = "AlertDialogDescription";
var AlertDialogDescription = React29.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeAlertDialog } = _a, descriptionProps = __objRest(_a, ["__scopeAlertDialog"]);
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Description, __spreadProps(__spreadValues(__spreadValues({}, dialogScope), descriptionProps), { ref: forwardedRef }));
});
AlertDialogDescription.displayName = DESCRIPTION_NAME2;
var ACTION_NAME = "AlertDialogAction";
var AlertDialogAction = React29.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAlertDialog } = _a, actionProps = __objRest(_a, ["__scopeAlertDialog"]);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Close, __spreadProps(__spreadValues(__spreadValues({}, dialogScope), actionProps), { ref: forwardedRef }));
  }
);
AlertDialogAction.displayName = ACTION_NAME;
var CANCEL_NAME = "AlertDialogCancel";
var AlertDialogCancel = React29.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAlertDialog } = _a, cancelProps = __objRest(_a, ["__scopeAlertDialog"]);
    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const ref2 = useComposedRefs(forwardedRef, cancelRef);
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Close, __spreadProps(__spreadValues(__spreadValues({}, dialogScope), cancelProps), { ref: ref2 }));
  }
);
AlertDialogCancel.displayName = CANCEL_NAME;
var DescriptionWarning2 = ({ contentRef }) => {
  const MESSAGE = `\`${CONTENT_NAME4}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${CONTENT_NAME4}\` by passing a \`${DESCRIPTION_NAME2}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME4}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  React29.useEffect(() => {
    var _a;
    const hasDescription = document.getElementById(
      (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby")
    );
    if (!hasDescription)
      console.warn(MESSAGE);
  }, [MESSAGE, contentRef]);
  return null;
};
var Root22 = AlertDialog;
var Trigger22 = AlertDialogTrigger;
var Portal22 = AlertDialogPortal;
var Overlay2 = AlertDialogOverlay;
var Content22 = AlertDialogContent;
var Action = AlertDialogAction;
var Cancel = AlertDialogCancel;
var Title2 = AlertDialogTitle;
var Description2 = AlertDialogDescription;

// src/components/alert-dialog.tsx
var import_utils7 = require("@nubras/utils");

// src/components/button.tsx
var React32 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-slot@1.2.2_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var React31 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React30 = __toESM(require("react"), 1);
function setRef2(ref2, value) {
  if (typeof ref2 === "function") {
    return ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs2(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref2) => {
      const cleanup = setRef2(ref2, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef2(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs2(...refs) {
  return React30.useCallback(composeRefs2(...refs), refs);
}

// ../../node_modules/.pnpm/@radix-ui+react-slot@1.2.2_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime14 = require("react/jsx-runtime");
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone2 = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot22 = React31.forwardRef((props2, forwardedRef) => {
    const _a = props2, { children } = _a, slotProps = __objRest(_a, ["children"]);
    const childrenArray = React31.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React31.Children.count(newElement) > 1)
            return React31.Children.only(null);
          return React31.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(SlotClone2, __spreadProps(__spreadValues({}, slotProps), { ref: forwardedRef, children: React31.isValidElement(newElement) ? React31.cloneElement(newElement, void 0, newChildren) : null }));
    }
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(SlotClone2, __spreadProps(__spreadValues({}, slotProps), { ref: forwardedRef, children }));
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot2 = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone2 = React31.forwardRef((props2, forwardedRef) => {
    const _a = props2, { children } = _a, slotProps = __objRest(_a, ["children"]);
    const childrenRef = React31.isValidElement(children) ? getElementRef3(children) : void 0;
    const ref2 = useComposedRefs2(childrenRef, forwardedRef);
    if (React31.isValidElement(children)) {
      const props22 = mergeProps2(slotProps, children.props);
      if (children.type !== React31.Fragment) {
        props22.ref = ref2;
      }
      return React31.cloneElement(children, props22);
    }
    return React31.Children.count(children) > 1 ? React31.Children.only(null) : null;
  });
  SlotClone2.displayName = `${ownerName}.SlotClone`;
  return SlotClone2;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable2(child) {
  return React31.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = __spreadValues({}, childProps);
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue);
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return __spreadValues(__spreadValues({}, slotProps), overrideProps);
}
function getElementRef3(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t2, f, n3 = "";
  if ("string" == typeof e || "number" == typeof e)
    n3 += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o2 = e.length;
      for (t2 = 0; t2 < o2; t2++)
        e[t2] && (f = r(e[t2])) && (n3 && (n3 += " "), n3 += f);
    } else
      for (f in e)
        e[f] && (n3 && (n3 += " "), n3 += f);
  return n3;
}
function clsx() {
  for (var e, t2, f = 0, n3 = "", o2 = arguments.length; f < o2; f++)
    (e = arguments[f]) && (t2 = r(e)) && (n3 && (n3 += " "), n3 += t2);
  return n3;
}

// ../../node_modules/.pnpm/class-variance-authority@0.7.1/node_modules/class-variance-authority/dist/index.mjs
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx;
var cva = (base, config) => (props2) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null)
    return cx(base, props2 === null || props2 === void 0 ? void 0 : props2.class, props2 === null || props2 === void 0 ? void 0 : props2.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props2 === null || props2 === void 0 ? void 0 : props2[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null)
      return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props2 && Object.entries(props2).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let _a = param, { class: cvClass, className: cvClassName } = _a, compoundVariantOptions = __objRest(_a, ["class", "className"]);
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes(__spreadValues(__spreadValues({}, defaultVariants), propsWithoutUndefined)[key]) : __spreadValues(__spreadValues({}, defaultVariants), propsWithoutUndefined)[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props2 === null || props2 === void 0 ? void 0 : props2.class, props2 === null || props2 === void 0 ? void 0 : props2.className);
};

// src/components/button.tsx
var import_utils6 = require("@nubras/utils");
var import_jsx_runtime15 = require("react/jsx-runtime");
var buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var Button = React32.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className, variant, size: size4, asChild = false } = _b, props2 = __objRest(_b, ["className", "variant", "size", "asChild"]);
    const Comp = asChild ? Slot2 : "button";
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      Comp,
      __spreadValues({
        className: (0, import_utils6.cn)(buttonVariants({ variant, size: size4, className })),
        ref: ref2
      }, props2)
    );
  }
);
Button.displayName = "Button";

// src/components/alert-dialog.tsx
var import_jsx_runtime16 = require("react/jsx-runtime");
var AlertDialog2 = Root22;
var AlertDialogTrigger2 = Trigger22;
var AlertDialogPortal2 = Portal22;
var AlertDialogOverlay2 = React33.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    Overlay2,
    __spreadProps(__spreadValues({
      className: (0, import_utils7.cn)(
        "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        className
      )
    }, props2), {
      ref: ref2
    })
  );
});
AlertDialogOverlay2.displayName = Overlay2.displayName;
var AlertDialogContent2 = React33.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(AlertDialogPortal2, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlertDialogOverlay2, {}),
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      Content22,
      __spreadValues({
        ref: ref2,
        className: (0, import_utils7.cn)(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          className
        )
      }, props2)
    )
  ] });
});
AlertDialogContent2.displayName = Content22.displayName;
var AlertDialogHeader = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    "div",
    __spreadValues({
      className: (0, import_utils7.cn)(
        "flex flex-col space-y-2 text-center sm:text-left",
        className
      )
    }, props2)
  );
};
AlertDialogHeader.displayName = "AlertDialogHeader";
var AlertDialogFooter = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    "div",
    __spreadValues({
      className: (0, import_utils7.cn)(
        "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
        className
      )
    }, props2)
  );
};
AlertDialogFooter.displayName = "AlertDialogFooter";
var AlertDialogTitle2 = React33.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    Title2,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils7.cn)("text-lg font-semibold", className)
    }, props2)
  );
});
AlertDialogTitle2.displayName = Title2.displayName;
var AlertDialogDescription2 = React33.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    Description2,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils7.cn)("text-sm text-muted-foreground", className)
    }, props2)
  );
});
AlertDialogDescription2.displayName = Description2.displayName;
var AlertDialogAction2 = React33.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    Action,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils7.cn)(buttonVariants(), className)
    }, props2)
  );
});
AlertDialogAction2.displayName = Action.displayName;
var AlertDialogCancel2 = React33.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    Cancel,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils7.cn)(
        buttonVariants({ variant: "outline" }),
        "mt-2 sm:mt-0",
        className
      )
    }, props2)
  );
});
AlertDialogCancel2.displayName = Cancel.displayName;

// src/components/alert.tsx
var React34 = __toESM(require("react"));
var import_utils8 = require("@nubras/utils");
var import_jsx_runtime17 = require("react/jsx-runtime");
var alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
var Alert = React34.forwardRef((_a, ref2) => {
  var _b = _a, { className, variant } = _b, props2 = __objRest(_b, ["className", "variant"]);
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      role: "alert",
      className: (0, import_utils8.cn)(alertVariants({ variant }), className)
    }, props2)
  );
});
Alert.displayName = "Alert";
var AlertTitle = React34.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    "h5",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils8.cn)("mb-1 font-medium leading-none tracking-tight", className)
    }, props2)
  );
});
AlertTitle.displayName = "AlertTitle";
var AlertDescription = React34.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils8.cn)("text-sm [&_p]:leading-relaxed", className)
    }, props2)
  );
});
AlertDescription.displayName = "AlertDescription";

// ../../node_modules/.pnpm/@radix-ui+react-aspect-ratio@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_pcdvxkdtjiucxkeqlhyoly6tei/node_modules/@radix-ui/react-aspect-ratio/dist/index.mjs
var React35 = __toESM(require("react"), 1);
var import_jsx_runtime18 = require("react/jsx-runtime");
var NAME = "AspectRatio";
var AspectRatio = React35.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { ratio = 1 / 1, style: style2 } = _a, aspectRatioProps = __objRest(_a, ["ratio", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "div",
      {
        style: {
          // ensures inner element is contained
          position: "relative",
          // ensures padding bottom trick maths works
          width: "100%",
          paddingBottom: `${100 / ratio}%`
        },
        "data-radix-aspect-ratio-wrapper": "",
        children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          Primitive.div,
          __spreadProps(__spreadValues({}, aspectRatioProps), {
            ref: forwardedRef,
            style: __spreadProps(__spreadValues({}, style2), {
              // ensures children expand in ratio
              position: "absolute",
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            })
          })
        )
      }
    );
  }
);
AspectRatio.displayName = NAME;
var Root5 = AspectRatio;

// src/components/aspect-ratio.tsx
var AspectRatio2 = Root5;

// src/components/avatar.tsx
var React41 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-avatar@1.1.9_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_z7mpyyogzzs5nez4zxoktpy7dm/node_modules/@radix-ui/react-avatar/dist/index.mjs
var React40 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-context@1.1.2_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-context/dist/index.mjs
var React36 = __toESM(require("react"), 1);
var import_jsx_runtime19 = require("react/jsx-runtime");
function createContext22(rootComponentName, defaultContext) {
  const Context = React36.createContext(defaultContext);
  const Provider4 = (props2) => {
    const _a = props2, { children } = _a, context = __objRest(_a, ["children"]);
    const value = React36.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Context.Provider, { value, children });
  };
  Provider4.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React36.useContext(Context);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider4, useContext22];
}
function createContextScope2(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React36.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider4 = (props2) => {
      var _b;
      const _a = props2, { scope, children } = _a, context = __objRest(_a, ["scope", "children"]);
      const Context = ((_b = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _b[index2]) || BaseContext;
      const value = React36.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Context.Provider, { value, children });
    };
    Provider4.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const context = React36.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider4, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React36.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React36.useMemo(
        () => ({ [`__scope${scopeName}`]: __spreadProps(__spreadValues({}, scope), { [scopeName]: contexts }) }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes2(createScope, ...createContextScopeDeps)];
}
function composeContextScopes2(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return __spreadValues(__spreadValues({}, nextScopes2), currentScope);
      }, {});
      return React36.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../../node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React37 = __toESM(require("react"), 1);
function useCallbackRef3(callback) {
  const callbackRef = React37.useRef(callback);
  React37.useEffect(() => {
    callbackRef.current = callback;
  });
  return React37.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}

// ../../node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React38 = __toESM(require("react"), 1);
var useLayoutEffect22 = (globalThis == null ? void 0 : globalThis.document) ? React38.useLayoutEffect : () => {
};

// ../../node_modules/.pnpm/@radix-ui+react-primitive@2.1.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19._j7ilbky33jjr3inldc3okhyoqm/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React39 = __toESM(require("react"), 1);
var ReactDOM3 = __toESM(require("react-dom"), 1);
var import_jsx_runtime20 = require("react/jsx-runtime");
var NODES2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive2 = NODES2.reduce((primitive, node) => {
  const Slot4 = createSlot(`Primitive.${node}`);
  const Node2 = React39.forwardRef((props2, forwardedRef) => {
    const _a = props2, { asChild } = _a, primitiveProps = __objRest(_a, ["asChild"]);
    const Comp = asChild ? Slot4 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Comp, __spreadProps(__spreadValues({}, primitiveProps), { ref: forwardedRef }));
  });
  Node2.displayName = `Primitive.${node}`;
  return __spreadProps(__spreadValues({}, primitive), { [node]: Node2 });
}, {});
function dispatchDiscreteCustomEvent2(target, event) {
  if (target)
    ReactDOM3.flushSync(() => target.dispatchEvent(event));
}

// ../../node_modules/.pnpm/@radix-ui+react-use-is-hydrated@0.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-is-hydrated/dist/index.mjs
var import_shim = __toESM(require_shim(), 1);
function useIsHydrated() {
  return (0, import_shim.useSyncExternalStore)(
    subscribe,
    () => true,
    () => false
  );
}
function subscribe() {
  return () => {
  };
}

// ../../node_modules/.pnpm/@radix-ui+react-avatar@1.1.9_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_z7mpyyogzzs5nez4zxoktpy7dm/node_modules/@radix-ui/react-avatar/dist/index.mjs
var import_jsx_runtime21 = require("react/jsx-runtime");
var AVATAR_NAME = "Avatar";
var [createAvatarContext, createAvatarScope] = createContextScope2(AVATAR_NAME);
var [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
var Avatar = React40.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAvatar } = _a, avatarProps = __objRest(_a, ["__scopeAvatar"]);
    const [imageLoadingStatus, setImageLoadingStatus] = React40.useState("idle");
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      AvatarProvider,
      {
        scope: __scopeAvatar,
        imageLoadingStatus,
        onImageLoadingStatusChange: setImageLoadingStatus,
        children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Primitive2.span, __spreadProps(__spreadValues({}, avatarProps), { ref: forwardedRef }))
      }
    );
  }
);
Avatar.displayName = AVATAR_NAME;
var IMAGE_NAME = "AvatarImage";
var AvatarImage = React40.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAvatar, src, onLoadingStatusChange = () => {
    } } = _a, imageProps = __objRest(_a, ["__scopeAvatar", "src", "onLoadingStatusChange"]);
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = useImageLoadingStatus(src, imageProps);
    const handleLoadingStatusChange = useCallbackRef3((status) => {
      onLoadingStatusChange(status);
      context.onImageLoadingStatusChange(status);
    });
    useLayoutEffect22(() => {
      if (imageLoadingStatus !== "idle") {
        handleLoadingStatusChange(imageLoadingStatus);
      }
    }, [imageLoadingStatus, handleLoadingStatusChange]);
    return imageLoadingStatus === "loaded" ? /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Primitive2.img, __spreadProps(__spreadValues({}, imageProps), { ref: forwardedRef, src })) : null;
  }
);
AvatarImage.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback";
var AvatarFallback = React40.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeAvatar, delayMs } = _a, fallbackProps = __objRest(_a, ["__scopeAvatar", "delayMs"]);
    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = React40.useState(delayMs === void 0);
    React40.useEffect(() => {
      if (delayMs !== void 0) {
        const timerId = window.setTimeout(() => setCanRender(true), delayMs);
        return () => window.clearTimeout(timerId);
      }
    }, [delayMs]);
    return canRender && context.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Primitive2.span, __spreadProps(__spreadValues({}, fallbackProps), { ref: forwardedRef })) : null;
  }
);
AvatarFallback.displayName = FALLBACK_NAME;
function resolveLoadingStatus(image, src) {
  if (!image) {
    return "idle";
  }
  if (!src) {
    return "error";
  }
  if (image.src !== src) {
    image.src = src;
  }
  return image.complete && image.naturalWidth > 0 ? "loaded" : "loading";
}
function useImageLoadingStatus(src, { referrerPolicy, crossOrigin }) {
  const isHydrated = useIsHydrated();
  const imageRef = React40.useRef(null);
  const image = (() => {
    if (!isHydrated)
      return null;
    if (!imageRef.current) {
      imageRef.current = new window.Image();
    }
    return imageRef.current;
  })();
  const [loadingStatus, setLoadingStatus] = React40.useState(
    () => resolveLoadingStatus(image, src)
  );
  useLayoutEffect22(() => {
    setLoadingStatus(resolveLoadingStatus(image, src));
  }, [image, src]);
  useLayoutEffect22(() => {
    const updateStatus = (status) => () => {
      setLoadingStatus(status);
    };
    if (!image)
      return;
    const handleLoad = updateStatus("loaded");
    const handleError = updateStatus("error");
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (referrerPolicy) {
      image.referrerPolicy = referrerPolicy;
    }
    if (typeof crossOrigin === "string") {
      image.crossOrigin = crossOrigin;
    }
    return () => {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    };
  }, [image, crossOrigin, referrerPolicy]);
  return loadingStatus;
}
var Root6 = Avatar;
var Image = AvatarImage;
var Fallback = AvatarFallback;

// src/components/avatar.tsx
var import_utils9 = require("@nubras/utils");
var import_jsx_runtime22 = require("react/jsx-runtime");
var Avatar2 = React41.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
    Root6,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils9.cn)("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)
    }, props2)
  );
});
Avatar2.displayName = Root6.displayName;
var AvatarImage2 = React41.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(Image, __spreadValues({ ref: ref2, className: (0, import_utils9.cn)("aspect-square h-full w-full", className) }, props2));
});
AvatarImage2.displayName = Image.displayName;
var AvatarFallback2 = React41.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
    Fallback,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils9.cn)("flex h-full w-full items-center justify-center rounded-full bg-muted", className)
    }, props2)
  );
});
AvatarFallback2.displayName = Fallback.displayName;

// src/components/badge.tsx
var import_utils10 = require("@nubras/utils");
var import_jsx_runtime23 = require("react/jsx-runtime");
var badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        success: "border-transparent bg-green-500 text-white hover:bg-green-500/80",
        warning: "border-transparent bg-yellow-500 text-white hover:bg-yellow-500/80",
        info: "border-transparent bg-blue-500 text-white hover:bg-blue-500/80"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Badge(_a) {
  var _b = _a, { className, variant } = _b, props2 = __objRest(_b, ["className", "variant"]);
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", __spreadValues({ className: (0, import_utils10.cn)(badgeVariants({ variant }), className) }, props2));
}

// src/components/breadcrumb.tsx
var React42 = __toESM(require("react"));
var import_utils11 = require("@nubras/utils");
var import_jsx_runtime24 = require("react/jsx-runtime");
var Breadcrumb = React42.forwardRef((_a, ref2) => {
  var props2 = __objRest(_a, []);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("nav", __spreadValues({ ref: ref2, "aria-label": "breadcrumb" }, props2));
});
Breadcrumb.displayName = "Breadcrumb";
var BreadcrumbList = React42.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    "ol",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils11.cn)(
        "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
        className
      )
    }, props2)
  );
});
BreadcrumbList.displayName = "BreadcrumbList";
var BreadcrumbItem = React42.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    "li",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils11.cn)("inline-flex items-center gap-1.5", className)
    }, props2)
  );
});
BreadcrumbItem.displayName = "BreadcrumbItem";
var BreadcrumbLink = React42.forwardRef((_a, ref2) => {
  var _b = _a, { asChild, className } = _b, props2 = __objRest(_b, ["asChild", "className"]);
  const Comp = asChild ? Slot2 : "a";
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    Comp,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils11.cn)("transition-colors hover:text-foreground", className)
    }, props2)
  );
});
BreadcrumbLink.displayName = "BreadcrumbLink";
var BreadcrumbPage = React42.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    "span",
    __spreadValues({
      ref: ref2,
      role: "link",
      "aria-disabled": "true",
      "aria-current": "page",
      className: (0, import_utils11.cn)("font-normal text-foreground", className)
    }, props2)
  );
});
BreadcrumbPage.displayName = "BreadcrumbPage";
var BreadcrumbSeparator = (_a) => {
  var _b = _a, {
    children,
    className
  } = _b, props2 = __objRest(_b, [
    "children",
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    "li",
    __spreadProps(__spreadValues({
      role: "presentation",
      "aria-hidden": "true",
      className: (0, import_utils11.cn)("[&>svg]:w-3.5 [&>svg]:h-3.5", className)
    }, props2), {
      children: children != null ? children : /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(ChevronRight, {})
    })
  );
};
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";
var BreadcrumbEllipsis = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(
    "span",
    __spreadProps(__spreadValues({
      role: "presentation",
      "aria-hidden": "true",
      className: (0, import_utils11.cn)("flex h-9 w-9 items-center justify-center", className)
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(Ellipsis, { className: "h-4 w-4" }),
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("span", { className: "sr-only", children: "More" })
      ]
    })
  );
};
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis";

// src/components/calendar.tsx
var React78 = __toESM(require("react"));

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/DayPicker.js
var import_react37 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/UI.js
var UI;
(function(UI2) {
  UI2["Root"] = "root";
  UI2["Chevron"] = "chevron";
  UI2["Day"] = "day";
  UI2["DayButton"] = "day_button";
  UI2["CaptionLabel"] = "caption_label";
  UI2["Dropdowns"] = "dropdowns";
  UI2["Dropdown"] = "dropdown";
  UI2["DropdownRoot"] = "dropdown_root";
  UI2["Footer"] = "footer";
  UI2["MonthGrid"] = "month_grid";
  UI2["MonthCaption"] = "month_caption";
  UI2["MonthsDropdown"] = "months_dropdown";
  UI2["Month"] = "month";
  UI2["Months"] = "months";
  UI2["Nav"] = "nav";
  UI2["NextMonthButton"] = "button_next";
  UI2["PreviousMonthButton"] = "button_previous";
  UI2["Week"] = "week";
  UI2["Weeks"] = "weeks";
  UI2["Weekday"] = "weekday";
  UI2["Weekdays"] = "weekdays";
  UI2["WeekNumber"] = "week_number";
  UI2["WeekNumberHeader"] = "week_number_header";
  UI2["YearsDropdown"] = "years_dropdown";
})(UI || (UI = {}));
var DayFlag;
(function(DayFlag2) {
  DayFlag2["disabled"] = "disabled";
  DayFlag2["hidden"] = "hidden";
  DayFlag2["outside"] = "outside";
  DayFlag2["focused"] = "focused";
  DayFlag2["today"] = "today";
})(DayFlag || (DayFlag = {}));
var SelectionState;
(function(SelectionState2) {
  SelectionState2["range_end"] = "range_end";
  SelectionState2["range_middle"] = "range_middle";
  SelectionState2["range_start"] = "range_start";
  SelectionState2["selected"] = "selected";
})(SelectionState || (SelectionState = {}));
var Animation;
(function(Animation2) {
  Animation2["weeks_before_enter"] = "weeks_before_enter";
  Animation2["weeks_before_exit"] = "weeks_before_exit";
  Animation2["weeks_after_enter"] = "weeks_after_enter";
  Animation2["weeks_after_exit"] = "weeks_after_exit";
  Animation2["caption_after_enter"] = "caption_after_enter";
  Animation2["caption_after_exit"] = "caption_after_exit";
  Animation2["caption_before_enter"] = "caption_before_enter";
  Animation2["caption_before_exit"] = "caption_before_exit";
})(Animation || (Animation = {}));

// ../../node_modules/.pnpm/@date-fns+tz@1.2.0/node_modules/@date-fns/tz/constants/index.js
var constructFromSymbol = Symbol.for("constructDateFrom");

// ../../node_modules/.pnpm/@date-fns+tz@1.2.0/node_modules/@date-fns/tz/tzOffset/index.js
var offsetFormatCache = {};
var offsetCache = {};
function tzOffset(timeZone, date) {
  try {
    const format2 = offsetFormatCache[timeZone] || (offsetFormatCache[timeZone] = new Intl.DateTimeFormat("en-GB", {
      timeZone,
      hour: "numeric",
      timeZoneName: "longOffset"
    }).format);
    const offsetStr = format2(date).split("GMT")[1] || "";
    if (offsetStr in offsetCache)
      return offsetCache[offsetStr];
    return calcOffset(offsetStr, offsetStr.split(":"));
  } catch (e) {
    if (timeZone in offsetCache)
      return offsetCache[timeZone];
    const captures = timeZone == null ? void 0 : timeZone.match(offsetRe);
    if (captures)
      return calcOffset(timeZone, captures.slice(1));
    return NaN;
  }
}
var offsetRe = /([+-]\d\d):?(\d\d)?/;
function calcOffset(cacheStr, values) {
  const hours = +values[0];
  const minutes = +(values[1] || 0);
  return offsetCache[cacheStr] = hours > 0 ? hours * 60 + minutes : hours * 60 - minutes;
}

// ../../node_modules/.pnpm/@date-fns+tz@1.2.0/node_modules/@date-fns/tz/date/mini.js
var TZDateMini = class _TZDateMini extends Date {
  //#region static
  constructor(...args) {
    super();
    if (args.length > 1 && typeof args[args.length - 1] === "string") {
      this.timeZone = args.pop();
    }
    this.internal = /* @__PURE__ */ new Date();
    if (isNaN(tzOffset(this.timeZone, this))) {
      this.setTime(NaN);
    } else {
      if (!args.length) {
        this.setTime(Date.now());
      } else if (typeof args[0] === "number" && (args.length === 1 || args.length === 2 && typeof args[1] !== "number")) {
        this.setTime(args[0]);
      } else if (typeof args[0] === "string") {
        this.setTime(+new Date(args[0]));
      } else if (args[0] instanceof Date) {
        this.setTime(+args[0]);
      } else {
        this.setTime(+new Date(...args));
        adjustToSystemTZ(this, NaN);
        syncToInternal(this);
      }
    }
  }
  static tz(tz, ...args) {
    return args.length ? new _TZDateMini(...args, tz) : new _TZDateMini(Date.now(), tz);
  }
  //#endregion
  //#region time zone
  withTimeZone(timeZone) {
    return new _TZDateMini(+this, timeZone);
  }
  getTimezoneOffset() {
    return -tzOffset(this.timeZone, this);
  }
  //#endregion
  //#region time
  setTime(time) {
    Date.prototype.setTime.apply(this, arguments);
    syncToInternal(this);
    return +this;
  }
  //#endregion
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](date) {
    return new _TZDateMini(+new Date(date), this.timeZone);
  }
  //#endregion
};
var re = /^(get|set)(?!UTC)/;
Object.getOwnPropertyNames(Date.prototype).forEach((method) => {
  if (!re.test(method))
    return;
  const utcMethod = method.replace(re, "$1UTC");
  if (!TZDateMini.prototype[utcMethod])
    return;
  if (method.startsWith("get")) {
    TZDateMini.prototype[method] = function() {
      return this.internal[utcMethod]();
    };
  } else {
    TZDateMini.prototype[method] = function() {
      Date.prototype[utcMethod].apply(this.internal, arguments);
      syncFromInternal(this);
      return +this;
    };
    TZDateMini.prototype[utcMethod] = function() {
      Date.prototype[utcMethod].apply(this, arguments);
      syncToInternal(this);
      return +this;
    };
  }
});
function syncToInternal(date) {
  date.internal.setTime(+date);
  date.internal.setUTCMinutes(date.internal.getUTCMinutes() - date.getTimezoneOffset());
}
function syncFromInternal(date) {
  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());
  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());
  adjustToSystemTZ(date);
}
function adjustToSystemTZ(date) {
  const offset6 = tzOffset(date.timeZone, date);
  const prevHour = /* @__PURE__ */ new Date(+date);
  prevHour.setUTCHours(prevHour.getUTCHours() - 1);
  const systemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const prevHourSystemOffset = -(/* @__PURE__ */ new Date(+prevHour)).getTimezoneOffset();
  const systemDSTChange = systemOffset - prevHourSystemOffset;
  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();
  if (systemDSTChange && dstShift)
    date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);
  const offsetDiff = systemOffset - offset6;
  if (offsetDiff)
    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);
  const postOffset = tzOffset(date.timeZone, date);
  const postSystemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const postOffsetDiff = postSystemOffset - postOffset;
  const offsetChanged = postOffset !== offset6;
  const postDiff = postOffsetDiff - offsetDiff;
  if (offsetChanged && postDiff) {
    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);
    const newOffset = tzOffset(date.timeZone, date);
    const offsetChange = postOffset - newOffset;
    if (offsetChange) {
      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);
      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);
    }
  }
}

// ../../node_modules/.pnpm/@date-fns+tz@1.2.0/node_modules/@date-fns/tz/date/index.js
var TZDate = class _TZDate extends TZDateMini {
  //#region static
  static tz(tz, ...args) {
    return args.length ? new _TZDate(...args, tz) : new _TZDate(Date.now(), tz);
  }
  //#endregion
  //#region representation
  toISOString() {
    const [sign, hours, minutes] = this.tzComponents();
    const tz = `${sign}${hours}:${minutes}`;
    return this.internal.toISOString().slice(0, -1) + tz;
  }
  toString() {
    return `${this.toDateString()} ${this.toTimeString()}`;
  }
  toDateString() {
    const [day, date, month, year] = this.internal.toUTCString().split(" ");
    return `${day == null ? void 0 : day.slice(0, -1)} ${month} ${date} ${year}`;
  }
  toTimeString() {
    const time = this.internal.toUTCString().split(" ")[4];
    const [sign, hours, minutes] = this.tzComponents();
    return `${time} GMT${sign}${hours}${minutes} (${tzName(this.timeZone, this)})`;
  }
  toLocaleString(locales, options) {
    return Date.prototype.toLocaleString.call(this, locales, __spreadProps(__spreadValues({}, options), {
      timeZone: (options == null ? void 0 : options.timeZone) || this.timeZone
    }));
  }
  toLocaleDateString(locales, options) {
    return Date.prototype.toLocaleDateString.call(this, locales, __spreadProps(__spreadValues({}, options), {
      timeZone: (options == null ? void 0 : options.timeZone) || this.timeZone
    }));
  }
  toLocaleTimeString(locales, options) {
    return Date.prototype.toLocaleTimeString.call(this, locales, __spreadProps(__spreadValues({}, options), {
      timeZone: (options == null ? void 0 : options.timeZone) || this.timeZone
    }));
  }
  //#endregion
  //#region private
  tzComponents() {
    const offset6 = this.getTimezoneOffset();
    const sign = offset6 > 0 ? "-" : "+";
    const hours = String(Math.floor(Math.abs(offset6) / 60)).padStart(2, "0");
    const minutes = String(Math.abs(offset6) % 60).padStart(2, "0");
    return [sign, hours, minutes];
  }
  //#endregion
  withTimeZone(timeZone) {
    return new _TZDate(+this, timeZone);
  }
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](date) {
    return new _TZDate(+new Date(date), this.timeZone);
  }
  //#endregion
};
function tzName(tz, date) {
  return new Intl.DateTimeFormat("en-GB", {
    timeZone: tz,
    timeZoneName: "long"
  }).format(date).slice(12);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/constants.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInDay = 864e5;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
var constructFromSymbol2 = Symbol.for("constructDateFrom");

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/constructFrom.js
function constructFrom(date, value) {
  if (typeof date === "function")
    return date(value);
  if (date && typeof date === "object" && constructFromSymbol2 in date)
    return date[constructFromSymbol2](value);
  if (date instanceof Date)
    return new date.constructor(value);
  return new Date(value);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/toDate.js
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/addDays.js
function addDays(date, amount, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(amount))
    return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  if (!amount)
    return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/addMonths.js
function addMonths(date, amount, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(amount))
    return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom((options == null ? void 0 : options.in) || date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/defaultOptions.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/startOfWeek.js
function startOfWeek(date, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions4 = getDefaultOptions();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions4.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions4.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/startOfISOWeek.js
function startOfISOWeek(date, options) {
  return startOfWeek(date, __spreadProps(__spreadValues({}, options), { weekStartsOn: 1 }));
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getISOWeekYear.js
function getISOWeekYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/normalizeDates.js
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/startOfDay.js
function startOfDay(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/differenceInCalendarDays.js
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/startOfISOWeekYear.js
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom((options == null ? void 0 : options.in) || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/addWeeks.js
function addWeeks(date, amount, options) {
  return addDays(date, amount * 7, options);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/addYears.js
function addYears(date, amount, options) {
  return addMonths(date, amount * 12, options);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/max.js
function max(dates, options) {
  let result;
  let context = options == null ? void 0 : options.in;
  dates.forEach((date) => {
    if (!context && typeof date === "object")
      context = constructFrom.bind(null, date);
    const date_ = toDate(date, context);
    if (!result || result < date_ || isNaN(+date_))
      result = date_;
  });
  return constructFrom(context, result || NaN);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/min.js
function min(dates, options) {
  let result;
  let context = options == null ? void 0 : options.in;
  dates.forEach((date) => {
    if (!context && typeof date === "object")
      context = constructFrom.bind(null, date);
    const date_ = toDate(date, context);
    if (!result || result > date_ || isNaN(+date_))
      result = date_;
  });
  return constructFrom(context, result || NaN);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/isSameDay.js
function isSameDay(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return +startOfDay(dateLeft_) === +startOfDay(dateRight_);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/isDate.js
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/isValid.js
function isValid(date) {
  return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/differenceInCalendarMonths.js
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/endOfMonth.js
function endOfMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/normalizeInterval.js
function normalizeInterval(context, interval) {
  const [start2, end2] = normalizeDates(context, interval.start, interval.end);
  return { start: start2, end: end2 };
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/eachMonthOfInterval.js
function eachMonthOfInterval(interval, options) {
  var _a;
  const { start: start2, end: end2 } = normalizeInterval(options == null ? void 0 : options.in, interval);
  let reversed = +start2 > +end2;
  const endTime = reversed ? +start2 : +end2;
  const date = reversed ? end2 : start2;
  date.setHours(0, 0, 0, 0);
  date.setDate(1);
  let step = (_a = options == null ? void 0 : options.step) != null ? _a : 1;
  if (!step)
    return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start2, date));
    date.setMonth(date.getMonth() + step);
  }
  return reversed ? dates.reverse() : dates;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/startOfMonth.js
function startOfMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/endOfYear.js
function endOfYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/startOfYear.js
function startOfYear(date, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/endOfWeek.js
function endOfWeek(date, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions4 = getDefaultOptions();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions4.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions4.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/endOfISOWeek.js
function endOfISOWeek(date, options) {
  return endOfWeek(date, __spreadProps(__spreadValues({}, options), { weekStartsOn: 1 }));
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/en-US/_lib/formatDistance.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count7, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count7 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count7.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/_lib/buildFormatLongFn.js
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/en-US/_lib/formatLong.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/en-US/_lib/formatRelative.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/_lib/buildLocalizeFn.js
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/en-US/_lib/localize.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/_lib/buildMatchFn.js
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/en-US/_lib/match.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/en-US.js
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getDayOfYear.js
function getDayOfYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getISOWeek.js
function getISOWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getWeekYear.js
function getWeekYear(date, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const defaultOptions4 = getDefaultOptions();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions4.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions4.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/startOfWeekYear.js
function startOfWeekYear(date, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions4 = getDefaultOptions();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions4.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions4.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getWeek.js
function getWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/addLeadingZeros.js
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/format/lightFormatters.js
var lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/format/formatters.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    return addLeadingZeros(+date, token.length);
  }
};
function formatTimezoneShort(offset6, delimiter = "") {
  const sign = offset6 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset6);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset6, delimiter) {
  if (offset6 % 60 === 0) {
    const sign = offset6 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset6) / 60, 2);
  }
  return formatTimezone(offset6, delimiter);
}
function formatTimezone(offset6, delimiter = "") {
  const sign = offset6 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset6);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/format/longFormatters.js
var dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/_lib/protectedTokens.js
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token))
    throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/format.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const defaultOptions4 = getDefaultOptions();
  const locale = (_b = (_a = options == null ? void 0 : options.locale) != null ? _a : defaultOptions4.locale) != null ? _b : enUS;
  const firstWeekContainsDate = (_j = (_i = (_f = (_e = options == null ? void 0 : options.firstWeekContainsDate) != null ? _e : (_d = (_c = options == null ? void 0 : options.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) != null ? _f : defaultOptions4.firstWeekContainsDate) != null ? _i : (_h = (_g = defaultOptions4.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.firstWeekContainsDate) != null ? _j : 1;
  const weekStartsOn = (_r = (_q = (_n = (_m = options == null ? void 0 : options.weekStartsOn) != null ? _m : (_l = (_k = options == null ? void 0 : options.locale) == null ? void 0 : _k.options) == null ? void 0 : _l.weekStartsOn) != null ? _n : defaultOptions4.weekStartsOn) != null ? _q : (_p = (_o = defaultOptions4.locale) == null ? void 0 : _o.options) == null ? void 0 : _p.weekStartsOn) != null ? _r : 0;
  const originalDate = toDate(date, options == null ? void 0 : options.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken)
      return part.value;
    const token = part.value;
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getDaysInMonth.js
function getDaysInMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth = constructFrom(_date, 0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getMonth.js
function getMonth(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getMonth();
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/getYear.js
function getYear(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getFullYear();
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/isAfter.js
function isAfter(date, dateToCompare) {
  return +toDate(date) > +toDate(dateToCompare);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/isBefore.js
function isBefore(date, dateToCompare) {
  return +toDate(date) < +toDate(dateToCompare);
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/isSameMonth.js
function isSameMonth(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() === earlierDate_.getFullYear() && laterDate_.getMonth() === earlierDate_.getMonth();
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/isSameYear.js
function isSameYear(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() === earlierDate_.getFullYear();
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/setMonth.js
function setMonth(date, month, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const midMonth = constructFrom((options == null ? void 0 : options.in) || date, 0);
  midMonth.setFullYear(year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}

// ../../node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/setYear.js
function setYear(date, year, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(+date_))
    return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  date_.setFullYear(year);
  return date_;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getBroadcastWeeksInMonth.js
var FIVE_WEEKS = 5;
var FOUR_WEEKS = 4;
function getBroadcastWeeksInMonth(month, dateLib) {
  const firstDayOfMonth = dateLib.startOfMonth(month);
  const firstDayOfWeek = firstDayOfMonth.getDay() > 0 ? firstDayOfMonth.getDay() : 7;
  const broadcastStartDate = dateLib.addDays(month, -firstDayOfWeek + 1);
  const lastDateOfLastWeek = dateLib.addDays(broadcastStartDate, FIVE_WEEKS * 7 - 1);
  const numberOfWeeks = dateLib.getMonth(month) === dateLib.getMonth(lastDateOfLastWeek) ? FIVE_WEEKS : FOUR_WEEKS;
  return numberOfWeeks;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/startOfBroadcastWeek.js
function startOfBroadcastWeek(date, dateLib) {
  const firstOfMonth = dateLib.startOfMonth(date);
  const dayOfWeek = firstOfMonth.getDay();
  if (dayOfWeek === 1) {
    return firstOfMonth;
  } else if (dayOfWeek === 0) {
    return dateLib.addDays(firstOfMonth, -1 * 6);
  } else {
    return dateLib.addDays(firstOfMonth, -1 * (dayOfWeek - 1));
  }
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/endOfBroadcastWeek.js
function endOfBroadcastWeek(date, dateLib) {
  const startDate = startOfBroadcastWeek(date, dateLib);
  const numberOfWeeks = getBroadcastWeeksInMonth(date, dateLib);
  const endDate = dateLib.addDays(startDate, numberOfWeeks * 7 - 1);
  return endDate;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/classes/DateLib.js
var DateLib = class {
  /**
   * Creates an instance of DateLib.
   *
   * @param options The options for the date library.
   * @param overrides Overrides for the date library functions.
   */
  constructor(options, overrides) {
    this.Date = Date;
    this.today = () => {
      var _a;
      if ((_a = this.overrides) == null ? void 0 : _a.today) {
        return this.overrides.today();
      }
      if (this.options.timeZone) {
        return TZDate.tz(this.options.timeZone);
      }
      return new this.Date();
    };
    this.newDate = (year, monthIndex, date) => {
      var _a;
      if ((_a = this.overrides) == null ? void 0 : _a.newDate) {
        return this.overrides.newDate(year, monthIndex, date);
      }
      if (this.options.timeZone) {
        return new TZDate(year, monthIndex, date, this.options.timeZone);
      }
      return new Date(year, monthIndex, date);
    };
    this.addDays = (date, amount) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.addDays) ? this.overrides.addDays(date, amount) : addDays(date, amount);
    };
    this.addMonths = (date, amount) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.addMonths) ? this.overrides.addMonths(date, amount) : addMonths(date, amount);
    };
    this.addWeeks = (date, amount) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.addWeeks) ? this.overrides.addWeeks(date, amount) : addWeeks(date, amount);
    };
    this.addYears = (date, amount) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.addYears) ? this.overrides.addYears(date, amount) : addYears(date, amount);
    };
    this.differenceInCalendarDays = (dateLeft, dateRight) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.differenceInCalendarDays) ? this.overrides.differenceInCalendarDays(dateLeft, dateRight) : differenceInCalendarDays(dateLeft, dateRight);
    };
    this.differenceInCalendarMonths = (dateLeft, dateRight) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.differenceInCalendarMonths) ? this.overrides.differenceInCalendarMonths(dateLeft, dateRight) : differenceInCalendarMonths(dateLeft, dateRight);
    };
    this.eachMonthOfInterval = (interval) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.eachMonthOfInterval) ? this.overrides.eachMonthOfInterval(interval) : eachMonthOfInterval(interval);
    };
    this.endOfBroadcastWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.endOfBroadcastWeek) ? this.overrides.endOfBroadcastWeek(date, this) : endOfBroadcastWeek(date, this);
    };
    this.endOfISOWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.endOfISOWeek) ? this.overrides.endOfISOWeek(date) : endOfISOWeek(date);
    };
    this.endOfMonth = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.endOfMonth) ? this.overrides.endOfMonth(date) : endOfMonth(date);
    };
    this.endOfWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.endOfWeek) ? this.overrides.endOfWeek(date, this.options) : endOfWeek(date, this.options);
    };
    this.endOfYear = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.endOfYear) ? this.overrides.endOfYear(date) : endOfYear(date);
    };
    this.format = (date, formatStr) => {
      var _a;
      const formatted = ((_a = this.overrides) == null ? void 0 : _a.format) ? this.overrides.format(date, formatStr, this.options) : format(date, formatStr, this.options);
      if (this.options.numerals && this.options.numerals !== "latn") {
        return this.replaceDigits(formatted);
      }
      return formatted;
    };
    this.getISOWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.getISOWeek) ? this.overrides.getISOWeek(date) : getISOWeek(date);
    };
    this.getMonth = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.getMonth) ? this.overrides.getMonth(date, this.options) : getMonth(date, this.options);
    };
    this.getYear = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.getYear) ? this.overrides.getYear(date, this.options) : getYear(date, this.options);
    };
    this.getWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.getWeek) ? this.overrides.getWeek(date, this.options) : getWeek(date, this.options);
    };
    this.isAfter = (date, dateToCompare) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.isAfter) ? this.overrides.isAfter(date, dateToCompare) : isAfter(date, dateToCompare);
    };
    this.isBefore = (date, dateToCompare) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.isBefore) ? this.overrides.isBefore(date, dateToCompare) : isBefore(date, dateToCompare);
    };
    this.isDate = (value) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.isDate) ? this.overrides.isDate(value) : isDate(value);
    };
    this.isSameDay = (dateLeft, dateRight) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.isSameDay) ? this.overrides.isSameDay(dateLeft, dateRight) : isSameDay(dateLeft, dateRight);
    };
    this.isSameMonth = (dateLeft, dateRight) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.isSameMonth) ? this.overrides.isSameMonth(dateLeft, dateRight) : isSameMonth(dateLeft, dateRight);
    };
    this.isSameYear = (dateLeft, dateRight) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.isSameYear) ? this.overrides.isSameYear(dateLeft, dateRight) : isSameYear(dateLeft, dateRight);
    };
    this.max = (dates) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.max) ? this.overrides.max(dates) : max(dates);
    };
    this.min = (dates) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.min) ? this.overrides.min(dates) : min(dates);
    };
    this.setMonth = (date, month) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.setMonth) ? this.overrides.setMonth(date, month) : setMonth(date, month);
    };
    this.setYear = (date, year) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.setYear) ? this.overrides.setYear(date, year) : setYear(date, year);
    };
    this.startOfBroadcastWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.startOfBroadcastWeek) ? this.overrides.startOfBroadcastWeek(date, this) : startOfBroadcastWeek(date, this);
    };
    this.startOfDay = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.startOfDay) ? this.overrides.startOfDay(date) : startOfDay(date);
    };
    this.startOfISOWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.startOfISOWeek) ? this.overrides.startOfISOWeek(date) : startOfISOWeek(date);
    };
    this.startOfMonth = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.startOfMonth) ? this.overrides.startOfMonth(date) : startOfMonth(date);
    };
    this.startOfWeek = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.startOfWeek) ? this.overrides.startOfWeek(date, this.options) : startOfWeek(date, this.options);
    };
    this.startOfYear = (date) => {
      var _a;
      return ((_a = this.overrides) == null ? void 0 : _a.startOfYear) ? this.overrides.startOfYear(date) : startOfYear(date);
    };
    this.options = __spreadValues({ locale: enUS }, options);
    this.overrides = overrides;
  }
  /**
   * Generate digit map dynamically using Intl.NumberFormat.
   *
   * @since 9.5.0
   */
  getDigitMap() {
    const { numerals = "latn" } = this.options;
    const formatter = new Intl.NumberFormat("en-US", {
      numberingSystem: numerals
    });
    const digitMap = {};
    for (let i = 0; i < 10; i++) {
      digitMap[i.toString()] = formatter.format(i);
    }
    return digitMap;
  }
  /**
   * Replace Arabic digits with the target numbering system digits.
   *
   * @since 9.5.0
   */
  replaceDigits(input) {
    const digitMap = this.getDigitMap();
    return input.replace(/\d/g, (digit) => digitMap[digit] || digit);
  }
  /**
   * Format number using the custom numbering system.
   *
   * @since 9.5.0
   * @param value The number to format.
   * @returns The formatted number.
   */
  formatNumber(value) {
    return this.replaceDigits(value.toString());
  }
};
var defaultDateLib = new DateLib();

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getClassNamesForModifiers.js
function getClassNamesForModifiers(modifiers, classNames, modifiersClassNames = {}) {
  const modifierClassNames = Object.entries(modifiers).filter(([, active]) => active === true).reduce((previousValue, [key]) => {
    if (modifiersClassNames[key]) {
      previousValue.push(modifiersClassNames[key]);
    } else if (classNames[DayFlag[key]]) {
      previousValue.push(classNames[DayFlag[key]]);
    } else if (classNames[SelectionState[key]]) {
      previousValue.push(classNames[SelectionState[key]]);
    }
    return previousValue;
  }, [classNames[UI.Day]]);
  return modifierClassNames;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/custom-components.js
var custom_components_exports = {};
__export(custom_components_exports, {
  Button: () => Button2,
  CaptionLabel: () => CaptionLabel,
  Chevron: () => Chevron,
  Day: () => Day,
  DayButton: () => DayButton,
  Dropdown: () => Dropdown,
  DropdownNav: () => DropdownNav,
  Footer: () => Footer,
  Month: () => Month,
  MonthCaption: () => MonthCaption,
  MonthGrid: () => MonthGrid,
  Months: () => Months,
  MonthsDropdown: () => MonthsDropdown,
  Nav: () => Nav,
  NextMonthButton: () => NextMonthButton,
  Option: () => Option,
  PreviousMonthButton: () => PreviousMonthButton,
  Root: () => Root7,
  Select: () => Select,
  Week: () => Week,
  WeekNumber: () => WeekNumber,
  WeekNumberHeader: () => WeekNumberHeader,
  Weekday: () => Weekday,
  Weekdays: () => Weekdays,
  Weeks: () => Weeks,
  YearsDropdown: () => YearsDropdown
});

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Button.js
var import_react6 = __toESM(require("react"), 1);
function Button2(props2) {
  return import_react6.default.createElement("button", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/CaptionLabel.js
var import_react7 = __toESM(require("react"), 1);
function CaptionLabel(props2) {
  return import_react7.default.createElement("span", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Chevron.js
var import_react8 = __toESM(require("react"), 1);
function Chevron(props2) {
  const { size: size4 = 24, orientation = "left", className } = props2;
  return import_react8.default.createElement(
    "svg",
    { className, width: size4, height: size4, viewBox: "0 0 24 24" },
    orientation === "up" && import_react8.default.createElement("polygon", { points: "6.77 17 12.5 11.43 18.24 17 20 15.28 12.5 8 5 15.28" }),
    orientation === "down" && import_react8.default.createElement("polygon", { points: "6.77 8 12.5 13.57 18.24 8 20 9.72 12.5 17 5 9.72" }),
    orientation === "left" && import_react8.default.createElement("polygon", { points: "16 18.112 9.81111111 12 16 5.87733333 14.0888889 4 6 12 14.0888889 20" }),
    orientation === "right" && import_react8.default.createElement("polygon", { points: "8 18.112 14.18888889 12 8 5.87733333 9.91111111 4 18 12 9.91111111 20" })
  );
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Day.js
var import_react9 = __toESM(require("react"), 1);
function Day(props2) {
  const _a = props2, { day, modifiers } = _a, tdProps = __objRest(_a, ["day", "modifiers"]);
  return import_react9.default.createElement("td", __spreadValues({}, tdProps));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/DayButton.js
var import_react10 = __toESM(require("react"), 1);
function DayButton(props2) {
  const _a = props2, { day, modifiers } = _a, buttonProps = __objRest(_a, ["day", "modifiers"]);
  const ref2 = import_react10.default.useRef(null);
  import_react10.default.useEffect(() => {
    var _a2;
    if (modifiers.focused)
      (_a2 = ref2.current) == null ? void 0 : _a2.focus();
  }, [modifiers.focused]);
  return import_react10.default.createElement("button", __spreadValues({ ref: ref2 }, buttonProps));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Dropdown.js
var import_react11 = __toESM(require("react"), 1);
function Dropdown(props2) {
  const _a = props2, { options, className, components, classNames } = _a, selectProps = __objRest(_a, ["options", "className", "components", "classNames"]);
  const cssClassSelect = [classNames[UI.Dropdown], className].join(" ");
  const selectedOption = options == null ? void 0 : options.find(({ value }) => value === selectProps.value);
  return import_react11.default.createElement(
    "span",
    { "data-disabled": selectProps.disabled, className: classNames[UI.DropdownRoot] },
    import_react11.default.createElement(components.Select, __spreadValues({ className: cssClassSelect }, selectProps), options == null ? void 0 : options.map(({ value, label, disabled }) => import_react11.default.createElement(components.Option, { key: value, value, disabled }, label))),
    import_react11.default.createElement(
      "span",
      { className: classNames[UI.CaptionLabel], "aria-hidden": true },
      selectedOption == null ? void 0 : selectedOption.label,
      import_react11.default.createElement(components.Chevron, { orientation: "down", size: 18, className: classNames[UI.Chevron] })
    )
  );
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/DropdownNav.js
var import_react12 = __toESM(require("react"), 1);
function DropdownNav(props2) {
  return import_react12.default.createElement("div", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Footer.js
var import_react13 = __toESM(require("react"), 1);
function Footer(props2) {
  return import_react13.default.createElement("div", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Month.js
var import_react14 = __toESM(require("react"), 1);
function Month(props2) {
  const _a = props2, { calendarMonth, displayIndex } = _a, divProps = __objRest(_a, ["calendarMonth", "displayIndex"]);
  return import_react14.default.createElement("div", __spreadValues({}, divProps), props2.children);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/MonthCaption.js
var import_react15 = __toESM(require("react"), 1);
function MonthCaption(props2) {
  const _a = props2, { calendarMonth, displayIndex } = _a, divProps = __objRest(_a, ["calendarMonth", "displayIndex"]);
  return import_react15.default.createElement("div", __spreadValues({}, divProps));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/MonthGrid.js
var import_react16 = __toESM(require("react"), 1);
function MonthGrid(props2) {
  return import_react16.default.createElement("table", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Months.js
var import_react17 = __toESM(require("react"), 1);
function Months(props2) {
  return import_react17.default.createElement("div", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/MonthsDropdown.js
var import_react19 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useDayPicker.js
var import_react18 = require("react");
var dayPickerContext = (0, import_react18.createContext)(void 0);
function useDayPicker() {
  const context = (0, import_react18.useContext)(dayPickerContext);
  if (context === void 0) {
    throw new Error("useDayPicker() must be used within a custom component.");
  }
  return context;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/MonthsDropdown.js
function MonthsDropdown(props2) {
  const { components } = useDayPicker();
  return import_react19.default.createElement(components.Dropdown, __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Nav.js
var import_react20 = __toESM(require("react"), 1);
function Nav(props2) {
  const _a = props2, { onPreviousClick, onNextClick, previousMonth, nextMonth } = _a, navProps = __objRest(_a, ["onPreviousClick", "onNextClick", "previousMonth", "nextMonth"]);
  const { components, classNames, labels: { labelPrevious: labelPrevious2, labelNext: labelNext2 } } = useDayPicker();
  const handleNextClick = (0, import_react20.useCallback)((e) => {
    if (nextMonth) {
      onNextClick == null ? void 0 : onNextClick(e);
    }
  }, [nextMonth, onNextClick]);
  const handlePreviousClick = (0, import_react20.useCallback)((e) => {
    if (previousMonth) {
      onPreviousClick == null ? void 0 : onPreviousClick(e);
    }
  }, [previousMonth, onPreviousClick]);
  return import_react20.default.createElement(
    "nav",
    __spreadValues({}, navProps),
    import_react20.default.createElement(
      components.PreviousMonthButton,
      { type: "button", className: classNames[UI.PreviousMonthButton], tabIndex: previousMonth ? void 0 : -1, "aria-disabled": previousMonth ? void 0 : true, "aria-label": labelPrevious2(previousMonth), onClick: handlePreviousClick },
      import_react20.default.createElement(components.Chevron, { disabled: previousMonth ? void 0 : true, className: classNames[UI.Chevron], orientation: "left" })
    ),
    import_react20.default.createElement(
      components.NextMonthButton,
      { type: "button", className: classNames[UI.NextMonthButton], tabIndex: nextMonth ? void 0 : -1, "aria-disabled": nextMonth ? void 0 : true, "aria-label": labelNext2(nextMonth), onClick: handleNextClick },
      import_react20.default.createElement(components.Chevron, { disabled: nextMonth ? void 0 : true, orientation: "right", className: classNames[UI.Chevron] })
    )
  );
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/NextMonthButton.js
var import_react21 = __toESM(require("react"), 1);
function NextMonthButton(props2) {
  const { components } = useDayPicker();
  return import_react21.default.createElement(components.Button, __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Option.js
var import_react22 = __toESM(require("react"), 1);
function Option(props2) {
  return import_react22.default.createElement("option", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/PreviousMonthButton.js
var import_react23 = __toESM(require("react"), 1);
function PreviousMonthButton(props2) {
  const { components } = useDayPicker();
  return import_react23.default.createElement(components.Button, __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Root.js
var import_react24 = __toESM(require("react"), 1);
function Root7(props2) {
  const _a = props2, { rootRef } = _a, rest = __objRest(_a, ["rootRef"]);
  return import_react24.default.createElement("div", __spreadProps(__spreadValues({}, rest), { ref: rootRef }));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Select.js
var import_react25 = __toESM(require("react"), 1);
function Select(props2) {
  return import_react25.default.createElement("select", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Week.js
var import_react26 = __toESM(require("react"), 1);
function Week(props2) {
  const _a = props2, { week } = _a, trProps = __objRest(_a, ["week"]);
  return import_react26.default.createElement("tr", __spreadValues({}, trProps));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Weekday.js
var import_react27 = __toESM(require("react"), 1);
function Weekday(props2) {
  return import_react27.default.createElement("th", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Weekdays.js
var import_react28 = __toESM(require("react"), 1);
function Weekdays(props2) {
  return import_react28.default.createElement(
    "thead",
    { "aria-hidden": true },
    import_react28.default.createElement("tr", __spreadValues({}, props2))
  );
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/WeekNumber.js
var import_react29 = __toESM(require("react"), 1);
function WeekNumber(props2) {
  const _a = props2, { week } = _a, thProps = __objRest(_a, ["week"]);
  return import_react29.default.createElement("th", __spreadValues({}, thProps));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/WeekNumberHeader.js
var import_react30 = __toESM(require("react"), 1);
function WeekNumberHeader(props2) {
  return import_react30.default.createElement("th", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/Weeks.js
var import_react31 = __toESM(require("react"), 1);
function Weeks(props2) {
  return import_react31.default.createElement("tbody", __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/components/YearsDropdown.js
var import_react32 = __toESM(require("react"), 1);
function YearsDropdown(props2) {
  const { components } = useDayPicker();
  return import_react32.default.createElement(components.Dropdown, __spreadValues({}, props2));
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getComponents.js
function getComponents(customComponents) {
  return __spreadValues(__spreadValues({}, custom_components_exports), customComponents);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getDataAttributes.js
function getDataAttributes(props2) {
  var _a;
  const dataAttributes = {
    "data-mode": (_a = props2.mode) != null ? _a : void 0,
    "data-required": "required" in props2 ? props2.required : void 0,
    "data-multiple-months": props2.numberOfMonths && props2.numberOfMonths > 1 || void 0,
    "data-week-numbers": props2.showWeekNumber || void 0,
    "data-broadcast-calendar": props2.broadcastCalendar || void 0
  };
  Object.entries(props2).forEach(([key, val]) => {
    if (key.startsWith("data-")) {
      dataAttributes[key] = val;
    }
  });
  return dataAttributes;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getDefaultClassNames.js
function getDefaultClassNames() {
  const classNames = {};
  for (const key in UI) {
    classNames[UI[key]] = `rdp-${UI[key]}`;
  }
  for (const key in DayFlag) {
    classNames[DayFlag[key]] = `rdp-${DayFlag[key]}`;
  }
  for (const key in SelectionState) {
    classNames[SelectionState[key]] = `rdp-${SelectionState[key]}`;
  }
  for (const key in Animation) {
    classNames[Animation[key]] = `rdp-${Animation[key]}`;
  }
  return classNames;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/index.js
var formatters_exports = {};
__export(formatters_exports, {
  formatCaption: () => formatCaption,
  formatDay: () => formatDay,
  formatMonthCaption: () => formatMonthCaption,
  formatMonthDropdown: () => formatMonthDropdown,
  formatWeekNumber: () => formatWeekNumber,
  formatWeekNumberHeader: () => formatWeekNumberHeader,
  formatWeekdayName: () => formatWeekdayName,
  formatYearCaption: () => formatYearCaption,
  formatYearDropdown: () => formatYearDropdown
});

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/formatCaption.js
function formatCaption(month, options, dateLib) {
  return (dateLib != null ? dateLib : new DateLib(options)).format(month, "LLLL y");
}
var formatMonthCaption = formatCaption;

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/formatDay.js
function formatDay(date, options, dateLib) {
  return (dateLib != null ? dateLib : new DateLib(options)).format(date, "d");
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/formatMonthDropdown.js
function formatMonthDropdown(month, dateLib = defaultDateLib) {
  return dateLib.format(month, "LLLL");
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/formatWeekNumber.js
function formatWeekNumber(weekNumber) {
  if (weekNumber < 10) {
    return `0${weekNumber.toLocaleString()}`;
  }
  return `${weekNumber.toLocaleString()}`;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/formatWeekNumberHeader.js
function formatWeekNumberHeader() {
  return ``;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/formatWeekdayName.js
function formatWeekdayName(weekday, options, dateLib) {
  return (dateLib != null ? dateLib : new DateLib(options)).format(weekday, "cccccc");
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/formatters/formatYearDropdown.js
function formatYearDropdown(year, dateLib = defaultDateLib) {
  return dateLib.format(year, "yyyy");
}
var formatYearCaption = formatYearDropdown;

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getFormatters.js
function getFormatters(customFormatters) {
  if ((customFormatters == null ? void 0 : customFormatters.formatMonthCaption) && !customFormatters.formatCaption) {
    customFormatters.formatCaption = customFormatters.formatMonthCaption;
  }
  if ((customFormatters == null ? void 0 : customFormatters.formatYearCaption) && !customFormatters.formatYearDropdown) {
    customFormatters.formatYearDropdown = customFormatters.formatYearCaption;
  }
  return __spreadValues(__spreadValues({}, formatters_exports), customFormatters);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getMonthOptions.js
function getMonthOptions(displayMonth, navStart, navEnd, formatters2, dateLib) {
  const { startOfMonth: startOfMonth2, startOfYear: startOfYear2, endOfYear: endOfYear2, eachMonthOfInterval: eachMonthOfInterval2, getMonth: getMonth2 } = dateLib;
  const months = eachMonthOfInterval2({
    start: startOfYear2(displayMonth),
    end: endOfYear2(displayMonth)
  });
  const options = months.map((month) => {
    const label = formatters2.formatMonthDropdown(month, dateLib);
    const value = getMonth2(month);
    const disabled = navStart && month < startOfMonth2(navStart) || navEnd && month > startOfMonth2(navEnd) || false;
    return { value, label, disabled };
  });
  return options;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getStyleForModifiers.js
function getStyleForModifiers(dayModifiers, styles = {}, modifiersStyles = {}) {
  let style2 = __spreadValues({}, styles == null ? void 0 : styles[UI.Day]);
  Object.entries(dayModifiers).filter(([, active]) => active === true).forEach(([modifier]) => {
    style2 = __spreadValues(__spreadValues({}, style2), modifiersStyles == null ? void 0 : modifiersStyles[modifier]);
  });
  return style2;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getWeekdays.js
function getWeekdays(dateLib, ISOWeek, broadcastCalendar) {
  const today = dateLib.today();
  const start2 = broadcastCalendar ? dateLib.startOfBroadcastWeek(today, dateLib) : ISOWeek ? dateLib.startOfISOWeek(today) : dateLib.startOfWeek(today);
  const days = [];
  for (let i = 0; i < 7; i++) {
    const day = dateLib.addDays(start2, i);
    days.push(day);
  }
  return days;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getYearOptions.js
function getYearOptions(navStart, navEnd, formatters2, dateLib) {
  if (!navStart)
    return void 0;
  if (!navEnd)
    return void 0;
  const { startOfYear: startOfYear2, endOfYear: endOfYear2, addYears: addYears2, getYear: getYear2, isBefore: isBefore2, isSameYear: isSameYear2 } = dateLib;
  const firstNavYear = startOfYear2(navStart);
  const lastNavYear = endOfYear2(navEnd);
  const years = [];
  let year = firstNavYear;
  while (isBefore2(year, lastNavYear) || isSameYear2(year, lastNavYear)) {
    years.push(year);
    year = addYears2(year, 1);
  }
  return years.map((year2) => {
    const label = formatters2.formatYearDropdown(year2, dateLib);
    return {
      value: getYear2(year2),
      label,
      disabled: false
    };
  });
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/index.js
var labels_exports = {};
__export(labels_exports, {
  labelCaption: () => labelCaption,
  labelDay: () => labelDay,
  labelDayButton: () => labelDayButton,
  labelGrid: () => labelGrid,
  labelGridcell: () => labelGridcell,
  labelMonthDropdown: () => labelMonthDropdown,
  labelNav: () => labelNav,
  labelNext: () => labelNext,
  labelPrevious: () => labelPrevious,
  labelWeekNumber: () => labelWeekNumber,
  labelWeekNumberHeader: () => labelWeekNumberHeader,
  labelWeekday: () => labelWeekday,
  labelYearDropdown: () => labelYearDropdown
});

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelGrid.js
function labelGrid(date, options, dateLib) {
  return (dateLib != null ? dateLib : new DateLib(options)).format(date, "LLLL y");
}
var labelCaption = labelGrid;

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelGridcell.js
function labelGridcell(date, modifiers, options, dateLib) {
  let label = (dateLib != null ? dateLib : new DateLib(options)).format(date, "PPPP");
  if (modifiers == null ? void 0 : modifiers.today) {
    label = `Today, ${label}`;
  }
  return label;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelDayButton.js
function labelDayButton(date, modifiers, options, dateLib) {
  let label = (dateLib != null ? dateLib : new DateLib(options)).format(date, "PPPP");
  if (modifiers.today)
    label = `Today, ${label}`;
  if (modifiers.selected)
    label = `${label}, selected`;
  return label;
}
var labelDay = labelDayButton;

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelNav.js
function labelNav() {
  return "";
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelMonthDropdown.js
function labelMonthDropdown(options) {
  return "Choose the Month";
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelNext.js
function labelNext(month) {
  return "Go to the Next Month";
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelPrevious.js
function labelPrevious(month) {
  return "Go to the Previous Month";
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelWeekday.js
function labelWeekday(date, options, dateLib) {
  return (dateLib != null ? dateLib : new DateLib(options)).format(date, "cccc");
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelWeekNumber.js
function labelWeekNumber(weekNumber, options) {
  return `Week ${weekNumber}`;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelWeekNumberHeader.js
function labelWeekNumberHeader(options) {
  return "Week Number";
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/labels/labelYearDropdown.js
function labelYearDropdown(options) {
  return "Choose the Year";
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useAnimation.js
var import_react33 = require("react");
var asHtmlElement = (element) => {
  if (element instanceof HTMLElement)
    return element;
  return null;
};
var queryMonthEls = (element) => {
  var _a;
  return [
    ...(_a = element.querySelectorAll("[data-animated-month]")) != null ? _a : []
  ];
};
var queryMonthEl = (element) => asHtmlElement(element.querySelector("[data-animated-month]"));
var queryCaptionEl = (element) => asHtmlElement(element.querySelector("[data-animated-caption]"));
var queryWeeksEl = (element) => asHtmlElement(element.querySelector("[data-animated-weeks]"));
var queryNavEl = (element) => asHtmlElement(element.querySelector("[data-animated-nav]"));
var queryWeekdaysEl = (element) => asHtmlElement(element.querySelector("[data-animated-weekdays]"));
function useAnimation(rootElRef, enabled2, { classNames, months, focused, dateLib }) {
  const previousRootElSnapshotRef = (0, import_react33.useRef)(null);
  const previousMonthsRef = (0, import_react33.useRef)(months);
  const animatingRef = (0, import_react33.useRef)(false);
  (0, import_react33.useLayoutEffect)(() => {
    const previousMonths = previousMonthsRef.current;
    previousMonthsRef.current = months;
    if (!enabled2 || !rootElRef.current || // safety check because the ref can be set to anything by consumers
    !(rootElRef.current instanceof HTMLElement) || // validation required for the animation to work as expected
    months.length === 0 || previousMonths.length === 0 || months.length !== previousMonths.length) {
      return;
    }
    const isSameMonth2 = dateLib.isSameMonth(months[0].date, previousMonths[0].date);
    const isAfterPreviousMonth = dateLib.isAfter(months[0].date, previousMonths[0].date);
    const captionAnimationClass = isAfterPreviousMonth ? classNames[Animation.caption_after_enter] : classNames[Animation.caption_before_enter];
    const weeksAnimationClass = isAfterPreviousMonth ? classNames[Animation.weeks_after_enter] : classNames[Animation.weeks_before_enter];
    const previousRootElSnapshot = previousRootElSnapshotRef.current;
    const rootElSnapshot = rootElRef.current.cloneNode(true);
    if (rootElSnapshot instanceof HTMLElement) {
      const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);
      currentMonthElsSnapshot.forEach((currentMonthElSnapshot) => {
        if (!(currentMonthElSnapshot instanceof HTMLElement))
          return;
        const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);
        if (previousMonthElSnapshot && currentMonthElSnapshot.contains(previousMonthElSnapshot)) {
          currentMonthElSnapshot.removeChild(previousMonthElSnapshot);
        }
        const captionEl = queryCaptionEl(currentMonthElSnapshot);
        if (captionEl) {
          captionEl.classList.remove(captionAnimationClass);
        }
        const weeksEl = queryWeeksEl(currentMonthElSnapshot);
        if (weeksEl) {
          weeksEl.classList.remove(weeksAnimationClass);
        }
      });
      previousRootElSnapshotRef.current = rootElSnapshot;
    } else {
      previousRootElSnapshotRef.current = null;
    }
    if (animatingRef.current || isSameMonth2 || // skip animation if a day is focused because it can cause issues to the animation and is better for a11y
    focused) {
      return;
    }
    const previousMonthEls = previousRootElSnapshot instanceof HTMLElement ? queryMonthEls(previousRootElSnapshot) : [];
    const currentMonthEls = queryMonthEls(rootElRef.current);
    if (currentMonthEls && currentMonthEls.every((el) => el instanceof HTMLElement) && previousMonthEls && previousMonthEls.every((el) => el instanceof HTMLElement)) {
      animatingRef.current = true;
      const cleanUpFunctions = [];
      rootElRef.current.style.isolation = "isolate";
      const navEl = queryNavEl(rootElRef.current);
      if (navEl) {
        navEl.style.zIndex = "1";
      }
      currentMonthEls.forEach((currentMonthEl, index2) => {
        const previousMonthEl = previousMonthEls[index2];
        if (!previousMonthEl) {
          return;
        }
        currentMonthEl.style.position = "relative";
        currentMonthEl.style.overflow = "hidden";
        const captionEl = queryCaptionEl(currentMonthEl);
        if (captionEl) {
          captionEl.classList.add(captionAnimationClass);
        }
        const weeksEl = queryWeeksEl(currentMonthEl);
        if (weeksEl) {
          weeksEl.classList.add(weeksAnimationClass);
        }
        const cleanUp = () => {
          animatingRef.current = false;
          if (rootElRef.current) {
            rootElRef.current.style.isolation = "";
          }
          if (navEl) {
            navEl.style.zIndex = "";
          }
          if (captionEl) {
            captionEl.classList.remove(captionAnimationClass);
          }
          if (weeksEl) {
            weeksEl.classList.remove(weeksAnimationClass);
          }
          currentMonthEl.style.position = "";
          currentMonthEl.style.overflow = "";
          if (currentMonthEl.contains(previousMonthEl)) {
            currentMonthEl.removeChild(previousMonthEl);
          }
        };
        cleanUpFunctions.push(cleanUp);
        previousMonthEl.style.pointerEvents = "none";
        previousMonthEl.style.position = "absolute";
        previousMonthEl.style.overflow = "hidden";
        previousMonthEl.setAttribute("aria-hidden", "true");
        const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);
        if (previousWeekdaysEl) {
          previousWeekdaysEl.style.opacity = "0";
        }
        const previousCaptionEl = queryCaptionEl(previousMonthEl);
        if (previousCaptionEl) {
          previousCaptionEl.classList.add(isAfterPreviousMonth ? classNames[Animation.caption_before_exit] : classNames[Animation.caption_after_exit]);
          previousCaptionEl.addEventListener("animationend", cleanUp);
        }
        const previousWeeksEl = queryWeeksEl(previousMonthEl);
        if (previousWeeksEl) {
          previousWeeksEl.classList.add(isAfterPreviousMonth ? classNames[Animation.weeks_before_exit] : classNames[Animation.weeks_after_exit]);
        }
        currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);
      });
    }
  });
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useCalendar.js
var import_react35 = require("react");

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getDates.js
function getDates(displayMonths, maxDate, props2, dateLib) {
  const firstMonth = displayMonths[0];
  const lastMonth = displayMonths[displayMonths.length - 1];
  const { ISOWeek, fixedWeeks, broadcastCalendar } = props2 != null ? props2 : {};
  const { addDays: addDays2, differenceInCalendarDays: differenceInCalendarDays2, differenceInCalendarMonths: differenceInCalendarMonths2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfMonth: endOfMonth2, endOfWeek: endOfWeek2, isAfter: isAfter2, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
  const startWeekFirstDate = broadcastCalendar ? startOfBroadcastWeek2(firstMonth, dateLib) : ISOWeek ? startOfISOWeek2(firstMonth) : startOfWeek2(firstMonth);
  const endWeekLastDate = broadcastCalendar ? endOfBroadcastWeek2(lastMonth, dateLib) : ISOWeek ? endOfISOWeek2(endOfMonth2(lastMonth)) : endOfWeek2(endOfMonth2(lastMonth));
  const nOfDays = differenceInCalendarDays2(endWeekLastDate, startWeekFirstDate);
  const nOfMonths = differenceInCalendarMonths2(lastMonth, firstMonth) + 1;
  const dates = [];
  for (let i = 0; i <= nOfDays; i++) {
    const date = addDays2(startWeekFirstDate, i);
    if (maxDate && isAfter2(date, maxDate)) {
      break;
    }
    dates.push(date);
  }
  const nrOfDaysWithFixedWeeks = broadcastCalendar ? 35 : 42;
  const extraDates = nrOfDaysWithFixedWeeks * nOfMonths;
  if (fixedWeeks && dates.length < extraDates) {
    const daysToAdd = extraDates - dates.length;
    for (let i = 0; i < daysToAdd; i++) {
      const date = addDays2(dates[dates.length - 1], 1);
      dates.push(date);
    }
  }
  return dates;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getDays.js
function getDays(calendarMonths) {
  const initialDays = [];
  return calendarMonths.reduce((days, month) => {
    const initialDays2 = [];
    const weekDays = month.weeks.reduce((weekDays2, week) => {
      return [...weekDays2, ...week.days];
    }, initialDays2);
    return [...days, ...weekDays];
  }, initialDays);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getDisplayMonths.js
function getDisplayMonths(firstDisplayedMonth, calendarEndMonth, props2, dateLib) {
  const { numberOfMonths = 1 } = props2;
  const months = [];
  for (let i = 0; i < numberOfMonths; i++) {
    const month = dateLib.addMonths(firstDisplayedMonth, i);
    if (calendarEndMonth && month > calendarEndMonth) {
      break;
    }
    months.push(month);
  }
  return months;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getInitialMonth.js
function getInitialMonth(props2, dateLib) {
  const { month, defaultMonth, today = dateLib.today(), numberOfMonths = 1, endMonth, startMonth, timeZone } = props2;
  let initialMonth = month || defaultMonth || today;
  const { differenceInCalendarMonths: differenceInCalendarMonths2, addMonths: addMonths2, startOfMonth: startOfMonth2 } = dateLib;
  if (endMonth && differenceInCalendarMonths2(endMonth, initialMonth) < 0) {
    const offset6 = -1 * (numberOfMonths - 1);
    initialMonth = addMonths2(endMonth, offset6);
  }
  if (startMonth && differenceInCalendarMonths2(initialMonth, startMonth) < 0) {
    initialMonth = startMonth;
  }
  initialMonth = timeZone ? new TZDate(initialMonth, timeZone) : initialMonth;
  return startOfMonth2(initialMonth);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/classes/CalendarDay.js
var CalendarDay = class {
  constructor(date, displayMonth, dateLib = defaultDateLib) {
    this.date = date;
    this.displayMonth = displayMonth;
    this.outside = Boolean(displayMonth && !dateLib.isSameMonth(date, displayMonth));
    this.dateLib = dateLib;
  }
  /**
   * Check if the day is the same as the given day: considering if it is in the
   * same display month.
   */
  isEqualTo(day) {
    return this.dateLib.isSameDay(day.date, this.date) && this.dateLib.isSameMonth(day.displayMonth, this.displayMonth);
  }
};

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/classes/CalendarMonth.js
var CalendarMonth = class {
  constructor(month, weeks) {
    this.date = month;
    this.weeks = weeks;
  }
};

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/classes/CalendarWeek.js
var CalendarWeek = class {
  constructor(weekNumber, days) {
    this.days = days;
    this.weekNumber = weekNumber;
  }
};

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getMonths.js
function getMonths(displayMonths, dates, props2, dateLib) {
  const { addDays: addDays2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfMonth: endOfMonth2, endOfWeek: endOfWeek2, getISOWeek: getISOWeek2, getWeek: getWeek2, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
  const dayPickerMonths = displayMonths.reduce((months, month) => {
    const firstDateOfFirstWeek = props2.broadcastCalendar ? startOfBroadcastWeek2(month, dateLib) : props2.ISOWeek ? startOfISOWeek2(month) : startOfWeek2(month);
    const lastDateOfLastWeek = props2.broadcastCalendar ? endOfBroadcastWeek2(month, dateLib) : props2.ISOWeek ? endOfISOWeek2(endOfMonth2(month)) : endOfWeek2(endOfMonth2(month));
    const monthDates = dates.filter((date) => {
      return date >= firstDateOfFirstWeek && date <= lastDateOfLastWeek;
    });
    const nrOfDaysWithFixedWeeks = props2.broadcastCalendar ? 35 : 42;
    if (props2.fixedWeeks && monthDates.length < nrOfDaysWithFixedWeeks) {
      const extraDates = dates.filter((date) => {
        const daysToAdd = nrOfDaysWithFixedWeeks - monthDates.length;
        return date > lastDateOfLastWeek && date <= addDays2(lastDateOfLastWeek, daysToAdd);
      });
      monthDates.push(...extraDates);
    }
    const weeks = monthDates.reduce((weeks2, date) => {
      const weekNumber = props2.ISOWeek ? getISOWeek2(date) : getWeek2(date);
      const week = weeks2.find((week2) => week2.weekNumber === weekNumber);
      const day = new CalendarDay(date, month, dateLib);
      if (!week) {
        weeks2.push(new CalendarWeek(weekNumber, [day]));
      } else {
        week.days.push(day);
      }
      return weeks2;
    }, []);
    const dayPickerMonth = new CalendarMonth(month, weeks);
    months.push(dayPickerMonth);
    return months;
  }, []);
  if (!props2.reverseMonths) {
    return dayPickerMonths;
  } else {
    return dayPickerMonths.reverse();
  }
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getNavMonth.js
function getNavMonths(props2, dateLib) {
  var _a, _b;
  let { startMonth, endMonth } = props2;
  const { startOfYear: startOfYear2, startOfDay: startOfDay2, startOfMonth: startOfMonth2, endOfMonth: endOfMonth2, addYears: addYears2, endOfYear: endOfYear2, newDate, today } = dateLib;
  const { fromYear, toYear, fromMonth, toMonth } = props2;
  if (!startMonth && fromMonth) {
    startMonth = fromMonth;
  }
  if (!startMonth && fromYear) {
    startMonth = dateLib.newDate(fromYear, 0, 1);
  }
  if (!endMonth && toMonth) {
    endMonth = toMonth;
  }
  if (!endMonth && toYear) {
    endMonth = newDate(toYear, 11, 31);
  }
  const hasYearDropdown = props2.captionLayout === "dropdown" || props2.captionLayout === "dropdown-years";
  if (startMonth) {
    startMonth = startOfMonth2(startMonth);
  } else if (fromYear) {
    startMonth = newDate(fromYear, 0, 1);
  } else if (!startMonth && hasYearDropdown) {
    startMonth = startOfYear2(addYears2((_a = props2.today) != null ? _a : today(), -100));
  }
  if (endMonth) {
    endMonth = endOfMonth2(endMonth);
  } else if (toYear) {
    endMonth = newDate(toYear, 11, 31);
  } else if (!endMonth && hasYearDropdown) {
    endMonth = endOfYear2((_b = props2.today) != null ? _b : today());
  }
  return [
    startMonth ? startOfDay2(startMonth) : startMonth,
    endMonth ? startOfDay2(endMonth) : endMonth
  ];
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getNextMonth.js
function getNextMonth(firstDisplayedMonth, calendarEndMonth, options, dateLib) {
  if (options.disableNavigation) {
    return void 0;
  }
  const { pagedNavigation, numberOfMonths = 1 } = options;
  const { startOfMonth: startOfMonth2, addMonths: addMonths2, differenceInCalendarMonths: differenceInCalendarMonths2 } = dateLib;
  const offset6 = pagedNavigation ? numberOfMonths : 1;
  const month = startOfMonth2(firstDisplayedMonth);
  if (!calendarEndMonth) {
    return addMonths2(month, offset6);
  }
  const monthsDiff = differenceInCalendarMonths2(calendarEndMonth, firstDisplayedMonth);
  if (monthsDiff < numberOfMonths) {
    return void 0;
  }
  return addMonths2(month, offset6);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getPreviousMonth.js
function getPreviousMonth(firstDisplayedMonth, calendarStartMonth, options, dateLib) {
  if (options.disableNavigation) {
    return void 0;
  }
  const { pagedNavigation, numberOfMonths } = options;
  const { startOfMonth: startOfMonth2, addMonths: addMonths2, differenceInCalendarMonths: differenceInCalendarMonths2 } = dateLib;
  const offset6 = pagedNavigation ? numberOfMonths != null ? numberOfMonths : 1 : 1;
  const month = startOfMonth2(firstDisplayedMonth);
  if (!calendarStartMonth) {
    return addMonths2(month, -offset6);
  }
  const monthsDiff = differenceInCalendarMonths2(month, calendarStartMonth);
  if (monthsDiff <= 0) {
    return void 0;
  }
  return addMonths2(month, -offset6);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getWeeks.js
function getWeeks(months) {
  const initialWeeks = [];
  return months.reduce((weeks, month) => {
    return [...weeks, ...month.weeks];
  }, initialWeeks);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/useControlledValue.js
var import_react34 = require("react");
function useControlledValue(defaultValue, controlledValue) {
  const [uncontrolledValue, setValue] = (0, import_react34.useState)(defaultValue);
  const value = controlledValue === void 0 ? uncontrolledValue : controlledValue;
  return [value, setValue];
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useCalendar.js
function useCalendar(props2, dateLib) {
  const [navStart, navEnd] = getNavMonths(props2, dateLib);
  const { startOfMonth: startOfMonth2, endOfMonth: endOfMonth2 } = dateLib;
  const initialMonth = getInitialMonth(props2, dateLib);
  const [firstMonth, setFirstMonth] = useControlledValue(
    initialMonth,
    // initialMonth is always computed from props.month if provided
    props2.month ? initialMonth : void 0
  );
  (0, import_react35.useEffect)(() => {
    const newInitialMonth = getInitialMonth(props2, dateLib);
    setFirstMonth(newInitialMonth);
  }, [props2.timeZone]);
  const displayMonths = getDisplayMonths(firstMonth, navEnd, props2, dateLib);
  const dates = getDates(displayMonths, props2.endMonth ? endOfMonth2(props2.endMonth) : void 0, props2, dateLib);
  const months = getMonths(displayMonths, dates, props2, dateLib);
  const weeks = getWeeks(months);
  const days = getDays(months);
  const previousMonth = getPreviousMonth(firstMonth, navStart, props2, dateLib);
  const nextMonth = getNextMonth(firstMonth, navEnd, props2, dateLib);
  const { disableNavigation, onMonthChange } = props2;
  const isDayInCalendar = (day) => weeks.some((week) => week.days.some((d) => d.isEqualTo(day)));
  const goToMonth = (date) => {
    if (disableNavigation) {
      return;
    }
    let newMonth = startOfMonth2(date);
    if (navStart && newMonth < startOfMonth2(navStart)) {
      newMonth = startOfMonth2(navStart);
    }
    if (navEnd && newMonth > startOfMonth2(navEnd)) {
      newMonth = startOfMonth2(navEnd);
    }
    setFirstMonth(newMonth);
    onMonthChange == null ? void 0 : onMonthChange(newMonth);
  };
  const goToDay = (day) => {
    if (isDayInCalendar(day)) {
      return;
    }
    goToMonth(day.date);
  };
  const calendar = {
    months,
    weeks,
    days,
    navStart,
    navEnd,
    previousMonth,
    nextMonth,
    goToMonth,
    goToDay
  };
  return calendar;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useFocus.js
var import_react36 = require("react");

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/calculateFocusTarget.js
var FocusTargetPriority;
(function(FocusTargetPriority2) {
  FocusTargetPriority2[FocusTargetPriority2["Today"] = 0] = "Today";
  FocusTargetPriority2[FocusTargetPriority2["Selected"] = 1] = "Selected";
  FocusTargetPriority2[FocusTargetPriority2["LastFocused"] = 2] = "LastFocused";
  FocusTargetPriority2[FocusTargetPriority2["FocusedModifier"] = 3] = "FocusedModifier";
})(FocusTargetPriority || (FocusTargetPriority = {}));
function isFocusableDay(modifiers) {
  return !modifiers[DayFlag.disabled] && !modifiers[DayFlag.hidden] && !modifiers[DayFlag.outside];
}
function calculateFocusTarget(days, getModifiers, isSelected, lastFocused) {
  let focusTarget;
  let foundFocusTargetPriority = -1;
  for (const day of days) {
    const modifiers = getModifiers(day);
    if (isFocusableDay(modifiers)) {
      if (modifiers[DayFlag.focused] && foundFocusTargetPriority < FocusTargetPriority.FocusedModifier) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.FocusedModifier;
      } else if ((lastFocused == null ? void 0 : lastFocused.isEqualTo(day)) && foundFocusTargetPriority < FocusTargetPriority.LastFocused) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.LastFocused;
      } else if (isSelected(day.date) && foundFocusTargetPriority < FocusTargetPriority.Selected) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.Selected;
      } else if (modifiers[DayFlag.today] && foundFocusTargetPriority < FocusTargetPriority.Today) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.Today;
      }
    }
  }
  if (!focusTarget) {
    focusTarget = days.find((day) => isFocusableDay(getModifiers(day)));
  }
  return focusTarget;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/utils/rangeIncludesDate.js
function rangeIncludesDate(range, date, excludeEnds = false, dateLib = defaultDateLib) {
  let { from, to } = range;
  const { differenceInCalendarDays: differenceInCalendarDays2, isSameDay: isSameDay2 } = dateLib;
  if (from && to) {
    const isRangeInverted = differenceInCalendarDays2(to, from) < 0;
    if (isRangeInverted) {
      [from, to] = [to, from];
    }
    const isInRange = differenceInCalendarDays2(date, from) >= (excludeEnds ? 1 : 0) && differenceInCalendarDays2(to, date) >= (excludeEnds ? 1 : 0);
    return isInRange;
  }
  if (!excludeEnds && to) {
    return isSameDay2(to, date);
  }
  if (!excludeEnds && from) {
    return isSameDay2(from, date);
  }
  return false;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/utils/typeguards.js
function isDateInterval(matcher) {
  return Boolean(matcher && typeof matcher === "object" && "before" in matcher && "after" in matcher);
}
function isDateRange(value) {
  return Boolean(value && typeof value === "object" && "from" in value);
}
function isDateAfterType(value) {
  return Boolean(value && typeof value === "object" && "after" in value);
}
function isDateBeforeType(value) {
  return Boolean(value && typeof value === "object" && "before" in value);
}
function isDayOfWeekType(value) {
  return Boolean(value && typeof value === "object" && "dayOfWeek" in value);
}
function isDatesArray(value, dateLib) {
  return Array.isArray(value) && value.every(dateLib.isDate);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/utils/dateMatchModifiers.js
function dateMatchModifiers(date, matchers, dateLib = defaultDateLib) {
  const matchersArr = !Array.isArray(matchers) ? [matchers] : matchers;
  const { isSameDay: isSameDay2, differenceInCalendarDays: differenceInCalendarDays2, isAfter: isAfter2 } = dateLib;
  return matchersArr.some((matcher) => {
    if (typeof matcher === "boolean") {
      return matcher;
    }
    if (dateLib.isDate(matcher)) {
      return isSameDay2(date, matcher);
    }
    if (isDatesArray(matcher, dateLib)) {
      return matcher.includes(date);
    }
    if (isDateRange(matcher)) {
      return rangeIncludesDate(matcher, date, false, dateLib);
    }
    if (isDayOfWeekType(matcher)) {
      if (!Array.isArray(matcher.dayOfWeek)) {
        return matcher.dayOfWeek === date.getDay();
      }
      return matcher.dayOfWeek.includes(date.getDay());
    }
    if (isDateInterval(matcher)) {
      const diffBefore = differenceInCalendarDays2(matcher.before, date);
      const diffAfter = differenceInCalendarDays2(matcher.after, date);
      const isDayBefore = diffBefore > 0;
      const isDayAfter = diffAfter < 0;
      const isClosedInterval = isAfter2(matcher.before, matcher.after);
      if (isClosedInterval) {
        return isDayAfter && isDayBefore;
      } else {
        return isDayBefore || isDayAfter;
      }
    }
    if (isDateAfterType(matcher)) {
      return differenceInCalendarDays2(date, matcher.after) > 0;
    }
    if (isDateBeforeType(matcher)) {
      return differenceInCalendarDays2(matcher.before, date) > 0;
    }
    if (typeof matcher === "function") {
      return matcher(date);
    }
    return false;
  });
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getFocusableDate.js
function getFocusableDate(moveBy, moveDir, refDate, navStart, navEnd, props2, dateLib) {
  const { ISOWeek, broadcastCalendar } = props2;
  const { addDays: addDays2, addMonths: addMonths2, addWeeks: addWeeks2, addYears: addYears2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfWeek: endOfWeek2, max: max3, min: min3, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
  const moveFns = {
    day: addDays2,
    week: addWeeks2,
    month: addMonths2,
    year: addYears2,
    startOfWeek: (date) => broadcastCalendar ? startOfBroadcastWeek2(date, dateLib) : ISOWeek ? startOfISOWeek2(date) : startOfWeek2(date),
    endOfWeek: (date) => broadcastCalendar ? endOfBroadcastWeek2(date, dateLib) : ISOWeek ? endOfISOWeek2(date) : endOfWeek2(date)
  };
  let focusableDate = moveFns[moveBy](refDate, moveDir === "after" ? 1 : -1);
  if (moveDir === "before" && navStart) {
    focusableDate = max3([navStart, focusableDate]);
  } else if (moveDir === "after" && navEnd) {
    focusableDate = min3([navEnd, focusableDate]);
  }
  return focusableDate;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/helpers/getNextFocus.js
function getNextFocus(moveBy, moveDir, refDay, calendarStartMonth, calendarEndMonth, props2, dateLib, attempt = 0) {
  if (attempt > 365) {
    return void 0;
  }
  const focusableDate = getFocusableDate(
    moveBy,
    moveDir,
    refDay.date,
    // should be refDay? or refDay.date?
    calendarStartMonth,
    calendarEndMonth,
    props2,
    dateLib
  );
  const isDisabled = Boolean(props2.disabled && dateMatchModifiers(focusableDate, props2.disabled, dateLib));
  const isHidden3 = Boolean(props2.hidden && dateMatchModifiers(focusableDate, props2.hidden, dateLib));
  const targetMonth = focusableDate;
  const focusDay = new CalendarDay(focusableDate, targetMonth, dateLib);
  if (!isDisabled && !isHidden3) {
    return focusDay;
  }
  return getNextFocus(moveBy, moveDir, focusDay, calendarStartMonth, calendarEndMonth, props2, dateLib, attempt + 1);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useFocus.js
function useFocus(props2, calendar, getModifiers, isSelected, dateLib) {
  const { autoFocus } = props2;
  const [lastFocused, setLastFocused] = (0, import_react36.useState)();
  const focusTarget = calculateFocusTarget(calendar.days, getModifiers, isSelected || (() => false), lastFocused);
  const [focusedDay, setFocused] = (0, import_react36.useState)(autoFocus ? focusTarget : void 0);
  const blur = () => {
    setLastFocused(focusedDay);
    setFocused(void 0);
  };
  const moveFocus = (moveBy, moveDir) => {
    if (!focusedDay)
      return;
    const nextFocus = getNextFocus(moveBy, moveDir, focusedDay, calendar.navStart, calendar.navEnd, props2, dateLib);
    if (!nextFocus)
      return;
    calendar.goToDay(nextFocus);
    setFocused(nextFocus);
  };
  const isFocusTarget = (day) => {
    return Boolean(focusTarget == null ? void 0 : focusTarget.isEqualTo(day));
  };
  const useFocus2 = {
    isFocusTarget,
    setFocused,
    focused: focusedDay,
    blur,
    moveFocus
  };
  return useFocus2;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useGetModifiers.js
function useGetModifiers(days, props2, dateLib) {
  const { disabled, hidden, modifiers, showOutsideDays, broadcastCalendar, today } = props2;
  const { isSameDay: isSameDay2, isSameMonth: isSameMonth2, startOfMonth: startOfMonth2, isBefore: isBefore2, endOfMonth: endOfMonth2, isAfter: isAfter2 } = dateLib;
  const startMonth = props2.startMonth && startOfMonth2(props2.startMonth);
  const endMonth = props2.endMonth && endOfMonth2(props2.endMonth);
  const internalModifiersMap = {
    [DayFlag.focused]: [],
    [DayFlag.outside]: [],
    [DayFlag.disabled]: [],
    [DayFlag.hidden]: [],
    [DayFlag.today]: []
  };
  const customModifiersMap = {};
  for (const day of days) {
    const { date, displayMonth } = day;
    const isOutside = Boolean(displayMonth && !isSameMonth2(date, displayMonth));
    const isBeforeStartMonth = Boolean(startMonth && isBefore2(date, startMonth));
    const isAfterEndMonth = Boolean(endMonth && isAfter2(date, endMonth));
    const isDisabled = Boolean(disabled && dateMatchModifiers(date, disabled, dateLib));
    const isHidden3 = Boolean(hidden && dateMatchModifiers(date, hidden, dateLib)) || isBeforeStartMonth || isAfterEndMonth || // Broadcast calendar will show outside days as default
    !broadcastCalendar && !showOutsideDays && isOutside || broadcastCalendar && showOutsideDays === false && isOutside;
    const isToday = isSameDay2(date, today != null ? today : dateLib.today());
    if (isOutside)
      internalModifiersMap.outside.push(day);
    if (isDisabled)
      internalModifiersMap.disabled.push(day);
    if (isHidden3)
      internalModifiersMap.hidden.push(day);
    if (isToday)
      internalModifiersMap.today.push(day);
    if (modifiers) {
      Object.keys(modifiers).forEach((name) => {
        const modifierValue = modifiers == null ? void 0 : modifiers[name];
        const isMatch = modifierValue ? dateMatchModifiers(date, modifierValue, dateLib) : false;
        if (!isMatch)
          return;
        if (customModifiersMap[name]) {
          customModifiersMap[name].push(day);
        } else {
          customModifiersMap[name] = [day];
        }
      });
    }
  }
  return (day) => {
    const dayFlags = {
      [DayFlag.focused]: false,
      [DayFlag.disabled]: false,
      [DayFlag.hidden]: false,
      [DayFlag.outside]: false,
      [DayFlag.today]: false
    };
    const customModifiers = {};
    for (const name in internalModifiersMap) {
      const days2 = internalModifiersMap[name];
      dayFlags[name] = days2.some((d) => d === day);
    }
    for (const name in customModifiersMap) {
      customModifiers[name] = customModifiersMap[name].some((d) => d === day);
    }
    return __spreadValues(__spreadValues({}, dayFlags), customModifiers);
  };
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/selection/useMulti.js
function useMulti(props2, dateLib) {
  const { selected: initiallySelected, required: required2, onSelect } = props2;
  const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
  const selected = !onSelect ? internallySelected : initiallySelected;
  const { isSameDay: isSameDay2 } = dateLib;
  const isSelected = (date) => {
    var _a;
    return (_a = selected == null ? void 0 : selected.some((d) => isSameDay2(d, date))) != null ? _a : false;
  };
  const { min: min3, max: max3 } = props2;
  const select = (triggerDate, modifiers, e) => {
    let newDates = [...selected != null ? selected : []];
    if (isSelected(triggerDate)) {
      if ((selected == null ? void 0 : selected.length) === min3) {
        return;
      }
      if (required2 && (selected == null ? void 0 : selected.length) === 1) {
        return;
      }
      newDates = selected == null ? void 0 : selected.filter((d) => !isSameDay2(d, triggerDate));
    } else {
      if ((selected == null ? void 0 : selected.length) === max3) {
        newDates = [triggerDate];
      } else {
        newDates = [...newDates, triggerDate];
      }
    }
    if (!onSelect) {
      setSelected(newDates);
    }
    onSelect == null ? void 0 : onSelect(newDates, triggerDate, modifiers, e);
    return newDates;
  };
  return {
    selected,
    select,
    isSelected
  };
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/utils/addToRange.js
function addToRange(date, initialRange, min3 = 0, max3 = 0, required2 = false, dateLib = defaultDateLib) {
  const { from, to } = initialRange || {};
  const { isSameDay: isSameDay2, isAfter: isAfter2, isBefore: isBefore2 } = dateLib;
  let range;
  if (!from && !to) {
    range = { from: date, to: min3 > 0 ? void 0 : date };
  } else if (from && !to) {
    if (isSameDay2(from, date)) {
      if (required2) {
        range = { from, to: void 0 };
      } else {
        range = void 0;
      }
    } else if (isBefore2(date, from)) {
      range = { from: date, to: from };
    } else {
      range = { from, to: date };
    }
  } else if (from && to) {
    if (isSameDay2(from, date) && isSameDay2(to, date)) {
      if (required2) {
        range = { from, to };
      } else {
        range = void 0;
      }
    } else if (isSameDay2(from, date)) {
      range = { from, to: min3 > 0 ? void 0 : date };
    } else if (isSameDay2(to, date)) {
      range = { from: date, to: min3 > 0 ? void 0 : date };
    } else if (isBefore2(date, from)) {
      range = { from: date, to };
    } else if (isAfter2(date, from)) {
      range = { from, to: date };
    } else if (isAfter2(date, to)) {
      range = { from, to: date };
    } else {
      throw new Error("Invalid range");
    }
  }
  if ((range == null ? void 0 : range.from) && (range == null ? void 0 : range.to)) {
    const diff = dateLib.differenceInCalendarDays(range.to, range.from);
    if (max3 > 0 && diff > max3) {
      range = { from: date, to: void 0 };
    } else if (min3 > 1 && diff < min3) {
      range = { from: date, to: void 0 };
    }
  }
  return range;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/utils/rangeContainsDayOfWeek.js
function rangeContainsDayOfWeek(range, dayOfWeek, dateLib = defaultDateLib) {
  const dayOfWeekArr = !Array.isArray(dayOfWeek) ? [dayOfWeek] : dayOfWeek;
  let date = range.from;
  const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
  const totalDaysLimit = Math.min(totalDays, 6);
  for (let i = 0; i <= totalDaysLimit; i++) {
    if (dayOfWeekArr.includes(date.getDay())) {
      return true;
    }
    date = dateLib.addDays(date, 1);
  }
  return false;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/utils/rangeOverlaps.js
function rangeOverlaps(rangeLeft, rangeRight, dateLib = defaultDateLib) {
  return rangeIncludesDate(rangeLeft, rangeRight.from, false, dateLib) || rangeIncludesDate(rangeLeft, rangeRight.to, false, dateLib) || rangeIncludesDate(rangeRight, rangeLeft.from, false, dateLib) || rangeIncludesDate(rangeRight, rangeLeft.to, false, dateLib);
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/utils/rangeContainsModifiers.js
function rangeContainsModifiers(range, modifiers, dateLib = defaultDateLib) {
  const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];
  const nonFunctionMatchers = matchers.filter((matcher) => typeof matcher !== "function");
  const nonFunctionMatchersResult = nonFunctionMatchers.some((matcher) => {
    if (typeof matcher === "boolean")
      return matcher;
    if (dateLib.isDate(matcher)) {
      return rangeIncludesDate(range, matcher, false, dateLib);
    }
    if (isDatesArray(matcher, dateLib)) {
      return matcher.some((date) => rangeIncludesDate(range, date, false, dateLib));
    }
    if (isDateRange(matcher)) {
      if (matcher.from && matcher.to) {
        return rangeOverlaps(range, { from: matcher.from, to: matcher.to }, dateLib);
      }
      return false;
    }
    if (isDayOfWeekType(matcher)) {
      return rangeContainsDayOfWeek(range, matcher.dayOfWeek, dateLib);
    }
    if (isDateInterval(matcher)) {
      const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);
      if (isClosedInterval) {
        return rangeOverlaps(range, {
          from: dateLib.addDays(matcher.after, 1),
          to: dateLib.addDays(matcher.before, -1)
        }, dateLib);
      }
      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);
    }
    if (isDateAfterType(matcher) || isDateBeforeType(matcher)) {
      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);
    }
    return false;
  });
  if (nonFunctionMatchersResult) {
    return true;
  }
  const functionMatchers = matchers.filter((matcher) => typeof matcher === "function");
  if (functionMatchers.length) {
    let date = range.from;
    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
    for (let i = 0; i <= totalDays; i++) {
      if (functionMatchers.some((matcher) => matcher(date))) {
        return true;
      }
      date = dateLib.addDays(date, 1);
    }
  }
  return false;
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/selection/useRange.js
function useRange(props2, dateLib) {
  const { disabled, excludeDisabled, selected: initiallySelected, required: required2, onSelect } = props2;
  const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
  const selected = !onSelect ? internallySelected : initiallySelected;
  const isSelected = (date) => selected && rangeIncludesDate(selected, date, false, dateLib);
  const select = (triggerDate, modifiers, e) => {
    const { min: min3, max: max3 } = props2;
    const newRange = triggerDate ? addToRange(triggerDate, selected, min3, max3, required2, dateLib) : void 0;
    if (excludeDisabled && disabled && (newRange == null ? void 0 : newRange.from) && newRange.to) {
      if (rangeContainsModifiers({ from: newRange.from, to: newRange.to }, disabled, dateLib)) {
        newRange.from = triggerDate;
        newRange.to = void 0;
      }
    }
    if (!onSelect) {
      setSelected(newRange);
    }
    onSelect == null ? void 0 : onSelect(newRange, triggerDate, modifiers, e);
    return newRange;
  };
  return {
    selected,
    select,
    isSelected
  };
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/selection/useSingle.js
function useSingle(props2, dateLib) {
  const { selected: initiallySelected, required: required2, onSelect } = props2;
  const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
  const selected = !onSelect ? internallySelected : initiallySelected;
  const { isSameDay: isSameDay2 } = dateLib;
  const isSelected = (compareDate) => {
    return selected ? isSameDay2(selected, compareDate) : false;
  };
  const select = (triggerDate, modifiers, e) => {
    let newDate = triggerDate;
    if (!required2 && selected && selected && isSameDay2(triggerDate, selected)) {
      newDate = void 0;
    }
    if (!onSelect) {
      setSelected(newDate);
    }
    if (required2) {
      onSelect == null ? void 0 : onSelect(newDate, triggerDate, modifiers, e);
    } else {
      onSelect == null ? void 0 : onSelect(newDate, triggerDate, modifiers, e);
    }
    return newDate;
  };
  return {
    selected,
    select,
    isSelected
  };
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/useSelection.js
function useSelection(props2, dateLib) {
  const single = useSingle(props2, dateLib);
  const multi = useMulti(props2, dateLib);
  const range = useRange(props2, dateLib);
  switch (props2.mode) {
    case "single":
      return single;
    case "multiple":
      return multi;
    case "range":
      return range;
    default:
      return void 0;
  }
}

// ../../node_modules/.pnpm/react-day-picker@9.6.7_react@19.1.0/node_modules/react-day-picker/dist/esm/DayPicker.js
function DayPicker(props2) {
  var _a;
  const { components, formatters: formatters2, labels, dateLib, locale, classNames } = (0, import_react37.useMemo)(() => {
    const locale2 = __spreadValues(__spreadValues({}, enUS), props2.locale);
    const dateLib2 = new DateLib({
      locale: locale2,
      weekStartsOn: props2.broadcastCalendar ? 1 : props2.weekStartsOn,
      firstWeekContainsDate: props2.firstWeekContainsDate,
      useAdditionalWeekYearTokens: props2.useAdditionalWeekYearTokens,
      useAdditionalDayOfYearTokens: props2.useAdditionalDayOfYearTokens,
      timeZone: props2.timeZone,
      numerals: props2.numerals
    }, props2.dateLib);
    return {
      dateLib: dateLib2,
      components: getComponents(props2.components),
      formatters: getFormatters(props2.formatters),
      labels: __spreadValues(__spreadValues({}, labels_exports), props2.labels),
      locale: locale2,
      classNames: __spreadValues(__spreadValues({}, getDefaultClassNames()), props2.classNames)
    };
  }, [
    props2.locale,
    props2.broadcastCalendar,
    props2.weekStartsOn,
    props2.firstWeekContainsDate,
    props2.useAdditionalWeekYearTokens,
    props2.useAdditionalDayOfYearTokens,
    props2.timeZone,
    props2.numerals,
    props2.dateLib,
    props2.components,
    props2.formatters,
    props2.labels,
    props2.classNames
  ]);
  const { captionLayout, mode, onDayBlur, onDayClick, onDayFocus, onDayKeyDown, onDayMouseEnter, onDayMouseLeave, onNextClick, onPrevClick, showWeekNumber, styles } = props2;
  const { formatCaption: formatCaption2, formatDay: formatDay2, formatMonthDropdown: formatMonthDropdown2, formatWeekNumber: formatWeekNumber2, formatWeekNumberHeader: formatWeekNumberHeader2, formatWeekdayName: formatWeekdayName2, formatYearDropdown: formatYearDropdown2 } = formatters2;
  const calendar = useCalendar(props2, dateLib);
  const { days, months, navStart, navEnd, previousMonth, nextMonth, goToMonth } = calendar;
  const getModifiers = useGetModifiers(days, props2, dateLib);
  const { isSelected, select, selected: selectedValue } = (_a = useSelection(props2, dateLib)) != null ? _a : {};
  const { blur, focused, isFocusTarget, moveFocus, setFocused } = useFocus(props2, calendar, getModifiers, isSelected != null ? isSelected : () => false, dateLib);
  const { labelDayButton: labelDayButton2, labelGridcell: labelGridcell2, labelGrid: labelGrid2, labelMonthDropdown: labelMonthDropdown2, labelNav: labelNav2, labelWeekday: labelWeekday2, labelWeekNumber: labelWeekNumber2, labelWeekNumberHeader: labelWeekNumberHeader2, labelYearDropdown: labelYearDropdown2 } = labels;
  const weekdays = (0, import_react37.useMemo)(() => getWeekdays(dateLib, props2.ISOWeek), [dateLib, props2.ISOWeek]);
  const isInteractive = mode !== void 0 || onDayClick !== void 0;
  const handlePreviousClick = (0, import_react37.useCallback)(() => {
    if (!previousMonth)
      return;
    goToMonth(previousMonth);
    onPrevClick == null ? void 0 : onPrevClick(previousMonth);
  }, [previousMonth, goToMonth, onPrevClick]);
  const handleNextClick = (0, import_react37.useCallback)(() => {
    if (!nextMonth)
      return;
    goToMonth(nextMonth);
    onNextClick == null ? void 0 : onNextClick(nextMonth);
  }, [goToMonth, nextMonth, onNextClick]);
  const handleDayClick = (0, import_react37.useCallback)((day, m2) => (e) => {
    e.preventDefault();
    e.stopPropagation();
    setFocused(day);
    select == null ? void 0 : select(day.date, m2, e);
    onDayClick == null ? void 0 : onDayClick(day.date, m2, e);
  }, [select, onDayClick, setFocused]);
  const handleDayFocus = (0, import_react37.useCallback)((day, m2) => (e) => {
    setFocused(day);
    onDayFocus == null ? void 0 : onDayFocus(day.date, m2, e);
  }, [onDayFocus, setFocused]);
  const handleDayBlur = (0, import_react37.useCallback)((day, m2) => (e) => {
    blur();
    onDayBlur == null ? void 0 : onDayBlur(day.date, m2, e);
  }, [blur, onDayBlur]);
  const handleDayKeyDown = (0, import_react37.useCallback)((day, modifiers) => (e) => {
    const keyMap = {
      ArrowLeft: ["day", props2.dir === "rtl" ? "after" : "before"],
      ArrowRight: ["day", props2.dir === "rtl" ? "before" : "after"],
      ArrowDown: ["week", "after"],
      ArrowUp: ["week", "before"],
      PageUp: [e.shiftKey ? "year" : "month", "before"],
      PageDown: [e.shiftKey ? "year" : "month", "after"],
      Home: ["startOfWeek", "before"],
      End: ["endOfWeek", "after"]
    };
    if (keyMap[e.key]) {
      e.preventDefault();
      e.stopPropagation();
      const [moveBy, moveDir] = keyMap[e.key];
      moveFocus(moveBy, moveDir);
    }
    onDayKeyDown == null ? void 0 : onDayKeyDown(day.date, modifiers, e);
  }, [moveFocus, onDayKeyDown, props2.dir]);
  const handleDayMouseEnter = (0, import_react37.useCallback)((day, modifiers) => (e) => {
    onDayMouseEnter == null ? void 0 : onDayMouseEnter(day.date, modifiers, e);
  }, [onDayMouseEnter]);
  const handleDayMouseLeave = (0, import_react37.useCallback)((day, modifiers) => (e) => {
    onDayMouseLeave == null ? void 0 : onDayMouseLeave(day.date, modifiers, e);
  }, [onDayMouseLeave]);
  const handleMonthChange = (0, import_react37.useCallback)((date) => (e) => {
    const selectedMonth = Number(e.target.value);
    const month = dateLib.setMonth(dateLib.startOfMonth(date), selectedMonth);
    goToMonth(month);
  }, [dateLib, goToMonth]);
  const handleYearChange = (0, import_react37.useCallback)((date) => (e) => {
    const selectedYear = Number(e.target.value);
    const month = dateLib.setYear(dateLib.startOfMonth(date), selectedYear);
    goToMonth(month);
  }, [dateLib, goToMonth]);
  const { className, style: style2 } = (0, import_react37.useMemo)(() => ({
    className: [classNames[UI.Root], props2.className].filter(Boolean).join(" "),
    style: __spreadValues(__spreadValues({}, styles == null ? void 0 : styles[UI.Root]), props2.style)
  }), [classNames, props2.className, props2.style, styles]);
  const dataAttributes = getDataAttributes(props2);
  const rootElRef = (0, import_react37.useRef)(null);
  useAnimation(rootElRef, Boolean(props2.animate), {
    classNames,
    months,
    focused,
    dateLib
  });
  const contextValue = {
    dayPickerProps: props2,
    selected: selectedValue,
    select,
    isSelected,
    months,
    nextMonth,
    previousMonth,
    goToMonth,
    getModifiers,
    components,
    classNames,
    styles,
    labels,
    formatters: formatters2
  };
  return import_react37.default.createElement(
    dayPickerContext.Provider,
    { value: contextValue },
    import_react37.default.createElement(
      components.Root,
      __spreadValues({ rootRef: props2.animate ? rootElRef : void 0, className, style: style2, dir: props2.dir, id: props2.id, lang: props2.lang, nonce: props2.nonce, title: props2.title, role: props2.role, "aria-label": props2["aria-label"] }, dataAttributes),
      import_react37.default.createElement(
        components.Months,
        { className: classNames[UI.Months], style: styles == null ? void 0 : styles[UI.Months] },
        !props2.hideNavigation && import_react37.default.createElement(components.Nav, { "data-animated-nav": props2.animate ? "true" : void 0, className: classNames[UI.Nav], style: styles == null ? void 0 : styles[UI.Nav], "aria-label": labelNav2(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth, nextMonth }),
        months.map((calendarMonth, displayIndex) => {
          const dropdownMonths = getMonthOptions(calendarMonth.date, navStart, navEnd, formatters2, dateLib);
          const dropdownYears = getYearOptions(navStart, navEnd, formatters2, dateLib);
          return import_react37.default.createElement(
            components.Month,
            { "data-animated-month": props2.animate ? "true" : void 0, className: classNames[UI.Month], style: styles == null ? void 0 : styles[UI.Month], key: displayIndex, displayIndex, calendarMonth },
            import_react37.default.createElement(components.MonthCaption, { "data-animated-caption": props2.animate ? "true" : void 0, className: classNames[UI.MonthCaption], style: styles == null ? void 0 : styles[UI.MonthCaption], calendarMonth, displayIndex }, (captionLayout == null ? void 0 : captionLayout.startsWith("dropdown")) ? import_react37.default.createElement(
              components.DropdownNav,
              { className: classNames[UI.Dropdowns], style: styles == null ? void 0 : styles[UI.Dropdowns] },
              captionLayout === "dropdown" || captionLayout === "dropdown-months" ? import_react37.default.createElement(components.MonthsDropdown, { className: classNames[UI.MonthsDropdown], "aria-label": labelMonthDropdown2(), classNames, components, disabled: Boolean(props2.disableNavigation), onChange: handleMonthChange(calendarMonth.date), options: dropdownMonths, style: styles == null ? void 0 : styles[UI.Dropdown], value: dateLib.getMonth(calendarMonth.date) }) : import_react37.default.createElement("span", null, formatMonthDropdown2(calendarMonth.date, dateLib)),
              captionLayout === "dropdown" || captionLayout === "dropdown-years" ? import_react37.default.createElement(components.YearsDropdown, { className: classNames[UI.YearsDropdown], "aria-label": labelYearDropdown2(dateLib.options), classNames, components, disabled: Boolean(props2.disableNavigation), onChange: handleYearChange(calendarMonth.date), options: dropdownYears, style: styles == null ? void 0 : styles[UI.Dropdown], value: dateLib.getYear(calendarMonth.date) }) : import_react37.default.createElement("span", null, formatYearDropdown2(calendarMonth.date, dateLib)),
              import_react37.default.createElement("span", { role: "status", "aria-live": "polite", style: {
                border: 0,
                clip: "rect(0 0 0 0)",
                height: "1px",
                margin: "-1px",
                overflow: "hidden",
                padding: 0,
                position: "absolute",
                width: "1px",
                whiteSpace: "nowrap",
                wordWrap: "normal"
              } }, formatCaption2(calendarMonth.date, dateLib.options, dateLib))
            ) : import_react37.default.createElement(components.CaptionLabel, { className: classNames[UI.CaptionLabel], role: "status", "aria-live": "polite" }, formatCaption2(calendarMonth.date, dateLib.options, dateLib))),
            import_react37.default.createElement(
              components.MonthGrid,
              { role: "grid", "aria-multiselectable": mode === "multiple" || mode === "range", "aria-label": labelGrid2(calendarMonth.date, dateLib.options, dateLib) || void 0, className: classNames[UI.MonthGrid], style: styles == null ? void 0 : styles[UI.MonthGrid] },
              !props2.hideWeekdays && import_react37.default.createElement(
                components.Weekdays,
                { "data-animated-weekdays": props2.animate ? "true" : void 0, className: classNames[UI.Weekdays], style: styles == null ? void 0 : styles[UI.Weekdays] },
                showWeekNumber && import_react37.default.createElement(components.WeekNumberHeader, { "aria-label": labelWeekNumberHeader2(dateLib.options), className: classNames[UI.WeekNumberHeader], style: styles == null ? void 0 : styles[UI.WeekNumberHeader], scope: "col" }, formatWeekNumberHeader2()),
                weekdays.map((weekday, i) => import_react37.default.createElement(components.Weekday, { "aria-label": labelWeekday2(weekday, dateLib.options, dateLib), className: classNames[UI.Weekday], key: i, style: styles == null ? void 0 : styles[UI.Weekday], scope: "col" }, formatWeekdayName2(weekday, dateLib.options, dateLib)))
              ),
              import_react37.default.createElement(components.Weeks, { "data-animated-weeks": props2.animate ? "true" : void 0, className: classNames[UI.Weeks], style: styles == null ? void 0 : styles[UI.Weeks] }, calendarMonth.weeks.map((week, weekIndex) => {
                return import_react37.default.createElement(
                  components.Week,
                  { className: classNames[UI.Week], key: week.weekNumber, style: styles == null ? void 0 : styles[UI.Week], week },
                  showWeekNumber && import_react37.default.createElement(components.WeekNumber, { week, style: styles == null ? void 0 : styles[UI.WeekNumber], "aria-label": labelWeekNumber2(week.weekNumber, {
                    locale
                  }), className: classNames[UI.WeekNumber], scope: "row", role: "rowheader" }, formatWeekNumber2(week.weekNumber)),
                  week.days.map((day) => {
                    const { date } = day;
                    const modifiers = getModifiers(day);
                    modifiers[DayFlag.focused] = !modifiers.hidden && Boolean(focused == null ? void 0 : focused.isEqualTo(day));
                    modifiers[SelectionState.selected] = (isSelected == null ? void 0 : isSelected(date)) || modifiers.selected;
                    if (isDateRange(selectedValue)) {
                      const { from, to } = selectedValue;
                      modifiers[SelectionState.range_start] = Boolean(from && to && dateLib.isSameDay(date, from));
                      modifiers[SelectionState.range_end] = Boolean(from && to && dateLib.isSameDay(date, to));
                      modifiers[SelectionState.range_middle] = rangeIncludesDate(selectedValue, date, true, dateLib);
                    }
                    const style3 = getStyleForModifiers(modifiers, styles, props2.modifiersStyles);
                    const className2 = getClassNamesForModifiers(modifiers, classNames, props2.modifiersClassNames);
                    const ariaLabel = !isInteractive && !modifiers.hidden ? labelGridcell2(date, modifiers, dateLib.options, dateLib) : void 0;
                    return import_react37.default.createElement(components.Day, { key: `${dateLib.format(date, "yyyy-MM-dd")}_${dateLib.format(day.displayMonth, "yyyy-MM")}`, day, modifiers, className: className2.join(" "), style: style3, role: "gridcell", "aria-selected": modifiers.selected || void 0, "aria-label": ariaLabel, "data-day": dateLib.format(date, "yyyy-MM-dd"), "data-month": day.outside ? dateLib.format(date, "yyyy-MM") : void 0, "data-selected": modifiers.selected || void 0, "data-disabled": modifiers.disabled || void 0, "data-hidden": modifiers.hidden || void 0, "data-outside": day.outside || void 0, "data-focused": modifiers.focused || void 0, "data-today": modifiers.today || void 0 }, !modifiers.hidden && isInteractive ? import_react37.default.createElement(components.DayButton, { className: classNames[UI.DayButton], style: styles == null ? void 0 : styles[UI.DayButton], type: "button", day, modifiers, disabled: modifiers.disabled || void 0, tabIndex: isFocusTarget(day) ? 0 : -1, "aria-label": labelDayButton2(date, modifiers, dateLib.options, dateLib), onClick: handleDayClick(day, modifiers), onBlur: handleDayBlur(day, modifiers), onFocus: handleDayFocus(day, modifiers), onKeyDown: handleDayKeyDown(day, modifiers), onMouseEnter: handleDayMouseEnter(day, modifiers), onMouseLeave: handleDayMouseLeave(day, modifiers) }, formatDay2(date, dateLib.options, dateLib)) : !modifiers.hidden && formatDay2(day.date, dateLib.options, dateLib));
                  })
                );
              }))
            )
          );
        })
      ),
      props2.footer && import_react37.default.createElement(components.Footer, { className: classNames[UI.Footer], style: styles == null ? void 0 : styles[UI.Footer], role: "status", "aria-live": "polite" }, props2.footer)
    )
  );
}

// src/components/calendar.tsx
var import_utils17 = require("@nubras/utils");

// src/components/select.tsx
var React77 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-select@2.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_ngac5x6oyhhewr4rdrkctcrfia/node_modules/@radix-ui/react-select/dist/index.mjs
var React76 = __toESM(require("react"), 1);
var ReactDOM5 = __toESM(require("react-dom"), 1);

// ../../node_modules/.pnpm/@radix-ui+number@1.1.0/node_modules/@radix-ui/number/dist/index.mjs
function clamp(value, [min3, max3]) {
  return Math.min(max3, Math.max(min3, value));
}

// ../../node_modules/.pnpm/@radix-ui+react-popper@1.2.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_ww2e7laulkx7kjxcn7gji2mwli/node_modules/@radix-ui/react-popper/dist/index.mjs
var React73 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start2, value, end2) {
  return max2(start2, min2(value, end2));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt3 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt3;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x2,
    right: x2 + width,
    bottom: y + height,
    x: x2,
    y
  };
}

// ../../node_modules/.pnpm/@floating-ui+core@1.7.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical2 = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical2 ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical2 ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = (reference, floating, config) => __async(void 0, null, function* () {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
  let rects = yield platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = yield fn({
      x: x2,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? yield platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
});
function detectOverflow(state, options) {
  return __async(this, null, function* () {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  });
}
var arrow = (options) => ({
  name: "arrow",
  options,
  fn(state) {
    return __async(this, null, function* () {
      const {
        x: x2,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = yield platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element);
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !(yield platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max3 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset6 = clamp2(min$1, center, max3);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset6 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: __spreadValues({
          [axis]: offset6,
          centerOffset: center - offset6 - alignmentOffset
        }, shouldAddOffset && {
          alignmentOffset
        }),
        reset: shouldAddOffset
      };
    });
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            var _overflowsData$;
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
            if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      });
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          rects
        } = state;
        const _a2 = evaluate(options, state), {
          strategy = "referenceHidden"
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "strategy"
        ]);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = yield detectOverflow(state, __spreadProps(__spreadValues({}, detectOverflowOptions), {
              elementContext: "reference"
            }));
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = yield detectOverflow(state, __spreadProps(__spreadValues({}, detectOverflowOptions), {
              altBoundary: true
            }));
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      });
    }
  };
};
function convertValueToCoords(state, options) {
  return __async(this, null, function* () {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical2 = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical2 ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical2 ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  });
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = yield convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y + diffCoords.y,
          data: __spreadProps(__spreadValues({}, diffCoords), {
            placement
          })
        };
      });
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          x: x2,
          y,
          placement
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x3,
                y: y2
              } = _ref;
              return {
                x: x3,
                y: y2
              };
            }
          }
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "limiter"
        ]);
        const coords = {
          x: x2,
          y
        };
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min3 = mainAxisCoord + overflow[minSide];
          const max3 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp2(min3, mainAxisCoord, max3);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min3 = crossAxisCoord + overflow[minSide];
          const max3 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp2(min3, crossAxisCoord, max3);
        }
        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        }));
        return __spreadProps(__spreadValues({}, limitedCoords), {
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        });
      });
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset6 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset6, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : __spreadValues({
        mainAxis: 0,
        crossAxis: 0
      }, rawOffset);
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const _a2 = evaluate(options, state), {
          apply: apply2 = () => {
          }
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "apply"
        ]);
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === ((yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max2(overflow.left, 0);
          const xMax = max2(overflow.right, 0);
          const yMin = max2(overflow.top, 0);
          const yMax = max2(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
          }
        }
        yield apply2(__spreadProps(__spreadValues({}, state), {
          availableWidth,
          availableHeight
        }));
        const nextDimensions = yield platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      });
    }
  };
};

// ../../node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../node_modules/.pnpm/@floating-ui+dom@1.7.0/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x2 = ($3 ? round(rect.width) : rect.width) / width;
  let y = ($3 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x: x2,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll2, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll2.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll2.scrollTop;
  return {
    x: x2,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll2.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll2.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll2 = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll2.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll2.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport2 = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y = 0;
  if (visualViewport2) {
    width = visualViewport2.width;
    height = visualViewport2.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport2.offsetLeft;
      y = visualViewport2.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2) : createCoords(0);
  const x2 = rect.left + scroll2.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll2.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = function(data) {
  return __async(this, null, function* () {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = yield getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, yield getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  });
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, __spreadProps(__spreadValues({}, options), {
        // Handle <iframe>s
        root: root.ownerDocument
      }));
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = __spreadValues({
    platform
  }, options);
  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {
    _c: cache2
  });
  return computePosition(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {
    platform: platformWithCache
  }));
};

// ../../node_modules/.pnpm/@floating-ui+react-dom@2.1.2_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React70 = __toESM(require("react"), 1);
var import_react38 = require("react");
var ReactDOM4 = __toESM(require("react-dom"), 1);
var index = typeof document !== "undefined" ? import_react38.useLayoutEffect : import_react38.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref2 = React70.useRef(value);
  index(() => {
    ref2.current = value;
  });
  return ref2;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React70.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React70.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React70.useState(null);
  const [_floating, _setFloating] = React70.useState(null);
  const setReference = React70.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React70.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React70.useRef(null);
  const floatingRef = React70.useRef(null);
  const dataRef = React70.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update2 = React70.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = __spreadProps(__spreadValues({}, data2), {
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      });
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM4.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => __spreadProps(__spreadValues({}, data2), {
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React70.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update2);
      }
      update2();
    }
  }, [referenceEl, floatingEl, update2, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React70.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React70.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React70.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return __spreadValues(__spreadProps(__spreadValues({}, initialStyles), {
        transform: "translate(" + x2 + "px, " + y + "px)"
      }), getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      });
    }
    return {
      position: strategy,
      left: x2,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React70.useMemo(() => __spreadProps(__spreadValues({}, data), {
    update: update2,
    refs,
    elements,
    floatingStyles
  }), [data, update2, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => __spreadProps(__spreadValues({}, offset2(options)), {
  options: [options, deps]
});
var shift3 = (options, deps) => __spreadProps(__spreadValues({}, shift2(options)), {
  options: [options, deps]
});
var limitShift3 = (options, deps) => __spreadProps(__spreadValues({}, limitShift2(options)), {
  options: [options, deps]
});
var flip3 = (options, deps) => __spreadProps(__spreadValues({}, flip2(options)), {
  options: [options, deps]
});
var size3 = (options, deps) => __spreadProps(__spreadValues({}, size2(options)), {
  options: [options, deps]
});
var hide3 = (options, deps) => __spreadProps(__spreadValues({}, hide2(options)), {
  options: [options, deps]
});
var arrow3 = (options, deps) => __spreadProps(__spreadValues({}, arrow$1(options)), {
  options: [options, deps]
});

// ../../node_modules/.pnpm/@radix-ui+react-arrow@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3__6sisoq4w6sv4o6ymukpj3f3cju/node_modules/@radix-ui/react-arrow/dist/index.mjs
var React71 = __toESM(require("react"), 1);
var import_jsx_runtime25 = require("react/jsx-runtime");
var NAME2 = "Arrow";
var Arrow = React71.forwardRef((props2, forwardedRef) => {
  const _a = props2, { children, width = 10, height = 5 } = _a, arrowProps = __objRest(_a, ["children", "width", "height"]);
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    Primitive.svg,
    __spreadProps(__spreadValues({}, arrowProps), {
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props2.asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("polygon", { points: "0,0 30,0 15,10" })
    })
  );
});
Arrow.displayName = NAME2;
var Root8 = Arrow;

// ../../node_modules/.pnpm/@radix-ui+react-use-size@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-size/dist/index.mjs
var React72 = __toESM(require("react"), 1);
function useSize(element) {
  const [size4, setSize] = React72.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// ../../node_modules/.pnpm/@radix-ui+react-popper@1.2.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_ww2e7laulkx7kjxcn7gji2mwli/node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime26 = require("react/jsx-runtime");
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props2) => {
  const { __scopePopper, children } = props2;
  const [anchor, setAnchor] = React73.useState(null);
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React73.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopePopper, virtualRef } = _a, anchorProps = __objRest(_a, ["__scopePopper", "virtualRef"]);
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref2 = React73.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    React73.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref2.current);
    });
    return virtualRef ? null : /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(Primitive.div, __spreadProps(__spreadValues({}, anchorProps), { ref: composedRefs }));
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME5 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME5);
var PopperContent = React73.forwardRef(
  (props2, forwardedRef) => {
    var _b, _c, _d, _e, _f, _g, _h, _i;
    const _a = props2, {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced
    } = _a, contentProps = __objRest(_a, [
      "__scopePopper",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "onPlaced"
    ]);
    const context = usePopperContext(CONTENT_NAME5, __scopePopper);
    const [content, setContent] = React73.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React73.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = (_b = arrowSize == null ? void 0 : arrowSize.width) != null ? _b : 0;
    const arrowHeight = (_c = arrowSize == null ? void 0 : arrowSize.height) != null ? _c : 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : __spreadValues({ top: 0, right: 0, bottom: 0, left: 0 }, collisionPaddingProp);
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3(__spreadValues({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0
        }, detectOverflowOptions)),
        avoidCollisions && flip3(__spreadValues({}, detectOverflowOptions)),
        size3(__spreadProps(__spreadValues({}, detectOverflowOptions), {
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        })),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3(__spreadValues({ strategy: "referenceHidden" }, detectOverflowOptions))
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_d = middlewareData.arrow) == null ? void 0 : _d.x;
    const arrowY = (_e = middlewareData.arrow) == null ? void 0 : _e.y;
    const cannotCenterArrow = ((_f = middlewareData.arrow) == null ? void 0 : _f.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React73.useState();
    useLayoutEffect2(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: __spreadValues(__spreadProps(__spreadValues({}, floatingStyles), {
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_g = middlewareData.transformOrigin) == null ? void 0 : _g.x,
            (_h = middlewareData.transformOrigin) == null ? void 0 : _h.y
          ].join(" ")
        }), ((_i = middlewareData.hide) == null ? void 0 : _i.referenceHidden) && {
          visibility: "hidden",
          pointerEvents: "none"
        }),
        dir: props2.dir,
        children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
              Primitive.div,
              __spreadProps(__spreadValues({
                "data-side": placedSide,
                "data-align": placedAlign
              }, contentProps), {
                ref: composedRefs,
                style: __spreadProps(__spreadValues({}, contentProps.style), {
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                })
              })
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME5;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React73.forwardRef(function PopperArrow2(props2, forwardedRef) {
  const _a = props2, { __scopePopper } = _a, arrowProps = __objRest(_a, ["__scopePopper"]);
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
          Root8,
          __spreadProps(__spreadValues({}, arrowProps), {
            ref: forwardedRef,
            style: __spreadProps(__spreadValues({}, arrowProps.style), {
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            })
          })
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a, _b, _c, _d, _e;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = ((_c = (_b = middlewareData.arrow) == null ? void 0 : _b.x) != null ? _c : 0) + arrowWidth / 2;
    const arrowYCenter = ((_e = (_d = middlewareData.arrow) == null ? void 0 : _d.y) != null ? _e : 0) + arrowHeight / 2;
    let x2 = "";
    let y = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root23 = Popper;
var Anchor = PopperAnchor;
var Content4 = PopperContent;
var Arrow2 = PopperArrow;

// ../../node_modules/.pnpm/@radix-ui+react-use-previous@1.1.0_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-previous/dist/index.mjs
var React74 = __toESM(require("react"), 1);
function usePrevious(value) {
  const ref2 = React74.useRef({ value, previous: value });
  return React74.useMemo(() => {
    if (ref2.current.value !== value) {
      ref2.current.previous = ref2.current.value;
      ref2.current.value = value;
    }
    return ref2.current.previous;
  }, [value]);
}

// ../../node_modules/.pnpm/@radix-ui+react-visually-hidden@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+rea_3usne5ppai5e2tr5lkdtix6v7i/node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React75 = __toESM(require("react"), 1);
var import_jsx_runtime27 = require("react/jsx-runtime");
var NAME3 = "VisuallyHidden";
var VisuallyHidden = React75.forwardRef(
  (props2, forwardedRef) => {
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
      Primitive.span,
      __spreadProps(__spreadValues({}, props2), {
        ref: forwardedRef,
        style: __spreadValues({
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal"
        }, props2.style)
      })
    );
  }
);
VisuallyHidden.displayName = NAME3;
var Root9 = VisuallyHidden;

// ../../node_modules/.pnpm/@radix-ui+react-select@2.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_ngac5x6oyhhewr4rdrkctcrfia/node_modules/@radix-ui/react-select/dist/index.mjs
var import_jsx_runtime28 = require("react/jsx-runtime");
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope2,
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select2 = (props2) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required: required2,
    form
  } = props2;
  const popperScope = usePopperScope(__scopeSelect);
  const [trigger, setTrigger] = React76.useState(null);
  const [valueNode, setValueNode] = React76.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React76.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React76.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React76.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Root23, __spreadProps(__spreadValues({}, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(
    SelectProvider,
    {
      required: required2,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Collection2.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
          SelectNativeOptionsProvider,
          {
            scope: props2.__scopeSelect,
            onNativeOptionAdd: React76.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React76.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(
          BubbleSelect,
          {
            "aria-hidden": true,
            required: required2,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) }));
};
Select2.displayName = SELECT_NAME;
var TRIGGER_NAME5 = "SelectTrigger";
var SelectTrigger = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect, disabled = false } = _a, triggerProps = __objRest(_a, ["__scopeSelect", "disabled"]);
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME5, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection2(__scopeSelect);
    const pointerTypeRef = React76.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Anchor, __spreadProps(__spreadValues({ asChild: true }, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0
      }, triggerProps), {
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1)
            handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ")
            return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      })
    ) }));
  }
);
SelectTrigger.displayName = TRIGGER_NAME5;
var VALUE_NAME = "SelectValue";
var SelectValue = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect, className, style: style2, children, placeholder: placeholder2 = "" } = _a, valueProps = __objRest(_a, ["__scopeSelect", "className", "style", "children", "placeholder"]);
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
      Primitive.span,
      __spreadProps(__spreadValues({}, valueProps), {
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(import_jsx_runtime28.Fragment, { children: placeholder2 }) : children
      })
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect, children } = _a, iconProps = __objRest(_a, ["__scopeSelect", "children"]);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Primitive.span, __spreadProps(__spreadValues({ "aria-hidden": true }, iconProps), { ref: forwardedRef, children: children || "\u25BC" }));
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME4 = "SelectPortal";
var SelectPortal = (props2) => {
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Portal, __spreadValues({ asChild: true }, props2));
};
SelectPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME6 = "SelectContent";
var SelectContent = React76.forwardRef(
  (props2, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME6, props2.__scopeSelect);
    const [fragment, setFragment] = React76.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM5.createPortal(
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(SelectContentProvider, { scope: props2.__scopeSelect, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Collection2.Slot, { scope: props2.__scopeSelect, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { children: props2.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(SelectContentImpl, __spreadProps(__spreadValues({}, props2), { ref: forwardedRef }));
  }
);
SelectContent.displayName = CONTENT_NAME6;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME6);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeSelect,
      position: position2 = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      side: side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } = _a, contentProps = __objRest(_a, [
      "__scopeSelect",
      "position",
      "onCloseAutoFocus",
      "onEscapeKeyDown",
      "onPointerDownOutside",
      //
      // PopperContent props
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "avoidCollisions"
    ]);
    const context = useSelectContext(CONTENT_NAME6, __scopeSelect);
    const [content, setContent] = React76.useState(null);
    const [viewport, setViewport] = React76.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React76.useState(null);
    const [selectedItemText, setSelectedItemText] = React76.useState(
      null
    );
    const getItems = useCollection2(__scopeSelect);
    const [isPositioned, setIsPositioned] = React76.useState(false);
    const firstValidItemFoundRef = React76.useRef(false);
    React76.useEffect(() => {
      if (content)
        return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst8 = React76.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
            return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport)
            viewport.scrollTop = 0;
          if (candidate === lastItem && viewport)
            viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
            return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React76.useCallback(
      () => focusFirst8([selectedItem, content]),
      [focusFirst8, selectedItem, content]
    );
    React76.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React76.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove2 = (event) => {
          var _a2, _b, _c, _d;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - ((_b = (_a2 = triggerPointerDownPosRef.current) == null ? void 0 : _a2.x) != null ? _b : 0)),
            y: Math.abs(Math.round(event.pageY) - ((_d = (_c = triggerPointerDownPosRef.current) == null ? void 0 : _c.y) != null ? _d : 0))
          };
        };
        const handlePointerUp2 = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove2);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove2);
          document.addEventListener("pointerup", handlePointerUp2, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove2);
          document.removeEventListener("pointerup", handlePointerUp2, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React76.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React76.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem)
            firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React76.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React76.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position2 === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position: position2,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a2;
              (_a2 = context.trigger) == null ? void 0 : _a2.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
                  SelectPosition,
                  __spreadProps(__spreadValues(__spreadValues({
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault()
                  }, contentProps), popperContentProps), {
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: __spreadValues({
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none"
                    }, contentProps.style),
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab")
                        event.preventDefault();
                      if (!isModifierKey && event.key.length === 1)
                        handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst8(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  })
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React76.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeSelect, onPlaced } = _a, popperProps = __objRest(_a, ["__scopeSelect", "onPlaced"]);
  const context = useSelectContext(CONTENT_NAME6, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME6, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React76.useState(null);
  const [content, setContent] = React76.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection2(__scopeSelect);
  const shouldExpandOnScrollRef = React76.useRef(false);
  const shouldRepositionRef = React76.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position2 = React76.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position2(), [position2]);
  const [contentZIndex, setContentZIndex] = React76.useState();
  useLayoutEffect2(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React76.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position2();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position2, focusSelectedItem]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
            Primitive.div,
            __spreadProps(__spreadValues({}, popperProps), {
              ref: composedRefs,
              style: __spreadValues({
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%"
              }, popperProps.style)
            })
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React76.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN
  } = _a, popperProps = __objRest(_a, [
    "__scopeSelect",
    "align",
    "collisionPadding"
  ]);
  const popperScope = usePopperScope(__scopeSelect);
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    Content4,
    __spreadProps(__spreadValues(__spreadValues({}, popperScope), popperProps), {
      ref: forwardedRef,
      align,
      collisionPadding,
      style: __spreadValues(__spreadValues({
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box"
      }, popperProps.style), {
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      })
    })
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME6, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect, nonce: nonce2 } = _a, viewportProps = __objRest(_a, ["__scopeSelect", "nonce"]);
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React76.useRef(0);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce: nonce2
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Collection2.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        Primitive.div,
        __spreadProps(__spreadValues({
          "data-radix-select-viewport": "",
          role: "presentation"
        }, viewportProps), {
          ref: composedRefs,
          style: __spreadValues({
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto"
          }, viewportProps.style),
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        })
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect } = _a, groupProps = __objRest(_a, ["__scopeSelect"]);
    const groupId = useId();
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Primitive.div, __spreadProps(__spreadValues({ role: "group", "aria-labelledby": groupId }, groupProps), { ref: forwardedRef })) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect } = _a, labelProps = __objRest(_a, ["__scopeSelect"]);
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Primitive.div, __spreadProps(__spreadValues({ id: groupContext.id }, labelProps), { ref: forwardedRef }));
  }
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME2 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME2);
var SelectItem = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp
    } = _a, itemProps = __objRest(_a, [
      "__scopeSelect",
      "value",
      "disabled",
      "textValue"
    ]);
    const context = useSelectContext(ITEM_NAME2, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME2, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React76.useState(textValueProp != null ? textValueProp : "");
    const [isFocused, setIsFocused] = React76.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a2;
        return (_a2 = contentContext.itemRefCallback) == null ? void 0 : _a2.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId();
    const pointerTypeRef = React76.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React76.useCallback((node) => {
          setTextValue((prevTextValue) => {
            var _a2;
            return prevTextValue || ((_a2 = node == null ? void 0 : node.textContent) != null ? _a2 : "").trim();
          });
        }, []),
        children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
          Collection2.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
              Primitive.div,
              __spreadProps(__spreadValues({
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1
              }, itemProps), {
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse")
                    handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse")
                    handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a2;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a2;
                  if (event.currentTarget === document.activeElement) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a2;
                  const isTypingAhead = ((_a2 = contentContext.searchRef) == null ? void 0 : _a2.current) !== "";
                  if (isTypingAhead && event.key === " ")
                    return;
                  if (SELECTION_KEYS.includes(event.key))
                    handleSelect();
                  if (event.key === " ")
                    event.preventDefault();
                })
              })
            )
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME2;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect, className, style: style2 } = _a, itemTextProps = __objRest(_a, ["__scopeSelect", "className", "style"]);
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React76.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a2;
        return (_a2 = contentContext.itemTextRefCallback) == null ? void 0 : _a2.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React76.useMemo(
      () => /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Primitive.span, __spreadProps(__spreadValues({ id: itemContext.textId }, itemTextProps), { ref: composedRefs })),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM5.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect } = _a, itemIndicatorProps = __objRest(_a, ["__scopeSelect"]);
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Primitive.span, __spreadProps(__spreadValues({ "aria-hidden": true }, itemIndicatorProps), { ref: forwardedRef })) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React76.forwardRef((props2, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props2.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props2.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React76.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    SelectScrollButtonImpl,
    __spreadProps(__spreadValues({}, props2), {
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    })
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React76.forwardRef((props2, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props2.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props2.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React76.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    SelectScrollButtonImpl,
    __spreadProps(__spreadValues({}, props2), {
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    })
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React76.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeSelect, onAutoScroll } = _a, scrollIndicatorProps = __objRest(_a, ["__scopeSelect", "onAutoScroll"]);
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React76.useRef(null);
  const getItems = useCollection2(__scopeSelect);
  const clearAutoScrollTimer = React76.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React76.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    var _a2;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a2 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a2.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    Primitive.div,
    __spreadProps(__spreadValues({
      "aria-hidden": true
    }, scrollIndicatorProps), {
      ref: forwardedRef,
      style: __spreadValues({ flexShrink: 0 }, scrollIndicatorProps.style),
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a2;
        (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    })
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect } = _a, separatorProps = __objRest(_a, ["__scopeSelect"]);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Primitive.div, __spreadProps(__spreadValues({ "aria-hidden": true }, separatorProps), { ref: forwardedRef }));
  }
);
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME2 = "SelectArrow";
var SelectArrow = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSelect } = _a, arrowProps = __objRest(_a, ["__scopeSelect"]);
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(ARROW_NAME2, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME2, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Arrow2, __spreadProps(__spreadValues(__spreadValues({}, popperScope), arrowProps), { ref: forwardedRef })) : null;
  }
);
SelectArrow.displayName = ARROW_NAME2;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = React76.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { value } = _a, selectProps = __objRest(_a, ["value"]);
    const ref2 = React76.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const prevValue = usePrevious(value);
    React76.useEffect(() => {
      const select = ref2.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("select", __spreadProps(__spreadValues({}, selectProps), { ref: composedRefs, defaultValue: value })) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef(onSearchChange);
  const searchRef = React76.useRef("");
  const timerRef = React76.useRef(0);
  const handleTypeaheadSearch = React76.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React76.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React76.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem)
    wrappedItems = wrappedItems.filter((v2) => v2 !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root24 = Select2;
var Trigger4 = SelectTrigger;
var Value = SelectValue;
var Icon2 = SelectIcon;
var Portal3 = SelectPortal;
var Content23 = SelectContent;
var Viewport = SelectViewport;
var Group = SelectGroup;
var Label = SelectLabel;
var Item2 = SelectItem;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton;
var ScrollDownButton = SelectScrollDownButton;
var Separator = SelectSeparator;

// src/components/select.tsx
var import_utils16 = require("@nubras/utils");
var import_jsx_runtime29 = require("react/jsx-runtime");
var Select3 = Root24;
var SelectGroup2 = Group;
var SelectValue2 = Value;
var SelectTrigger2 = React77.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
    Trigger4,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils16.cn)(
        "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
        className
      )
    }, props2), {
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Icon2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(ChevronDown, { className: "h-4 w-4 opacity-50" }) })
      ]
    })
  );
});
SelectTrigger2.displayName = Trigger4.displayName;
var SelectScrollUpButton2 = React77.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
    ScrollUpButton,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils16.cn)(
        "flex cursor-default items-center justify-center py-1",
        className
      )
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(ChevronUp, { className: "h-4 w-4" })
    })
  );
});
SelectScrollUpButton2.displayName = ScrollUpButton.displayName;
var SelectScrollDownButton2 = React77.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
    ScrollDownButton,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils16.cn)(
        "flex cursor-default items-center justify-center py-1",
        className
      )
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(ChevronDown, { className: "h-4 w-4" })
    })
  );
});
SelectScrollDownButton2.displayName = ScrollDownButton.displayName;
var SelectContent2 = React77.forwardRef((_a, ref2) => {
  var _b = _a, { className, children, position: position2 = "popper" } = _b, props2 = __objRest(_b, ["className", "children", "position"]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Portal3, { children: /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
    Content23,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils16.cn)(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position2 === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      ),
      position: position2
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(SelectScrollUpButton2, {}),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
          Viewport,
          {
            className: (0, import_utils16.cn)(
              "p-1",
              position2 === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
            ),
            children
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(SelectScrollDownButton2, {})
      ]
    })
  ) });
});
SelectContent2.displayName = Content23.displayName;
var SelectLabel2 = React77.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
    Label,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils16.cn)("py-1.5 pl-8 pr-2 text-sm font-semibold", className)
    }, props2)
  );
});
SelectLabel2.displayName = Label.displayName;
var SelectItem2 = React77.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
    Item2,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils16.cn)(
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(ItemIndicator, { children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Check, { className: "h-4 w-4" }) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(ItemText, { children })
      ]
    })
  );
});
SelectItem2.displayName = Item2.displayName;
var SelectSeparator2 = React77.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
    Separator,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils16.cn)("-mx-1 my-1 h-px bg-muted", className)
    }, props2)
  );
});
SelectSeparator2.displayName = Separator.displayName;

// src/components/calendar.tsx
var import_jsx_runtime30 = require("react/jsx-runtime");
function CalendarDropdown(_a) {
  var _b = _a, { value, onChange, children } = _b, props2 = __objRest(_b, ["value", "onChange", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(Select3, { value: String(value), onValueChange: (value2) => onChange == null ? void 0 : onChange(value2), children: [
    /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(SelectTrigger2, { className: "h-7 w-fit gap-1 rounded-md border-0 bg-transparent p-0 font-medium shadow-none [&>span]:flex [&>span]:items-center [&>span]:gap-1", children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(SelectValue2, { children }) }),
    /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(SelectContent2, { position: "popper", children: React78.Children.map(children, (child) => React78.isValidElement(child) && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(SelectItem2, { value: String(child.props.value), className: "min-w-[var(--radix-select-trigger-width)]", children: child.props.children })) })
  ] });
}
function Calendar2(_a) {
  var _b = _a, { className, classNames, showOutsideDays = true } = _b, props2 = __objRest(_b, ["className", "classNames", "showOutsideDays"]);
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    DayPicker,
    __spreadValues({
      showOutsideDays,
      className: (0, import_utils17.cn)("p-3", className),
      classNames: __spreadValues({
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        caption_dropdowns: "flex justify-center gap-1",
        nav: "space-x-1 flex items-center",
        nav_button: (0, import_utils17.cn)(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: (0, import_utils17.cn)(buttonVariants({ variant: "ghost" }), "h-9 w-9 p-0 font-normal aria-selected:opacity-100"),
        day_range_end: "day-range-end",
        day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible"
      }, classNames),
      components: {
        Dropdown: CalendarDropdown
      }
    }, props2)
  );
}

// src/components/card.tsx
var React79 = __toESM(require("react"));
var import_utils18 = require("@nubras/utils");
var import_jsx_runtime31 = require("react/jsx-runtime");
var Card = React79.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils18.cn)(
        "rounded-lg border bg-card text-card-foreground shadow-sm",
        className
      )
    }, props2)
  );
});
Card.displayName = "Card";
var CardHeader = React79.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils18.cn)("flex flex-col space-y-1.5 p-6", className)
    }, props2)
  );
});
CardHeader.displayName = "CardHeader";
var CardTitle = React79.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils18.cn)(
        "text-2xl font-semibold leading-none tracking-tight",
        className
      )
    }, props2)
  );
});
CardTitle.displayName = "CardTitle";
var CardDescription = React79.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils18.cn)("text-sm text-muted-foreground", className)
    }, props2)
  );
});
CardDescription.displayName = "CardDescription";
var CardContent = React79.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", __spreadValues({ ref: ref2, className: (0, import_utils18.cn)("p-6 pt-0", className) }, props2));
});
CardContent.displayName = "CardContent";
var CardFooter = React79.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils18.cn)("flex items-center p-6 pt-0", className)
    }, props2)
  );
});
CardFooter.displayName = "CardFooter";

// src/components/carousel.tsx
var React80 = __toESM(require("react"));

// ../../node_modules/.pnpm/embla-carousel-react@8.5.1_react@19.1.0/node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js
var import_react39 = require("react");

// ../../node_modules/.pnpm/embla-carousel-reactive-utils@8.5.1_embla-carousel@8.5.1/node_modules/embla-carousel-reactive-utils/esm/embla-carousel-reactive-utils.esm.js
function isObject(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function isRecord(subject) {
  return isObject(subject) || Array.isArray(subject);
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function areOptionsEqual(optionsA, optionsB) {
  const optionsAKeys = Object.keys(optionsA);
  const optionsBKeys = Object.keys(optionsB);
  if (optionsAKeys.length !== optionsBKeys.length)
    return false;
  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}));
  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}));
  if (breakpointsA !== breakpointsB)
    return false;
  return optionsAKeys.every((key) => {
    const valueA = optionsA[key];
    const valueB = optionsB[key];
    if (typeof valueA === "function")
      return `${valueA}` === `${valueB}`;
    if (!isRecord(valueA) || !isRecord(valueB))
      return valueA === valueB;
    return areOptionsEqual(valueA, valueB);
  });
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort((a, b) => a.name > b.name ? 1 : -1).map((plugin) => plugin.options);
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length)
    return false;
  const optionsA = sortAndMapPluginToOptions(pluginsA);
  const optionsB = sortAndMapPluginToOptions(pluginsB);
  return optionsA.every((optionA, index2) => {
    const optionB = optionsB[index2];
    return areOptionsEqual(optionA, optionB);
  });
}

// ../../node_modules/.pnpm/embla-carousel@8.5.1/node_modules/embla-carousel/esm/embla-carousel.esm.js
function isNumber(subject) {
  return typeof subject === "number";
}
function isString(subject) {
  return typeof subject === "string";
}
function isBoolean(subject) {
  return typeof subject === "boolean";
}
function isObject2(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function mathAbs(n3) {
  return Math.abs(n3);
}
function mathSign(n3) {
  return Math.sign(n3);
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA);
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0)
    return 0;
  if (mathAbs(valueB) <= mathAbs(valueA))
    return 0;
  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
  return mathAbs(diff / valueB);
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100;
}
function arrayKeys(array) {
  return objectKeys(array).map(Number);
}
function arrayLast(array) {
  return array[arrayLastIndex(array)];
}
function arrayLastIndex(array) {
  return Math.max(0, array.length - 1);
}
function arrayIsLastIndex(array, index2) {
  return index2 === arrayLastIndex(array);
}
function arrayFromNumber(n3, startAt = 0) {
  return Array.from(Array(n3), (_2, i) => startAt + i);
}
function objectKeys(object) {
  return Object.keys(object);
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => {
    objectKeys(currentObject).forEach((key) => {
      const valueA = mergedObjects[key];
      const valueB = currentObject[key];
      const areObjects = isObject2(valueA) && isObject2(valueB);
      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
    });
    return mergedObjects;
  }, {});
}
function isMouseEvent(evt, ownerWindow) {
  return typeof ownerWindow.MouseEvent !== "undefined" && evt instanceof ownerWindow.MouseEvent;
}
function Alignment(align, viewSize) {
  const predefined = {
    start: start2,
    center,
    end: end2
  };
  function start2() {
    return 0;
  }
  function center(n3) {
    return end2(n3) / 2;
  }
  function end2(n3) {
    return viewSize - n3;
  }
  function measure(n3, index2) {
    if (isString(align))
      return predefined[align](n3);
    return align(viewSize, n3, index2);
  }
  const self = {
    measure
  };
  return self;
}
function EventStore() {
  let listeners3 = [];
  function add2(node, type, handler, options = {
    passive: true
  }) {
    let removeListener;
    if ("addEventListener" in node) {
      node.addEventListener(type, handler, options);
      removeListener = () => node.removeEventListener(type, handler, options);
    } else {
      const legacyMediaQueryList = node;
      legacyMediaQueryList.addListener(handler);
      removeListener = () => legacyMediaQueryList.removeListener(handler);
    }
    listeners3.push(removeListener);
    return self;
  }
  function clear() {
    listeners3 = listeners3.filter((remove) => remove());
  }
  const self = {
    add: add2,
    clear
  };
  return self;
}
function Animations(ownerDocument, ownerWindow, update2, render) {
  const documentVisibleHandler = EventStore();
  const fixedTimeStep = 1e3 / 60;
  let lastTimeStamp = null;
  let accumulatedTime = 0;
  let animationId = 0;
  function init() {
    documentVisibleHandler.add(ownerDocument, "visibilitychange", () => {
      if (ownerDocument.hidden)
        reset2();
    });
  }
  function destroy() {
    stop();
    documentVisibleHandler.clear();
  }
  function animate(timeStamp) {
    if (!animationId)
      return;
    if (!lastTimeStamp)
      lastTimeStamp = timeStamp;
    const timeElapsed = timeStamp - lastTimeStamp;
    lastTimeStamp = timeStamp;
    accumulatedTime += timeElapsed;
    while (accumulatedTime >= fixedTimeStep) {
      update2();
      accumulatedTime -= fixedTimeStep;
    }
    const alpha = accumulatedTime / fixedTimeStep;
    render(alpha);
    if (animationId) {
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
  }
  function start2() {
    if (animationId)
      return;
    animationId = ownerWindow.requestAnimationFrame(animate);
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId);
    lastTimeStamp = null;
    accumulatedTime = 0;
    animationId = 0;
  }
  function reset2() {
    lastTimeStamp = null;
    accumulatedTime = 0;
  }
  const self = {
    init,
    destroy,
    start: start2,
    stop,
    update: update2,
    render
  };
  return self;
}
function Axis(axis, contentDirection) {
  const isRightToLeft = contentDirection === "rtl";
  const isVertical2 = axis === "y";
  const scroll2 = isVertical2 ? "y" : "x";
  const cross = isVertical2 ? "x" : "y";
  const sign = !isVertical2 && isRightToLeft ? -1 : 1;
  const startEdge = getStartEdge();
  const endEdge = getEndEdge();
  function measureSize(nodeRect) {
    const {
      height,
      width
    } = nodeRect;
    return isVertical2 ? height : width;
  }
  function getStartEdge() {
    if (isVertical2)
      return "top";
    return isRightToLeft ? "right" : "left";
  }
  function getEndEdge() {
    if (isVertical2)
      return "bottom";
    return isRightToLeft ? "left" : "right";
  }
  function direction(n3) {
    return n3 * sign;
  }
  const self = {
    scroll: scroll2,
    cross,
    startEdge,
    endEdge,
    measureSize,
    direction
  };
  return self;
}
function Limit(min3 = 0, max3 = 0) {
  const length = mathAbs(min3 - max3);
  function reachedMin(n3) {
    return n3 < min3;
  }
  function reachedMax(n3) {
    return n3 > max3;
  }
  function reachedAny(n3) {
    return reachedMin(n3) || reachedMax(n3);
  }
  function constrain(n3) {
    if (!reachedAny(n3))
      return n3;
    return reachedMin(n3) ? min3 : max3;
  }
  function removeOffset(n3) {
    if (!length)
      return n3;
    return n3 - length * Math.ceil((n3 - max3) / length);
  }
  const self = {
    length,
    max: max3,
    min: min3,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
  return self;
}
function Counter(max3, start2, loop) {
  const {
    constrain
  } = Limit(0, max3);
  const loopEnd = max3 + 1;
  let counter2 = withinLimit(start2);
  function withinLimit(n3) {
    return !loop ? constrain(n3) : mathAbs((loopEnd + n3) % loopEnd);
  }
  function get2() {
    return counter2;
  }
  function set3(n3) {
    counter2 = withinLimit(n3);
    return self;
  }
  function add2(n3) {
    return clone().set(get2() + n3);
  }
  function clone() {
    return Counter(max3, get2(), loop);
  }
  const self = {
    get: get2,
    set: set3,
    add: add2,
    clone
  };
  return self;
}
function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index2, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
  const {
    cross: crossAxis,
    direction
  } = axis;
  const focusNodes = ["INPUT", "SELECT", "TEXTAREA"];
  const nonPassiveEvent = {
    passive: false
  };
  const initEvents = EventStore();
  const dragEvents = EventStore();
  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
  const snapForceBoost = {
    mouse: 300,
    touch: 400
  };
  const freeForceBoost = {
    mouse: 500,
    touch: 600
  };
  const baseSpeed = dragFree ? 43 : 25;
  let isMoving = false;
  let startScroll = 0;
  let startCross = 0;
  let pointerIsDown = false;
  let preventScroll = false;
  let preventClick = false;
  let isMouse = false;
  function init(emblaApi) {
    if (!watchDrag)
      return;
    function downIfAllowed(evt) {
      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt))
        down(evt);
    }
    const node = rootNode;
    initEvents.add(node, "dragstart", (evt) => evt.preventDefault(), nonPassiveEvent).add(node, "touchmove", () => void 0, nonPassiveEvent).add(node, "touchend", () => void 0).add(node, "touchstart", downIfAllowed).add(node, "mousedown", downIfAllowed).add(node, "touchcancel", up).add(node, "contextmenu", up).add(node, "click", click, true);
  }
  function destroy() {
    initEvents.clear();
    dragEvents.clear();
  }
  function addDragEvents() {
    const node = isMouse ? ownerDocument : rootNode;
    dragEvents.add(node, "touchmove", move2, nonPassiveEvent).add(node, "touchend", up).add(node, "mousemove", move2, nonPassiveEvent).add(node, "mouseup", up);
  }
  function isFocusNode(node) {
    const nodeName = node.nodeName || "";
    return focusNodes.includes(nodeName);
  }
  function forceBoost() {
    const boost = dragFree ? freeForceBoost : snapForceBoost;
    const type = isMouse ? "mouse" : "touch";
    return boost[type];
  }
  function allowedForce(force, targetChanged) {
    const next = index2.add(mathSign(force) * -1);
    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
    if (dragFree || mathAbs(force) < goToNextThreshold)
      return baseForce;
    if (skipSnaps && targetChanged)
      return baseForce * 0.5;
    return scrollTarget.byIndex(next.get(), 0).distance;
  }
  function down(evt) {
    const isMouseEvt = isMouseEvent(evt, ownerWindow);
    isMouse = isMouseEvt;
    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
    isMoving = deltaAbs(target.get(), location.get()) >= 2;
    if (isMouseEvt && evt.button !== 0)
      return;
    if (isFocusNode(evt.target))
      return;
    pointerIsDown = true;
    dragTracker.pointerDown(evt);
    scrollBody.useFriction(0).useDuration(0);
    target.set(location);
    addDragEvents();
    startScroll = dragTracker.readPoint(evt);
    startCross = dragTracker.readPoint(evt, crossAxis);
    eventHandler.emit("pointerDown");
  }
  function move2(evt) {
    const isTouchEvt = !isMouseEvent(evt, ownerWindow);
    if (isTouchEvt && evt.touches.length >= 2)
      return up(evt);
    const lastScroll = dragTracker.readPoint(evt);
    const lastCross = dragTracker.readPoint(evt, crossAxis);
    const diffScroll = deltaAbs(lastScroll, startScroll);
    const diffCross = deltaAbs(lastCross, startCross);
    if (!preventScroll && !isMouse) {
      if (!evt.cancelable)
        return up(evt);
      preventScroll = diffScroll > diffCross;
      if (!preventScroll)
        return up(evt);
    }
    const diff = dragTracker.pointerMove(evt);
    if (diffScroll > dragThreshold)
      preventClick = true;
    scrollBody.useFriction(0.3).useDuration(0.75);
    animation.start();
    target.add(direction(diff));
    evt.preventDefault();
  }
  function up(evt) {
    const currentLocation = scrollTarget.byDistance(0, false);
    const targetChanged = currentLocation.index !== index2.get();
    const rawForce = dragTracker.pointerUp(evt) * forceBoost();
    const force = allowedForce(direction(rawForce), targetChanged);
    const forceFactor = factorAbs(rawForce, force);
    const speed = baseSpeed - 10 * forceFactor;
    const friction = baseFriction + forceFactor / 50;
    preventScroll = false;
    pointerIsDown = false;
    dragEvents.clear();
    scrollBody.useDuration(speed).useFriction(friction);
    scrollTo.distance(force, !dragFree);
    isMouse = false;
    eventHandler.emit("pointerUp");
  }
  function click(evt) {
    if (preventClick) {
      evt.stopPropagation();
      evt.preventDefault();
      preventClick = false;
    }
  }
  function pointerDown() {
    return pointerIsDown;
  }
  const self = {
    init,
    destroy,
    pointerDown
  };
  return self;
}
function DragTracker(axis, ownerWindow) {
  const logInterval = 170;
  let startEvent;
  let lastEvent;
  function readTime(evt) {
    return evt.timeStamp;
  }
  function readPoint(evt, evtAxis) {
    const property = evtAxis || axis.scroll;
    const coord = `client${property === "x" ? "X" : "Y"}`;
    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];
  }
  function pointerDown(evt) {
    startEvent = evt;
    lastEvent = evt;
    return readPoint(evt);
  }
  function pointerMove(evt) {
    const diff = readPoint(evt) - readPoint(lastEvent);
    const expired = readTime(evt) - readTime(startEvent) > logInterval;
    lastEvent = evt;
    if (expired)
      startEvent = evt;
    return diff;
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent)
      return 0;
    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
    const diffTime = readTime(evt) - readTime(startEvent);
    const expired = readTime(evt) - readTime(lastEvent) > logInterval;
    const force = diffDrag / diffTime;
    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
    return isFlick ? force : 0;
  }
  const self = {
    pointerDown,
    pointerMove,
    pointerUp,
    readPoint
  };
  return self;
}
function NodeRects() {
  function measure(node) {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth,
      offsetHeight
    } = node;
    const offset6 = {
      top: offsetTop,
      right: offsetLeft + offsetWidth,
      bottom: offsetTop + offsetHeight,
      left: offsetLeft,
      width: offsetWidth,
      height: offsetHeight
    };
    return offset6;
  }
  const self = {
    measure
  };
  return self;
}
function PercentOfView(viewSize) {
  function measure(n3) {
    return viewSize * (n3 / 100);
  }
  const self = {
    measure
  };
  return self;
}
function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  const observeNodes = [container].concat(slides);
  let resizeObserver;
  let containerSize;
  let slideSizes = [];
  let destroyed = false;
  function readSize(node) {
    return axis.measureSize(nodeRects.measure(node));
  }
  function init(emblaApi) {
    if (!watchResize)
      return;
    containerSize = readSize(container);
    slideSizes = slides.map(readSize);
    function defaultCallback(entries) {
      for (const entry of entries) {
        if (destroyed)
          return;
        const isContainer = entry.target === container;
        const slideIndex = slides.indexOf(entry.target);
        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
        const newSize = readSize(isContainer ? container : slides[slideIndex]);
        const diffSize = mathAbs(newSize - lastSize);
        if (diffSize >= 0.5) {
          emblaApi.reInit();
          eventHandler.emit("resize");
          break;
        }
      }
    }
    resizeObserver = new ResizeObserver((entries) => {
      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {
        defaultCallback(entries);
      }
    });
    ownerWindow.requestAnimationFrame(() => {
      observeNodes.forEach((node) => resizeObserver.observe(node));
    });
  }
  function destroy() {
    destroyed = true;
    if (resizeObserver)
      resizeObserver.disconnect();
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
  let scrollVelocity = 0;
  let scrollDirection = 0;
  let scrollDuration = baseDuration;
  let scrollFriction = baseFriction;
  let rawLocation = location.get();
  let rawLocationPrevious = 0;
  function seek() {
    const displacement = target.get() - location.get();
    const isInstant = !scrollDuration;
    let scrollDistance = 0;
    if (isInstant) {
      scrollVelocity = 0;
      previousLocation.set(target);
      location.set(target);
      scrollDistance = displacement;
    } else {
      previousLocation.set(location);
      scrollVelocity += displacement / scrollDuration;
      scrollVelocity *= scrollFriction;
      rawLocation += scrollVelocity;
      location.add(scrollVelocity);
      scrollDistance = rawLocation - rawLocationPrevious;
    }
    scrollDirection = mathSign(scrollDistance);
    rawLocationPrevious = rawLocation;
    return self;
  }
  function settled() {
    const diff = target.get() - offsetLocation.get();
    return mathAbs(diff) < 1e-3;
  }
  function duration() {
    return scrollDuration;
  }
  function direction() {
    return scrollDirection;
  }
  function velocity() {
    return scrollVelocity;
  }
  function useBaseDuration() {
    return useDuration(baseDuration);
  }
  function useBaseFriction() {
    return useFriction(baseFriction);
  }
  function useDuration(n3) {
    scrollDuration = n3;
    return self;
  }
  function useFriction(n3) {
    scrollFriction = n3;
    return self;
  }
  const self = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration
  };
  return self;
}
function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
  const pullBackThreshold = percentOfView.measure(10);
  const edgeOffsetTolerance = percentOfView.measure(50);
  const frictionLimit = Limit(0.1, 0.99);
  let disabled = false;
  function shouldConstrain() {
    if (disabled)
      return false;
    if (!limit.reachedAny(target.get()))
      return false;
    if (!limit.reachedAny(location.get()))
      return false;
    return true;
  }
  function constrain(pointerDown) {
    if (!shouldConstrain())
      return;
    const edge = limit.reachedMin(location.get()) ? "min" : "max";
    const diffToEdge = mathAbs(limit[edge] - location.get());
    const diffToTarget = target.get() - location.get();
    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
    target.subtract(diffToTarget * friction);
    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
      target.set(limit.constrain(target.get()));
      scrollBody.useDuration(25).useBaseFriction();
    }
  }
  function toggleActive(active) {
    disabled = !active;
  }
  const self = {
    shouldConstrain,
    constrain,
    toggleActive
  };
  return self;
}
function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  const scrollBounds = Limit(-contentSize + viewSize, 0);
  const snapsBounded = measureBounded();
  const scrollContainLimit = findScrollContainLimit();
  const snapsContained = measureContained();
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) < 1;
  }
  function findScrollContainLimit() {
    const startSnap = snapsBounded[0];
    const endSnap = arrayLast(snapsBounded);
    const min3 = snapsBounded.lastIndexOf(startSnap);
    const max3 = snapsBounded.indexOf(endSnap) + 1;
    return Limit(min3, max3);
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index2) => {
      const {
        min: min3,
        max: max3
      } = scrollBounds;
      const snap = scrollBounds.constrain(snapAligned);
      const isFirst = !index2;
      const isLast = arrayIsLastIndex(snapsAligned, index2);
      if (isFirst)
        return max3;
      if (isLast)
        return min3;
      if (usePixelTolerance(min3, snap))
        return min3;
      if (usePixelTolerance(max3, snap))
        return max3;
      return snap;
    }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance)
      return [scrollBounds.max];
    if (containScroll === "keepSnaps")
      return snapsBounded;
    const {
      min: min3,
      max: max3
    } = scrollContainLimit;
    return snapsBounded.slice(min3, max3);
  }
  const self = {
    snapsContained,
    scrollContainLimit
  };
  return self;
}
function ScrollLimit(contentSize, scrollSnaps, loop) {
  const max3 = scrollSnaps[0];
  const min3 = loop ? max3 - contentSize : arrayLast(scrollSnaps);
  const limit = Limit(min3, max3);
  const self = {
    limit
  };
  return self;
}
function ScrollLooper(contentSize, limit, location, vectors) {
  const jointSafety = 0.1;
  const min3 = limit.min + jointSafety;
  const max3 = limit.max + jointSafety;
  const {
    reachedMin,
    reachedMax
  } = Limit(min3, max3);
  function shouldLoop(direction) {
    if (direction === 1)
      return reachedMax(location.get());
    if (direction === -1)
      return reachedMin(location.get());
    return false;
  }
  function loop(direction) {
    if (!shouldLoop(direction))
      return;
    const loopDistance = contentSize * (direction * -1);
    vectors.forEach((v2) => v2.add(loopDistance));
  }
  const self = {
    loop
  };
  return self;
}
function ScrollProgress(limit) {
  const {
    max: max3,
    length
  } = limit;
  function get2(n3) {
    const currentLocation = n3 - max3;
    return length ? currentLocation / -length : 0;
  }
  const self = {
    get: get2
  };
  return self;
}
function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  const {
    startEdge,
    endEdge
  } = axis;
  const {
    groupSlides
  } = slidesToScroll;
  const alignments = measureSizes().map(alignment.measure);
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  function measureSizes() {
    return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
  }
  function measureUnaligned() {
    return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));
  }
  function measureAligned() {
    return groupSlides(snaps).map((g) => g[0]).map((snap, index2) => snap + alignments[index2]);
  }
  const self = {
    snaps,
    snapsAligned
  };
  return self;
}
function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  const {
    groupSlides
  } = slidesToScroll;
  const {
    min: min3,
    max: max3
  } = scrollContainLimit;
  const slideRegistry = createSlideRegistry();
  function createSlideRegistry() {
    const groupedSlideIndexes = groupSlides(slideIndexes);
    const doNotContain = !containSnaps || containScroll === "keepSnaps";
    if (scrollSnaps.length === 1)
      return [slideIndexes];
    if (doNotContain)
      return groupedSlideIndexes;
    return groupedSlideIndexes.slice(min3, max3).map((group, index2, groups) => {
      const isFirst = !index2;
      const isLast = arrayIsLastIndex(groups, index2);
      if (isFirst) {
        const range = arrayLast(groups[0]) + 1;
        return arrayFromNumber(range);
      }
      if (isLast) {
        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
        return arrayFromNumber(range, arrayLast(groups)[0]);
      }
      return group;
    });
  }
  const self = {
    slideRegistry
  };
  return self;
}
function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
  const {
    reachedAny,
    removeOffset,
    constrain
  } = limit;
  function minDistance(distances) {
    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
  }
  function findTargetSnap(target) {
    const distance2 = loop ? removeOffset(target) : constrain(target);
    const ascDiffsToSnaps = scrollSnaps.map((snap, index3) => ({
      diff: shortcut(snap - distance2, 0),
      index: index3
    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
    const {
      index: index2
    } = ascDiffsToSnaps[0];
    return {
      index: index2,
      distance: distance2
    };
  }
  function shortcut(target, direction) {
    const targets = [target, target + contentSize, target - contentSize];
    if (!loop)
      return target;
    if (!direction)
      return minDistance(targets);
    const matchingTargets = targets.filter((t2) => mathSign(t2) === direction);
    if (matchingTargets.length)
      return minDistance(matchingTargets);
    return arrayLast(targets) - contentSize;
  }
  function byIndex(index2, direction) {
    const diffToSnap = scrollSnaps[index2] - targetVector.get();
    const distance2 = shortcut(diffToSnap, direction);
    return {
      index: index2,
      distance: distance2
    };
  }
  function byDistance(distance2, snap) {
    const target = targetVector.get() + distance2;
    const {
      index: index2,
      distance: targetSnapDistance
    } = findTargetSnap(target);
    const reachedBound = !loop && reachedAny(target);
    if (!snap || reachedBound)
      return {
        index: index2,
        distance: distance2
      };
    const diffToSnap = scrollSnaps[index2] - targetSnapDistance;
    const snapDistance = distance2 + shortcut(diffToSnap, 0);
    return {
      index: index2,
      distance: snapDistance
    };
  }
  const self = {
    byDistance,
    byIndex,
    shortcut
  };
  return self;
}
function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target) {
    const distanceDiff = target.distance;
    const indexDiff = target.index !== indexCurrent.get();
    targetVector.add(distanceDiff);
    if (distanceDiff) {
      if (scrollBody.duration()) {
        animation.start();
      } else {
        animation.update();
        animation.render(1);
        animation.update();
      }
    }
    if (indexDiff) {
      indexPrevious.set(indexCurrent.get());
      indexCurrent.set(target.index);
      eventHandler.emit("select");
    }
  }
  function distance2(n3, snap) {
    const target = scrollTarget.byDistance(n3, snap);
    scrollTo(target);
  }
  function index2(n3, direction) {
    const targetIndex = indexCurrent.clone().set(n3);
    const target = scrollTarget.byIndex(targetIndex.get(), direction);
    scrollTo(target);
  }
  const self = {
    distance: distance2,
    index: index2
  };
  return self;
}
function SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  const focusListenerOptions = {
    passive: true,
    capture: true
  };
  let lastTabPressTime = 0;
  function init(emblaApi) {
    if (!watchFocus)
      return;
    function defaultCallback(index2) {
      const nowTime = (/* @__PURE__ */ new Date()).getTime();
      const diffTime = nowTime - lastTabPressTime;
      if (diffTime > 10)
        return;
      eventHandler.emit("slideFocusStart");
      root.scrollLeft = 0;
      const group = slideRegistry.findIndex((group2) => group2.includes(index2));
      if (!isNumber(group))
        return;
      scrollBody.useDuration(0);
      scrollTo.index(group, 0);
      eventHandler.emit("slideFocus");
    }
    eventStore.add(document, "keydown", registerTabPress, false);
    slides.forEach((slide, slideIndex) => {
      eventStore.add(slide, "focus", (evt) => {
        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {
          defaultCallback(slideIndex);
        }
      }, focusListenerOptions);
    });
  }
  function registerTabPress(event) {
    if (event.code === "Tab")
      lastTabPressTime = (/* @__PURE__ */ new Date()).getTime();
  }
  const self = {
    init
  };
  return self;
}
function Vector1D(initialValue) {
  let value = initialValue;
  function get2() {
    return value;
  }
  function set3(n3) {
    value = normalizeInput(n3);
  }
  function add2(n3) {
    value += normalizeInput(n3);
  }
  function subtract2(n3) {
    value -= normalizeInput(n3);
  }
  function normalizeInput(n3) {
    return isNumber(n3) ? n3 : n3.get();
  }
  const self = {
    get: get2,
    set: set3,
    add: add2,
    subtract: subtract2
  };
  return self;
}
function Translate(axis, container) {
  const translate = axis.scroll === "x" ? x2 : y;
  const containerStyle = container.style;
  let previousTarget = null;
  let disabled = false;
  function x2(n3) {
    return `translate3d(${n3}px,0px,0px)`;
  }
  function y(n3) {
    return `translate3d(0px,${n3}px,0px)`;
  }
  function to(target) {
    if (disabled)
      return;
    const newTarget = roundToTwoDecimals(axis.direction(target));
    if (newTarget === previousTarget)
      return;
    containerStyle.transform = translate(newTarget);
    previousTarget = newTarget;
  }
  function toggleActive(active) {
    disabled = !active;
  }
  function clear() {
    if (disabled)
      return;
    containerStyle.transform = "";
    if (!container.getAttribute("style"))
      container.removeAttribute("style");
  }
  const self = {
    clear,
    to,
    toggleActive
  };
  return self;
}
function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {
  const roundingSafety = 0.5;
  const ascItems = arrayKeys(slideSizesWithGaps);
  const descItems = arrayKeys(slideSizesWithGaps).reverse();
  const loopPoints = startPoints().concat(endPoints());
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a, i) => {
      return a - slideSizesWithGaps[i];
    }, from);
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a, i) => {
      const remainingGap = removeSlideSizes(a, gap);
      return remainingGap > 0 ? a.concat([i]) : a;
    }, []);
  }
  function findSlideBounds(offset6) {
    return snaps.map((snap, index2) => ({
      start: snap - slideSizes[index2] + roundingSafety + offset6,
      end: snap + viewSize - roundingSafety + offset6
    }));
  }
  function findLoopPoints(indexes, offset6, isEndEdge) {
    const slideBounds = findSlideBounds(offset6);
    return indexes.map((index2) => {
      const initial = isEndEdge ? 0 : -contentSize;
      const altered = isEndEdge ? contentSize : 0;
      const boundEdge = isEndEdge ? "end" : "start";
      const loopPoint = slideBounds[index2][boundEdge];
      return {
        index: index2,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index2]),
        target: () => location.get() > loopPoint ? initial : altered
      };
    });
  }
  function startPoints() {
    const gap = scrollSnaps[0];
    const indexes = slidesInGap(descItems, gap);
    return findLoopPoints(indexes, contentSize, false);
  }
  function endPoints() {
    const gap = viewSize - scrollSnaps[0] - 1;
    const indexes = slidesInGap(ascItems, gap);
    return findLoopPoints(indexes, -contentSize, true);
  }
  function canLoop() {
    return loopPoints.every(({
      index: index2
    }) => {
      const otherIndexes = ascItems.filter((i) => i !== index2);
      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
    });
  }
  function loop() {
    loopPoints.forEach((loopPoint) => {
      const {
        target,
        translate,
        slideLocation
      } = loopPoint;
      const shiftLocation = target();
      if (shiftLocation === slideLocation.get())
        return;
      translate.to(shiftLocation);
      slideLocation.set(shiftLocation);
    });
  }
  function clear() {
    loopPoints.forEach((loopPoint) => loopPoint.translate.clear());
  }
  const self = {
    canLoop,
    clear,
    loop,
    loopPoints
  };
  return self;
}
function SlidesHandler(container, eventHandler, watchSlides) {
  let mutationObserver;
  let destroyed = false;
  function init(emblaApi) {
    if (!watchSlides)
      return;
    function defaultCallback(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          emblaApi.reInit();
          eventHandler.emit("slidesChanged");
          break;
        }
      }
    }
    mutationObserver = new MutationObserver((mutations) => {
      if (destroyed)
        return;
      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {
        defaultCallback(mutations);
      }
    });
    mutationObserver.observe(container, {
      childList: true
    });
  }
  function destroy() {
    if (mutationObserver)
      mutationObserver.disconnect();
    destroyed = true;
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function SlidesInView(container, slides, eventHandler, threshold) {
  const intersectionEntryMap = {};
  let inViewCache = null;
  let notInViewCache = null;
  let intersectionObserver;
  let destroyed = false;
  function init() {
    intersectionObserver = new IntersectionObserver((entries) => {
      if (destroyed)
        return;
      entries.forEach((entry) => {
        const index2 = slides.indexOf(entry.target);
        intersectionEntryMap[index2] = entry;
      });
      inViewCache = null;
      notInViewCache = null;
      eventHandler.emit("slidesInView");
    }, {
      root: container.parentElement,
      threshold
    });
    slides.forEach((slide) => intersectionObserver.observe(slide));
  }
  function destroy() {
    if (intersectionObserver)
      intersectionObserver.disconnect();
    destroyed = true;
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
      const index2 = parseInt(slideIndex);
      const {
        isIntersecting
      } = intersectionEntryMap[index2];
      const inViewMatch = inView && isIntersecting;
      const notInViewMatch = !inView && !isIntersecting;
      if (inViewMatch || notInViewMatch)
        list.push(index2);
      return list;
    }, []);
  }
  function get2(inView = true) {
    if (inView && inViewCache)
      return inViewCache;
    if (!inView && notInViewCache)
      return notInViewCache;
    const slideIndexes = createInViewList(inView);
    if (inView)
      inViewCache = slideIndexes;
    if (!inView)
      notInViewCache = slideIndexes;
    return slideIndexes;
  }
  const self = {
    init,
    destroy,
    get: get2
  };
  return self;
}
function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  const {
    measureSize,
    startEdge,
    endEdge
  } = axis;
  const withEdgeGap = slideRects[0] && readEdgeGap;
  const startGap = measureStartGap();
  const endGap = measureEndGap();
  const slideSizes = slideRects.map(measureSize);
  const slideSizesWithGaps = measureWithGaps();
  function measureStartGap() {
    if (!withEdgeGap)
      return 0;
    const slideRect = slideRects[0];
    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
  }
  function measureEndGap() {
    if (!withEdgeGap)
      return 0;
    const style2 = ownerWindow.getComputedStyle(arrayLast(slides));
    return parseFloat(style2.getPropertyValue(`margin-${endEdge}`));
  }
  function measureWithGaps() {
    return slideRects.map((rect, index2, rects) => {
      const isFirst = !index2;
      const isLast = arrayIsLastIndex(rects, index2);
      if (isFirst)
        return slideSizes[index2] + startGap;
      if (isLast)
        return slideSizes[index2] + endGap;
      return rects[index2 + 1][startEdge] - rect[startEdge];
    }).map(mathAbs);
  }
  const self = {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  };
  return self;
}
function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
  const {
    startEdge,
    endEdge,
    direction
  } = axis;
  const groupByNumber = isNumber(slidesToScroll);
  function byNumber(array, groupSize) {
    return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));
  }
  function bySize(array) {
    if (!array.length)
      return [];
    return arrayKeys(array).reduce((groups, rectB, index2) => {
      const rectA = arrayLast(groups) || 0;
      const isFirst = rectA === 0;
      const isLast = rectB === arrayLastIndex(array);
      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
      const gapA = !loop && isFirst ? direction(startGap) : 0;
      const gapB = !loop && isLast ? direction(endGap) : 0;
      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
      if (index2 && chunkSize > viewSize + pixelTolerance)
        groups.push(rectB);
      if (isLast)
        groups.push(array.length);
      return groups;
    }, []).map((currentSize, index2, groups) => {
      const previousSize = Math.max(groups[index2 - 1] || 0);
      return array.slice(previousSize, currentSize);
    });
  }
  function groupSlides(array) {
    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
  }
  const self = {
    groupSlides
  };
  return self;
}
function Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {
  const {
    align,
    axis: scrollAxis,
    direction,
    startIndex,
    loop,
    duration,
    dragFree,
    dragThreshold,
    inViewThreshold,
    slidesToScroll: groupSlides,
    skipSnaps,
    containScroll,
    watchResize,
    watchSlides,
    watchDrag,
    watchFocus
  } = options;
  const pixelTolerance = 2;
  const nodeRects = NodeRects();
  const containerRect = nodeRects.measure(container);
  const slideRects = slides.map(nodeRects.measure);
  const axis = Axis(scrollAxis, direction);
  const viewSize = axis.measureSize(containerRect);
  const percentOfView = PercentOfView(viewSize);
  const alignment = Alignment(align, viewSize);
  const containSnaps = !loop && !!containScroll;
  const readEdgeGap = loop || !!containScroll;
  const {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
  const {
    snaps,
    snapsAligned
  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const {
    snapsContained,
    scrollContainLimit
  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
  const {
    limit
  } = ScrollLimit(contentSize, scrollSnaps, loop);
  const index2 = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
  const indexPrevious = index2.clone();
  const slideIndexes = arrayKeys(slides);
  const update2 = ({
    dragHandler,
    scrollBody: scrollBody2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }) => {
    if (!loop2)
      scrollBounds.constrain(dragHandler.pointerDown());
    scrollBody2.seek();
  };
  const render = ({
    scrollBody: scrollBody2,
    translate,
    location: location2,
    offsetLocation: offsetLocation2,
    previousLocation: previousLocation2,
    scrollLooper,
    slideLooper,
    dragHandler,
    animation: animation2,
    eventHandler: eventHandler2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }, alpha) => {
    const shouldSettle = scrollBody2.settled();
    const withinBounds = !scrollBounds.shouldConstrain();
    const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;
    if (hasSettled && !dragHandler.pointerDown()) {
      animation2.stop();
      eventHandler2.emit("settle");
    }
    if (!hasSettled)
      eventHandler2.emit("scroll");
    const interpolatedLocation = location2.get() * alpha + previousLocation2.get() * (1 - alpha);
    offsetLocation2.set(interpolatedLocation);
    if (loop2) {
      scrollLooper.loop(scrollBody2.direction());
      slideLooper.loop();
    }
    translate.to(offsetLocation2.get());
  };
  const animation = Animations(ownerDocument, ownerWindow, () => update2(engine), (alpha) => render(engine, alpha));
  const friction = 0.68;
  const startLocation = scrollSnaps[index2.get()];
  const location = Vector1D(startLocation);
  const previousLocation = Vector1D(startLocation);
  const offsetLocation = Vector1D(startLocation);
  const target = Vector1D(startLocation);
  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);
  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
  const scrollTo = ScrollTo(animation, index2, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
  const scrollProgress = ScrollProgress(limit);
  const eventStore = EventStore();
  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
  const {
    slideRegistry
  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
  const engine = {
    ownerDocument,
    ownerWindow,
    eventHandler,
    containerRect,
    slideRects,
    animation,
    axis,
    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index2, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
    eventStore,
    percentOfView,
    index: index2,
    indexPrevious,
    limit,
    location,
    offsetLocation,
    previousLocation,
    options,
    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
    scrollBody,
    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),
    scrollProgress,
    scrollSnapList: scrollSnaps.map(scrollProgress.get),
    scrollSnaps,
    scrollTarget,
    scrollTo,
    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
    slideFocus,
    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
    slidesInView,
    slideIndexes,
    slideRegistry,
    slidesToScroll,
    target,
    translate: Translate(axis, container)
  };
  return engine;
}
function EventHandler() {
  let listeners3 = {};
  let api;
  function init(emblaApi) {
    api = emblaApi;
  }
  function getListeners(evt) {
    return listeners3[evt] || [];
  }
  function emit(evt) {
    getListeners(evt).forEach((e) => e(api, evt));
    return self;
  }
  function on(evt, cb) {
    listeners3[evt] = getListeners(evt).concat([cb]);
    return self;
  }
  function off(evt, cb) {
    listeners3[evt] = getListeners(evt).filter((e) => e !== cb);
    return self;
  }
  function clear() {
    listeners3 = {};
  }
  const self = {
    init,
    emit,
    off,
    on,
    clear
  };
  return self;
}
var defaultOptions2 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: false,
  dragThreshold: 10,
  loop: false,
  skipSnaps: false,
  duration: 25,
  startIndex: 0,
  active: true,
  watchDrag: true,
  watchResize: true,
  watchSlides: true,
  watchFocus: true
};
function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {});
  }
  function optionsAtMedia(options) {
    const optionsAtMedia2 = options.breakpoints || {};
    const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
    return mergeOptions(options, matchedMediaOptions);
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
  }
  const self = {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  };
  return self;
}
function PluginsHandler(optionsHandler) {
  let activePlugins = [];
  function init(emblaApi, plugins) {
    activePlugins = plugins.filter(({
      options
    }) => optionsHandler.optionsAtMedia(options).active !== false);
    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));
    return plugins.reduce((map, plugin) => Object.assign(map, {
      [plugin.name]: plugin
    }), {});
  }
  function destroy() {
    activePlugins = activePlugins.filter((plugin) => plugin.destroy());
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function EmblaCarousel(root, userOptions, userPlugins) {
  const ownerDocument = root.ownerDocument;
  const ownerWindow = ownerDocument.defaultView;
  const optionsHandler = OptionsHandler(ownerWindow);
  const pluginsHandler = PluginsHandler(optionsHandler);
  const mediaHandlers = EventStore();
  const eventHandler = EventHandler();
  const {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  } = optionsHandler;
  const {
    on,
    off,
    emit
  } = eventHandler;
  const reInit = reActivate;
  let destroyed = false;
  let engine;
  let optionsBase = mergeOptions(defaultOptions2, EmblaCarousel.globalOptions);
  let options = mergeOptions(optionsBase);
  let pluginList = [];
  let pluginApis;
  let container;
  let slides;
  function storeElements() {
    const {
      container: userContainer,
      slides: userSlides
    } = options;
    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;
    container = customContainer || root.children[0];
    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
    slides = [].slice.call(customSlides || container.children);
  }
  function createEngine(options2) {
    const engine2 = Engine(root, container, slides, ownerDocument, ownerWindow, options2, eventHandler);
    if (options2.loop && !engine2.slideLooper.canLoop()) {
      const optionsWithoutLoop = Object.assign({}, options2, {
        loop: false
      });
      return createEngine(optionsWithoutLoop);
    }
    return engine2;
  }
  function activate(withOptions, withPlugins) {
    if (destroyed)
      return;
    optionsBase = mergeOptions(optionsBase, withOptions);
    options = optionsAtMedia(optionsBase);
    pluginList = withPlugins || pluginList;
    storeElements();
    engine = createEngine(options);
    optionsMediaQueries([optionsBase, ...pluginList.map(({
      options: options2
    }) => options2)]).forEach((query) => mediaHandlers.add(query, "change", reActivate));
    if (!options.active)
      return;
    engine.translate.to(engine.location.get());
    engine.animation.init();
    engine.slidesInView.init();
    engine.slideFocus.init(self);
    engine.eventHandler.init(self);
    engine.resizeHandler.init(self);
    engine.slidesHandler.init(self);
    if (engine.options.loop)
      engine.slideLooper.loop();
    if (container.offsetParent && slides.length)
      engine.dragHandler.init(self);
    pluginApis = pluginsHandler.init(self, pluginList);
  }
  function reActivate(withOptions, withPlugins) {
    const startIndex = selectedScrollSnap();
    deActivate();
    activate(mergeOptions({
      startIndex
    }, withOptions), withPlugins);
    eventHandler.emit("reInit");
  }
  function deActivate() {
    engine.dragHandler.destroy();
    engine.eventStore.clear();
    engine.translate.clear();
    engine.slideLooper.clear();
    engine.resizeHandler.destroy();
    engine.slidesHandler.destroy();
    engine.slidesInView.destroy();
    engine.animation.destroy();
    pluginsHandler.destroy();
    mediaHandlers.clear();
  }
  function destroy() {
    if (destroyed)
      return;
    destroyed = true;
    mediaHandlers.clear();
    deActivate();
    eventHandler.emit("destroy");
    eventHandler.clear();
  }
  function scrollTo(index2, jump, direction) {
    if (!options.active || destroyed)
      return;
    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
    engine.scrollTo.index(index2, direction || 0);
  }
  function scrollNext(jump) {
    const next = engine.index.add(1).get();
    scrollTo(next, jump, -1);
  }
  function scrollPrev(jump) {
    const prev = engine.index.add(-1).get();
    scrollTo(prev, jump, 1);
  }
  function canScrollNext() {
    const next = engine.index.add(1).get();
    return next !== selectedScrollSnap();
  }
  function canScrollPrev() {
    const prev = engine.index.add(-1).get();
    return prev !== selectedScrollSnap();
  }
  function scrollSnapList() {
    return engine.scrollSnapList;
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.location.get());
  }
  function selectedScrollSnap() {
    return engine.index.get();
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get();
  }
  function slidesInView() {
    return engine.slidesInView.get();
  }
  function slidesNotInView() {
    return engine.slidesInView.get(false);
  }
  function plugins() {
    return pluginApis;
  }
  function internalEngine() {
    return engine;
  }
  function rootNode() {
    return root;
  }
  function containerNode() {
    return container;
  }
  function slideNodes() {
    return slides;
  }
  const self = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off,
    on,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView
  };
  activate(userOptions, userPlugins);
  setTimeout(() => eventHandler.emit("init"), 0);
  return self;
}
EmblaCarousel.globalOptions = void 0;

// ../../node_modules/.pnpm/embla-carousel-react@8.5.1_react@19.1.0/node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js
function useEmblaCarousel(options = {}, plugins = []) {
  const storedOptions = (0, import_react39.useRef)(options);
  const storedPlugins = (0, import_react39.useRef)(plugins);
  const [emblaApi, setEmblaApi] = (0, import_react39.useState)();
  const [viewport, setViewport] = (0, import_react39.useState)();
  const reInit = (0, import_react39.useCallback)(() => {
    if (emblaApi)
      emblaApi.reInit(storedOptions.current, storedPlugins.current);
  }, [emblaApi]);
  (0, import_react39.useEffect)(() => {
    if (areOptionsEqual(storedOptions.current, options))
      return;
    storedOptions.current = options;
    reInit();
  }, [options, reInit]);
  (0, import_react39.useEffect)(() => {
    if (arePluginsEqual(storedPlugins.current, plugins))
      return;
    storedPlugins.current = plugins;
    reInit();
  }, [plugins, reInit]);
  (0, import_react39.useEffect)(() => {
    if (canUseDOM() && viewport) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      const newEmblaApi = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
      setEmblaApi(newEmblaApi);
      return () => newEmblaApi.destroy();
    } else {
      setEmblaApi(void 0);
    }
  }, [viewport, setEmblaApi]);
  return [setViewport, emblaApi];
}
useEmblaCarousel.globalOptions = void 0;

// src/components/carousel.tsx
var import_utils19 = require("@nubras/utils");
var import_jsx_runtime32 = require("react/jsx-runtime");
var CarouselContext = React80.createContext(null);
function useCarousel() {
  const context = React80.useContext(CarouselContext);
  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }
  return context;
}
var Carousel = React80.forwardRef(
  (_a, ref2) => {
    var _b = _a, {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children
    } = _b, props2 = __objRest(_b, [
      "orientation",
      "opts",
      "setApi",
      "plugins",
      "className",
      "children"
    ]);
    const [carouselRef, api] = useEmblaCarousel(
      __spreadProps(__spreadValues({}, opts), {
        axis: orientation === "horizontal" ? "x" : "y"
      }),
      plugins
    );
    const [canScrollPrev, setCanScrollPrev] = React80.useState(false);
    const [canScrollNext, setCanScrollNext] = React80.useState(false);
    const onSelect = React80.useCallback((api2) => {
      if (!api2) {
        return;
      }
      setCanScrollPrev(api2.canScrollPrev());
      setCanScrollNext(api2.canScrollNext());
    }, []);
    const scrollPrev = React80.useCallback(() => {
      api == null ? void 0 : api.scrollPrev();
    }, [api]);
    const scrollNext = React80.useCallback(() => {
      api == null ? void 0 : api.scrollNext();
    }, [api]);
    const handleKeyDown = React80.useCallback(
      (event) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext]
    );
    React80.useEffect(() => {
      if (!api || !setApi) {
        return;
      }
      setApi(api);
    }, [api, setApi]);
    React80.useEffect(() => {
      if (!api) {
        return;
      }
      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);
      return () => {
        api == null ? void 0 : api.off("select", onSelect);
      };
    }, [api, onSelect]);
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
      CarouselContext.Provider,
      {
        value: {
          carouselRef,
          api,
          opts,
          orientation: orientation || ((opts == null ? void 0 : opts.axis) === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
          "div",
          __spreadProps(__spreadValues({
            ref: ref2,
            onKeyDownCapture: handleKeyDown,
            className: (0, import_utils19.cn)("relative", className),
            role: "region",
            "aria-roledescription": "carousel"
          }, props2), {
            children
          })
        )
      }
    );
  }
);
Carousel.displayName = "Carousel";
var CarouselContent = React80.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  const { carouselRef, orientation } = useCarousel();
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("div", { ref: carouselRef, className: "overflow-hidden", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils19.cn)(
        "flex",
        orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
        className
      )
    }, props2)
  ) });
});
CarouselContent.displayName = "CarouselContent";
var CarouselItem = React80.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  const { orientation } = useCarousel();
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      role: "group",
      "aria-roledescription": "slide",
      className: (0, import_utils19.cn)(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )
    }, props2)
  );
});
CarouselItem.displayName = "CarouselItem";
var CarouselPrevious = React80.forwardRef((_a, ref2) => {
  var _b = _a, { className, variant = "outline", size: size4 = "icon" } = _b, props2 = __objRest(_b, ["className", "variant", "size"]);
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(
    Button,
    __spreadProps(__spreadValues({
      ref: ref2,
      variant,
      size: size4,
      className: (0, import_utils19.cn)(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal" ? "-left-12 top-1/2 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      ),
      disabled: !canScrollPrev,
      onClick: scrollPrev
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ArrowLeft, { className: "h-4 w-4" }),
        /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("span", { className: "sr-only", children: "Previous slide" })
      ]
    })
  );
});
CarouselPrevious.displayName = "CarouselPrevious";
var CarouselNext = React80.forwardRef((_a, ref2) => {
  var _b = _a, { className, variant = "outline", size: size4 = "icon" } = _b, props2 = __objRest(_b, ["className", "variant", "size"]);
  const { orientation, scrollNext, canScrollNext } = useCarousel();
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(
    Button,
    __spreadProps(__spreadValues({
      ref: ref2,
      variant,
      size: size4,
      className: (0, import_utils19.cn)(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal" ? "-right-12 top-1/2 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      ),
      disabled: !canScrollNext,
      onClick: scrollNext
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ArrowRight, { className: "h-4 w-4" }),
        /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("span", { className: "sr-only", children: "Next slide" })
      ]
    })
  );
});
CarouselNext.displayName = "CarouselNext";

// src/components/chart.tsx
var React81 = __toESM(require("react"));
var import_jsx_runtime33 = require("react/jsx-runtime");
function ChartContainer(_a) {
  var _b = _a, { config = {}, className, children } = _b, props2 = __objRest(_b, ["config", "className", "children"]);
  const style2 = React81.useMemo(() => {
    if (!config || Object.keys(config).length === 0) {
      return {
        "--color-chart-1": "hsl(var(--primary))",
        "--color-chart-2": "hsl(var(--muted-foreground))",
        "--color-chart-3": "hsl(var(--accent))"
      };
    }
    return Object.entries(config).reduce(
      (acc, [key, value]) => {
        acc[`--color-${key}`] = value.color;
        return acc;
      },
      {
        "--color-chart-1": "hsl(var(--primary))",
        "--color-chart-2": "hsl(var(--muted-foreground))",
        "--color-chart-3": "hsl(var(--accent))"
      }
    );
  }, [config]);
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", __spreadProps(__spreadValues({ className, style: style2 }, props2), { children }));
}
function ChartTooltip(_a) {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", __spreadValues({ className }, props2));
}
function ChartTooltipContent(_a) {
  var _b = _a, { payload, label, active } = _b, props2 = __objRest(_b, ["payload", "label", "active"]);
  if (!active || !payload || payload.length === 0) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", __spreadProps(__spreadValues({ className: "rounded-lg border bg-background p-2 shadow-sm" }, props2), { children: /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("div", { className: "grid grid-cols-2 gap-2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", { className: "font-medium", children: label }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", { className: "font-medium", children: "Value" }),
    payload.map((entry) => {
      var _a2;
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(React81.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("div", { className: "flex items-center gap-1", children: [
          /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
            "div",
            {
              className: "h-2 w-2 rounded-full",
              style: {
                backgroundColor: ((_a2 = entry.payload) == null ? void 0 : _a2.color) || "hsl(var(--primary))"
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("span", { children: entry.name })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", { children: entry.value })
      ] }, entry.name);
    })
  ] }) }));
}
function ChartLegend(_a) {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", __spreadValues({ className }, props2));
}
function ChartLegendContent(_a) {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", __spreadValues({ className }, props2));
}
function ChartStyle(_a) {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("style", __spreadValues({}, props2));
}
function Chart(_a) {
  var _b = _a, { type, data, options, className } = _b, props2 = __objRest(_b, ["type", "data", "options", "className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", __spreadValues({ className }, props2));
}

// src/components/checkbox.tsx
var React83 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-checkbox@1.1.3_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1_2w6ekemk2xjjw5ddjcn6xmrdbi/node_modules/@radix-ui/react-checkbox/dist/index.mjs
var React82 = __toESM(require("react"), 1);
var import_jsx_runtime34 = require("react/jsx-runtime");
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox = React82.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeCheckbox,
      name,
      checked: checkedProp,
      defaultChecked,
      required: required2,
      disabled,
      value = "on",
      onCheckedChange,
      form
    } = _a, checkboxProps = __objRest(_a, [
      "__scopeCheckbox",
      "name",
      "checked",
      "defaultChecked",
      "required",
      "disabled",
      "value",
      "onCheckedChange",
      "form"
    ]);
    const [button, setButton] = React82.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React82.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    const initialCheckedStateRef = React82.useRef(checked);
    React82.useEffect(() => {
      const form2 = button == null ? void 0 : button.form;
      if (form2) {
        const reset2 = () => setChecked(initialCheckedStateRef.current);
        form2.addEventListener("reset", reset2);
        return () => form2.removeEventListener("reset", reset2);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
        Primitive.button,
        __spreadProps(__spreadValues({
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
          "aria-required": required2,
          "data-state": getState4(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value
        }, checkboxProps), {
          ref: composedRefs,
          onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
            if (event.key === "Enter")
              event.preventDefault();
          }),
          onClick: composeEventHandlers(props2.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        })
      ),
      isFormControl && /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
        BubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required: required2,
          disabled,
          form,
          style: { transform: "translateX(-100%)" },
          defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked
        }
      )
    ] });
  }
);
Checkbox.displayName = CHECKBOX_NAME;
var INDICATOR_NAME = "CheckboxIndicator";
var CheckboxIndicator = React82.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeCheckbox, forceMount } = _a, indicatorProps = __objRest(_a, ["__scopeCheckbox", "forceMount"]);
    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Presence, { present: forceMount || isIndeterminate(context.state) || context.state === true, children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      Primitive.span,
      __spreadProps(__spreadValues({
        "data-state": getState4(context.state),
        "data-disabled": context.disabled ? "" : void 0
      }, indicatorProps), {
        ref: forwardedRef,
        style: __spreadValues({ pointerEvents: "none" }, props2.style)
      })
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME;
var BubbleInput = (props2) => {
  const _a = props2, { control, checked, bubbles = true, defaultChecked } = _a, inputProps = __objRest(_a, ["control", "checked", "bubbles", "defaultChecked"]);
  const ref2 = React82.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React82.useEffect(() => {
    const input = ref2.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input.indeterminate = isIndeterminate(checked);
      setChecked.call(input, isIndeterminate(checked) ? false : checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  const defaultCheckedRef = React82.useRef(isIndeterminate(checked) ? false : checked);
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
    "input",
    __spreadProps(__spreadValues({
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: defaultChecked != null ? defaultChecked : defaultCheckedRef.current
    }, inputProps), {
      tabIndex: -1,
      ref: ref2,
      style: __spreadProps(__spreadValues(__spreadValues({}, props2.style), controlSize), {
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      })
    })
  );
};
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState4(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root10 = Checkbox;
var Indicator = CheckboxIndicator;

// src/components/checkbox.tsx
var import_utils20 = require("@nubras/utils");
var import_jsx_runtime35 = require("react/jsx-runtime");
var Checkbox2 = React83.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
    Root10,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils20.cn)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        className
      )
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
        Indicator,
        {
          className: (0, import_utils20.cn)("flex items-center justify-center text-current"),
          children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(Check, { className: "h-4 w-4" })
        }
      )
    })
  );
});
Checkbox2.displayName = Root10.displayName;

// src/components/collapsible.tsx
var Collapsible2 = Root;
var CollapsibleTrigger2 = CollapsibleTrigger;
var CollapsibleContent2 = CollapsibleContent;

// src/components/command.tsx
var React94 = __toESM(require("react"));

// ../../node_modules/.pnpm/cmdk@1.0.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/cmdk/dist/chunk-NZJY6EH4.mjs
var U = 1;
var Y = 0.9;
var H = 0.8;
var J = 0.17;
var p = 0.1;
var u = 0.999;
var $ = 0.9999;
var k = 0.99;
var m = /[\\\/_+.#"@\[\(\{&]/;
var B = /[\\\/_+.#"@\[\(\{&]/g;
var K = /[\s-]/;
var X2 = /[\s-]/g;
function G(_2, C, h, P, A, f, O) {
  if (f === C.length)
    return A === _2.length ? U : k;
  var T2 = `${A},${f}`;
  if (O[T2] !== void 0)
    return O[T2];
  for (var L = P.charAt(f), c = h.indexOf(L, A), S2 = 0, E2, N2, R, M4; c >= 0; )
    E2 = G(_2, C, h, P, c + 1, f + 1, O), E2 > S2 && (c === A ? E2 *= U : m.test(_2.charAt(c - 1)) ? (E2 *= H, R = _2.slice(A, c - 1).match(B), R && A > 0 && (E2 *= Math.pow(u, R.length))) : K.test(_2.charAt(c - 1)) ? (E2 *= Y, M4 = _2.slice(A, c - 1).match(X2), M4 && A > 0 && (E2 *= Math.pow(u, M4.length))) : (E2 *= J, A > 0 && (E2 *= Math.pow(u, c - A))), _2.charAt(c) !== C.charAt(f) && (E2 *= $)), (E2 < p && h.charAt(c - 1) === P.charAt(f + 1) || P.charAt(f + 1) === P.charAt(f) && h.charAt(c - 1) !== P.charAt(f)) && (N2 = G(_2, C, h, P, c + 1, f + 2, O), N2 * p > E2 && (E2 = N2 * p)), E2 > S2 && (S2 = E2), c = h.indexOf(L, c + 1);
  return O[T2] = S2, S2;
}
function D(_2) {
  return _2.toLowerCase().replace(X2, " ");
}
function W(_2, C, h) {
  return _2 = h && h.length > 0 ? `${_2 + " " + h.join(" ")}` : _2, G(_2, C, D(_2), D(C), 0, 0, {});
}

// ../../node_modules/.pnpm/@radix-ui+react-dialog@1.1.13_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1._v6gw3ahcqwldiu3xdlfwsdrrsu/node_modules/@radix-ui/react-dialog/dist/index.mjs
var React92 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+primitive@1.1.2/node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers2(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// ../../node_modules/.pnpm/@radix-ui+react-id@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-id/dist/index.mjs
var React84 = __toESM(require("react"), 1);
var useReactId2 = React84[" useId ".trim().toString()] || (() => void 0);
var count3 = 0;
function useId2(deterministicId) {
  const [id, setId] = React84.useState(useReactId2());
  useLayoutEffect22(() => {
    if (!deterministicId)
      setId((reactId) => reactId != null ? reactId : String(count3++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.2.2_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React85 = __toESM(require("react"), 1);
var React210 = __toESM(require("react"), 1);
var useInsertionEffect = React85[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState2({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState2({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React85.useRef(prop !== void 0);
    React85.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React85.useCallback(
    (nextValue) => {
      var _a;
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState2({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React85.useState(defaultProp);
  const prevValueRef = React85.useRef(value);
  const onChangeRef = React85.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React85.useEffect(() => {
    var _a;
    if (prevValueRef.current !== value) {
      (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.9_@types+react-dom@19.1.3_@types+react@19.1.3__@types+r_ooarq3fkufupqvieuavs5tzz3e/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React87 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React86 = __toESM(require("react"), 1);
function useEscapeKeydown2(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef3(onEscapeKeyDownProp);
  React86.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.9_@types+react-dom@19.1.3_@types+react@19.1.3__@types+r_ooarq3fkufupqvieuavs5tzz3e/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime36 = require("react/jsx-runtime");
var DISMISSABLE_LAYER_NAME2 = "DismissableLayer";
var CONTEXT_UPDATE2 = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE2 = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE2 = "dismissableLayer.focusOutside";
var originalBodyPointerEvents2;
var DismissableLayerContext2 = React87.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer2 = React87.forwardRef(
  (props2, forwardedRef) => {
    var _b;
    const _a = props2, {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss
    } = _a, layerProps = __objRest(_a, [
      "disableOutsidePointerEvents",
      "onEscapeKeyDown",
      "onPointerDownOutside",
      "onFocusOutside",
      "onInteractOutside",
      "onDismiss"
    ]);
    const context = React87.useContext(DismissableLayerContext2);
    const [node, setNode] = React87.useState(null);
    const ownerDocument = (_b = node == null ? void 0 : node.ownerDocument) != null ? _b : globalThis == null ? void 0 : globalThis.document;
    const [, force] = React87.useState({});
    const composedRefs = useComposedRefs2(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside2((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside2((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch)
        return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown2((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React87.useEffect(() => {
      if (!node)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents2 = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate2();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents2;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React87.useEffect(() => {
      return () => {
        if (!node)
          return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate2();
      };
    }, [node, context]);
    React87.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE2, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE2, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
      Primitive2.div,
      __spreadProps(__spreadValues({}, layerProps), {
        ref: composedRefs,
        style: __spreadValues({
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0
        }, props2.style),
        onFocusCapture: composeEventHandlers2(props2.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers2(props2.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers2(
          props2.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      })
    );
  }
);
DismissableLayer2.displayName = DISMISSABLE_LAYER_NAME2;
var BRANCH_NAME2 = "DismissableLayerBranch";
var DismissableLayerBranch2 = React87.forwardRef((props2, forwardedRef) => {
  const context = React87.useContext(DismissableLayerContext2);
  const ref2 = React87.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, ref2);
  React87.useEffect(() => {
    const node = ref2.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(Primitive2.div, __spreadProps(__spreadValues({}, props2), { ref: composedRefs }));
});
DismissableLayerBranch2.displayName = BRANCH_NAME2;
function usePointerDownOutside2(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef3(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React87.useRef(false);
  const handleClickRef = React87.useRef(() => {
  });
  React87.useEffect(() => {
    const handlePointerDown2 = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent2(
            POINTER_DOWN_OUTSIDE2,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown2);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown2);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside2(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef3(onFocusOutside);
  const isFocusInsideReactTreeRef = React87.useRef(false);
  React87.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent2(FOCUS_OUTSIDE2, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate2() {
  const event = new CustomEvent(CONTEXT_UPDATE2);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent2(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// ../../node_modules/.pnpm/@radix-ui+react-focus-scope@1.1.6_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@1_6onyxqm4h5j3djnzsk3dghafze/node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React88 = __toESM(require("react"), 1);
var import_jsx_runtime37 = require("react/jsx-runtime");
var AUTOFOCUS_ON_MOUNT2 = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT2 = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME2 = "FocusScope";
var FocusScope2 = React88.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp
  } = _a, scopeProps = __objRest(_a, [
    "loop",
    "trapped",
    "onMountAutoFocus",
    "onUnmountAutoFocus"
  ]);
  const [container, setContainer] = React88.useState(null);
  const onMountAutoFocus = useCallbackRef3(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef3(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React88.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, (node) => setContainer(node));
  const focusScope = React88.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React88.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus2(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React88.useEffect(() => {
    if (container) {
      focusScopesStack2.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT2, EVENT_OPTIONS2);
        container.addEventListener(AUTOFOCUS_ON_MOUNT2, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst2(removeLinks2(getTabbableCandidates2(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus2(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT2, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT2, EVENT_OPTIONS2);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT2, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus2(previouslyFocusedElement != null ? previouslyFocusedElement : document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT2, onUnmountAutoFocus);
          focusScopesStack2.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React88.useCallback(
    (event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges2(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              focus2(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              focus2(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Primitive2.div, __spreadProps(__spreadValues({ tabIndex: -1 }, scopeProps), { ref: composedRefs, onKeyDown: handleKeyDown }));
});
FocusScope2.displayName = FOCUS_SCOPE_NAME2;
function focusFirst2(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus2(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges2(container) {
  const candidates = getTabbableCandidates2(container);
  const first = findVisible2(candidates, container);
  const last = findVisible2(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible2(elements, container) {
  for (const element of elements) {
    if (!isHidden2(element, { upTo: container }))
      return element;
  }
}
function isHidden2(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput2(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus2(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput2(element) && select)
      element.select();
  }
}
var focusScopesStack2 = createFocusScopesStack2();
function createFocusScopesStack2() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove2(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove2(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove2(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks2(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../../node_modules/.pnpm/@radix-ui+react-portal@1.1.8_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_ejo7vqngq2ibtgsw7e4tsogxei/node_modules/@radix-ui/react-portal/dist/index.mjs
var React89 = __toESM(require("react"), 1);
var import_react_dom3 = __toESM(require("react-dom"), 1);
var import_jsx_runtime38 = require("react/jsx-runtime");
var PORTAL_NAME5 = "Portal";
var Portal4 = React89.forwardRef((props2, forwardedRef) => {
  var _b;
  const _a = props2, { container: containerProp } = _a, portalProps = __objRest(_a, ["container"]);
  const [mounted, setMounted] = React89.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_b = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _b.body);
  return container ? import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Primitive2.div, __spreadProps(__spreadValues({}, portalProps), { ref: forwardedRef })), container) : null;
});
Portal4.displayName = PORTAL_NAME5;

// ../../node_modules/.pnpm/@radix-ui+react-presence@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1_vnyloookubwqfj2pur6ybdu5pe/node_modules/@radix-ui/react-presence/dist/index.mjs
var React211 = __toESM(require("react"), 1);
var React90 = __toESM(require("react"), 1);
function useStateMachine2(initialState, machine) {
  return React90.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState != null ? nextState : state;
  }, initialState);
}
var Presence2 = (props2) => {
  const { present, children } = props2;
  const presence = usePresence2(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React211.Children.only(children);
  const ref2 = useComposedRefs2(presence.ref, getElementRef4(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React211.cloneElement(child, { ref: ref2 }) : null;
};
Presence2.displayName = "Presence";
function usePresence2(present) {
  const [node, setNode] = React211.useState();
  const stylesRef = React211.useRef(null);
  const prevPresentRef = React211.useRef(present);
  const prevAnimationNameRef = React211.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine2(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React211.useEffect(() => {
    const currentAnimationName = getAnimationName2(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName2(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    var _a;
    if (node) {
      let timeoutId;
      const ownerWindow = (_a = node.ownerDocument.defaultView) != null ? _a : window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName2(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName2(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React211.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName2(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef4(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/@radix-ui+react-focus-guards@1.1.2_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React91 = __toESM(require("react"), 1);
var count4 = 0;
function useFocusGuards2() {
  React91.useEffect(() => {
    var _a, _b;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_a = edgeGuards[0]) != null ? _a : createFocusGuard2());
    document.body.insertAdjacentElement("beforeend", (_b = edgeGuards[1]) != null ? _b : createFocusGuard2());
    count4++;
    return () => {
      if (count4 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count4--;
    };
  }, []);
}
function createFocusGuard2() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../../node_modules/.pnpm/@radix-ui+react-dialog@1.1.13_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1._v6gw3ahcqwldiu3xdlfwsdrrsu/node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime39 = require("react/jsx-runtime");
var DIALOG_NAME2 = "Dialog";
var [createDialogContext2, createDialogScope2] = createContextScope2(DIALOG_NAME2);
var [DialogProvider2, useDialogContext2] = createDialogContext2(DIALOG_NAME2);
var Dialog2 = (props2) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props2;
  const triggerRef = React92.useRef(null);
  const contentRef = React92.useRef(null);
  const [open, setOpen] = useControllableState2({
    prop: openProp,
    defaultProp: defaultOpen != null ? defaultOpen : false,
    onChange: onOpenChange,
    caller: DIALOG_NAME2
  });
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
    DialogProvider2,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId2(),
      titleId: useId2(),
      descriptionId: useId2(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React92.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog2.displayName = DIALOG_NAME2;
var TRIGGER_NAME6 = "DialogTrigger";
var DialogTrigger2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, triggerProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext2(TRIGGER_NAME6, __scopeDialog);
    const composedTriggerRef = useComposedRefs2(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
      Primitive2.button,
      __spreadProps(__spreadValues({
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState5(context.open)
      }, triggerProps), {
        ref: composedTriggerRef,
        onClick: composeEventHandlers2(props2.onClick, context.onOpenToggle)
      })
    );
  }
);
DialogTrigger2.displayName = TRIGGER_NAME6;
var PORTAL_NAME6 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext2(PORTAL_NAME6, {
  forceMount: void 0
});
var DialogPortal2 = (props2) => {
  const { __scopeDialog, forceMount, children, container } = props2;
  const context = useDialogContext2(PORTAL_NAME6, __scopeDialog);
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(PortalProvider2, { scope: __scopeDialog, forceMount, children: React92.Children.map(children, (child) => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Presence2, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Portal4, { asChild: true, container, children: child }) })) });
};
DialogPortal2.displayName = PORTAL_NAME6;
var OVERLAY_NAME3 = "DialogOverlay";
var DialogOverlay2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext2(OVERLAY_NAME3, props2.__scopeDialog);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, overlayProps = __objRest(_a, ["forceMount"]);
    const context = useDialogContext2(OVERLAY_NAME3, props2.__scopeDialog);
    return context.modal ? /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Presence2, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(DialogOverlayImpl2, __spreadProps(__spreadValues({}, overlayProps), { ref: forwardedRef })) }) : null;
  }
);
DialogOverlay2.displayName = OVERLAY_NAME3;
var Slot3 = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, overlayProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext2(OVERLAY_NAME3, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Combination_default, { as: Slot3, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
        Primitive2.div,
        __spreadProps(__spreadValues({
          "data-state": getState5(context.open)
        }, overlayProps), {
          ref: forwardedRef,
          style: __spreadValues({ pointerEvents: "auto" }, overlayProps.style)
        })
      ) })
    );
  }
);
var CONTENT_NAME7 = "DialogContent";
var DialogContent2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME7, props2.__scopeDialog);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, contentProps = __objRest(_a, ["forceMount"]);
    const context = useDialogContext2(CONTENT_NAME7, props2.__scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Presence2, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(DialogContentModal2, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) : /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(DialogContentNonModal2, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) });
  }
);
DialogContent2.displayName = CONTENT_NAME7;
var DialogContentModal2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const context = useDialogContext2(CONTENT_NAME7, props2.__scopeDialog);
    const contentRef = React92.useRef(null);
    const composedRefs = useComposedRefs2(forwardedRef, context.contentRef, contentRef);
    React92.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
      DialogContentImpl2,
      __spreadProps(__spreadValues({}, props2), {
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers2(props2.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers2(props2.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers2(
          props2.onFocusOutside,
          (event) => event.preventDefault()
        )
      })
    );
  }
);
var DialogContentNonModal2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const context = useDialogContext2(CONTENT_NAME7, props2.__scopeDialog);
    const hasInteractedOutsideRef = React92.useRef(false);
    const hasPointerDownOutsideRef = React92.useRef(false);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
      DialogContentImpl2,
      __spreadProps(__spreadValues({}, props2), {
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props2.onCloseAutoFocus) == null ? void 0 : _a.call(props2, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props2.onInteractOutside) == null ? void 0 : _a.call(props2, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      })
    );
  }
);
var DialogContentImpl2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus } = _a, contentProps = __objRest(_a, ["__scopeDialog", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]);
    const context = useDialogContext2(CONTENT_NAME7, __scopeDialog);
    const contentRef = React92.useRef(null);
    const composedRefs = useComposedRefs2(forwardedRef, contentRef);
    useFocusGuards2();
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
        FocusScope2,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
            DismissableLayer2,
            __spreadProps(__spreadValues({
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState5(context.open)
            }, contentProps), {
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            })
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(TitleWarning2, { titleId: context.titleId }),
        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(DescriptionWarning3, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME3 = "DialogTitle";
var DialogTitle2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, titleProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext2(TITLE_NAME3, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Primitive2.h2, __spreadProps(__spreadValues({ id: context.titleId }, titleProps), { ref: forwardedRef }));
  }
);
DialogTitle2.displayName = TITLE_NAME3;
var DESCRIPTION_NAME3 = "DialogDescription";
var DialogDescription2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, descriptionProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext2(DESCRIPTION_NAME3, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Primitive2.p, __spreadProps(__spreadValues({ id: context.descriptionId }, descriptionProps), { ref: forwardedRef }));
  }
);
DialogDescription2.displayName = DESCRIPTION_NAME3;
var CLOSE_NAME2 = "DialogClose";
var DialogClose2 = React92.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDialog } = _a, closeProps = __objRest(_a, ["__scopeDialog"]);
    const context = useDialogContext2(CLOSE_NAME2, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
      Primitive2.button,
      __spreadProps(__spreadValues({
        type: "button"
      }, closeProps), {
        ref: forwardedRef,
        onClick: composeEventHandlers2(props2.onClick, () => context.onOpenChange(false))
      })
    );
  }
);
DialogClose2.displayName = CLOSE_NAME2;
function getState5(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME2 = "DialogTitleWarning";
var [WarningProvider2, useWarningContext2] = createContext22(TITLE_WARNING_NAME2, {
  contentName: CONTENT_NAME7,
  titleName: TITLE_NAME3,
  docsSlug: "dialog"
});
var TitleWarning2 = ({ titleId }) => {
  const titleWarningContext = useWarningContext2(TITLE_WARNING_NAME2);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React92.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME2 = "DialogDescriptionWarning";
var DescriptionWarning3 = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext2(DESCRIPTION_WARNING_NAME2);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React92.useEffect(() => {
    var _a;
    const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root11 = Dialog2;
var Trigger5 = DialogTrigger2;
var Portal5 = DialogPortal2;
var Overlay3 = DialogOverlay2;
var Content5 = DialogContent2;
var Title3 = DialogTitle2;
var Description3 = DialogDescription2;
var Close2 = DialogClose2;

// ../../node_modules/.pnpm/cmdk@1.0.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/cmdk/dist/index.mjs
var n = __toESM(require("react"), 1);
var import_shim2 = __toESM(require_shim(), 1);
var N = '[cmdk-group=""]';
var Q = '[cmdk-group-items=""]';
var be = '[cmdk-group-heading=""]';
var Z = '[cmdk-item=""]';
var le = `${Z}:not([aria-disabled="true"])`;
var Y2 = "cmdk-item-select";
var I = "data-value";
var he = (r2, o2, t2) => W(r2, o2, t2);
var ue = n.createContext(void 0);
var K2 = () => n.useContext(ue);
var de = n.createContext(void 0);
var ee = () => n.useContext(de);
var fe = n.createContext(void 0);
var me = n.forwardRef((r2, o2) => {
  let t2 = k2(() => {
    var e, s;
    return { search: "", value: (s = (e = r2.value) != null ? e : r2.defaultValue) != null ? s : "", filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), u2 = k2(() => /* @__PURE__ */ new Set()), c = k2(() => /* @__PURE__ */ new Map()), d = k2(() => /* @__PURE__ */ new Map()), f = k2(() => /* @__PURE__ */ new Set()), p2 = pe(r2), _a = r2, { label: v2, children: b, value: l, onValueChange: y, filter: E2, shouldFilter: C, loop: H2, disablePointerSelection: ge2 = false, vimBindings: $3 = true } = _a, O = __objRest(_a, ["label", "children", "value", "onValueChange", "filter", "shouldFilter", "loop", "disablePointerSelection", "vimBindings"]), te2 = useId2(), B2 = useId2(), F = useId2(), x2 = n.useRef(null), R = Te();
  M(() => {
    if (l !== void 0) {
      let e = l.trim();
      t2.current.value = e, h.emit();
    }
  }, [l]), M(() => {
    R(6, re3);
  }, []);
  let h = n.useMemo(() => ({ subscribe: (e) => (f.current.add(e), () => f.current.delete(e)), snapshot: () => t2.current, setState: (e, s, i) => {
    var a, m2, g;
    if (!Object.is(t2.current[e], s)) {
      if (t2.current[e] = s, e === "search")
        W2(), U4(), R(1, z2);
      else if (e === "value" && (i || R(5, re3), ((a = p2.current) == null ? void 0 : a.value) !== void 0)) {
        let S2 = s != null ? s : "";
        (g = (m2 = p2.current).onValueChange) == null || g.call(m2, S2);
        return;
      }
      h.emit();
    }
  }, emit: () => {
    f.current.forEach((e) => e());
  } }), []), q = n.useMemo(() => ({ value: (e, s, i) => {
    var a;
    s !== ((a = d.current.get(e)) == null ? void 0 : a.value) && (d.current.set(e, { value: s, keywords: i }), t2.current.filtered.items.set(e, ne2(s, i)), R(2, () => {
      U4(), h.emit();
    }));
  }, item: (e, s) => (u2.current.add(e), s && (c.current.has(s) ? c.current.get(s).add(e) : c.current.set(s, /* @__PURE__ */ new Set([e]))), R(3, () => {
    W2(), U4(), t2.current.value || z2(), h.emit();
  }), () => {
    d.current.delete(e), u2.current.delete(e), t2.current.filtered.items.delete(e);
    let i = A();
    R(4, () => {
      W2(), (i == null ? void 0 : i.getAttribute("id")) === e && z2(), h.emit();
    });
  }), group: (e) => (c.current.has(e) || c.current.set(e, /* @__PURE__ */ new Set()), () => {
    d.current.delete(e), c.current.delete(e);
  }), filter: () => p2.current.shouldFilter, label: v2 || r2["aria-label"], getDisablePointerSelection: () => p2.current.disablePointerSelection, listId: te2, inputId: F, labelId: B2, listInnerRef: x2 }), []);
  function ne2(e, s) {
    var a, m2;
    let i = (m2 = (a = p2.current) == null ? void 0 : a.filter) != null ? m2 : he;
    return e ? i(e, t2.current.search, s) : 0;
  }
  function U4() {
    if (!t2.current.search || p2.current.shouldFilter === false)
      return;
    let e = t2.current.filtered.items, s = [];
    t2.current.filtered.groups.forEach((a) => {
      let m2 = c.current.get(a), g = 0;
      m2.forEach((S2) => {
        let P = e.get(S2);
        g = Math.max(P, g);
      }), s.push([a, g]);
    });
    let i = x2.current;
    _2().sort((a, m2) => {
      var P, V;
      let g = a.getAttribute("id"), S2 = m2.getAttribute("id");
      return ((P = e.get(S2)) != null ? P : 0) - ((V = e.get(g)) != null ? V : 0);
    }).forEach((a) => {
      let m2 = a.closest(Q);
      m2 ? m2.appendChild(a.parentElement === m2 ? a : a.closest(`${Q} > *`)) : i.appendChild(a.parentElement === i ? a : a.closest(`${Q} > *`));
    }), s.sort((a, m2) => m2[1] - a[1]).forEach((a) => {
      var g;
      let m2 = (g = x2.current) == null ? void 0 : g.querySelector(`${N}[${I}="${encodeURIComponent(a[0])}"]`);
      m2 == null || m2.parentElement.appendChild(m2);
    });
  }
  function z2() {
    let e = _2().find((i) => i.getAttribute("aria-disabled") !== "true"), s = e == null ? void 0 : e.getAttribute(I);
    h.setState("value", s || void 0);
  }
  function W2() {
    var s, i, a, m2;
    if (!t2.current.search || p2.current.shouldFilter === false) {
      t2.current.filtered.count = u2.current.size;
      return;
    }
    t2.current.filtered.groups = /* @__PURE__ */ new Set();
    let e = 0;
    for (let g of u2.current) {
      let S2 = (i = (s = d.current.get(g)) == null ? void 0 : s.value) != null ? i : "", P = (m2 = (a = d.current.get(g)) == null ? void 0 : a.keywords) != null ? m2 : [], V = ne2(S2, P);
      t2.current.filtered.items.set(g, V), V > 0 && e++;
    }
    for (let [g, S2] of c.current)
      for (let P of S2)
        if (t2.current.filtered.items.get(P) > 0) {
          t2.current.filtered.groups.add(g);
          break;
        }
    t2.current.filtered.count = e;
  }
  function re3() {
    var s, i, a;
    let e = A();
    e && (((s = e.parentElement) == null ? void 0 : s.firstChild) === e && ((a = (i = e.closest(N)) == null ? void 0 : i.querySelector(be)) == null || a.scrollIntoView({ block: "nearest" })), e.scrollIntoView({ block: "nearest" }));
  }
  function A() {
    var e;
    return (e = x2.current) == null ? void 0 : e.querySelector(`${Z}[aria-selected="true"]`);
  }
  function _2() {
    var e;
    return Array.from(((e = x2.current) == null ? void 0 : e.querySelectorAll(le)) || []);
  }
  function J2(e) {
    let i = _2()[e];
    i && h.setState("value", i.getAttribute(I));
  }
  function X3(e) {
    var g;
    let s = A(), i = _2(), a = i.findIndex((S2) => S2 === s), m2 = i[a + e];
    (g = p2.current) != null && g.loop && (m2 = a + e < 0 ? i[i.length - 1] : a + e === i.length ? i[0] : i[a + e]), m2 && h.setState("value", m2.getAttribute(I));
  }
  function oe2(e) {
    let s = A(), i = s == null ? void 0 : s.closest(N), a;
    for (; i && !a; )
      i = e > 0 ? Ie(i, N) : Me(i, N), a = i == null ? void 0 : i.querySelector(le);
    a ? h.setState("value", a.getAttribute(I)) : X3(e);
  }
  let ie2 = () => J2(_2().length - 1), ae2 = (e) => {
    e.preventDefault(), e.metaKey ? ie2() : e.altKey ? oe2(1) : X3(1);
  }, se2 = (e) => {
    e.preventDefault(), e.metaKey ? J2(0) : e.altKey ? oe2(-1) : X3(-1);
  };
  return n.createElement(Primitive2.div, __spreadProps(__spreadValues({ ref: o2, tabIndex: -1 }, O), { "cmdk-root": "", onKeyDown: (e) => {
    var s;
    if ((s = O.onKeyDown) == null || s.call(O, e), !e.defaultPrevented)
      switch (e.key) {
        case "n":
        case "j": {
          $3 && e.ctrlKey && ae2(e);
          break;
        }
        case "ArrowDown": {
          ae2(e);
          break;
        }
        case "p":
        case "k": {
          $3 && e.ctrlKey && se2(e);
          break;
        }
        case "ArrowUp": {
          se2(e);
          break;
        }
        case "Home": {
          e.preventDefault(), J2(0);
          break;
        }
        case "End": {
          e.preventDefault(), ie2();
          break;
        }
        case "Enter":
          if (!e.nativeEvent.isComposing && e.keyCode !== 229) {
            e.preventDefault();
            let i = A();
            if (i) {
              let a = new Event(Y2);
              i.dispatchEvent(a);
            }
          }
      }
  } }), n.createElement("label", { "cmdk-label": "", htmlFor: q.inputId, id: q.labelId, style: Le }, v2), j(r2, (e) => n.createElement(de.Provider, { value: h }, n.createElement(ue.Provider, { value: q }, e))));
});
var ye = n.forwardRef((r2, o2) => {
  var F, x2;
  let t2 = useId2(), u2 = n.useRef(null), c = n.useContext(fe), d = K2(), f = pe(r2), p2 = (x2 = (F = f.current) == null ? void 0 : F.forceMount) != null ? x2 : c == null ? void 0 : c.forceMount;
  M(() => {
    if (!p2)
      return d.item(t2, c == null ? void 0 : c.id);
  }, [p2]);
  let v2 = ve(t2, u2, [r2.value, r2.children, u2], r2.keywords), b = ee(), l = T((R) => R.value && R.value === v2.current), y = T((R) => p2 || d.filter() === false ? true : R.search ? R.filtered.items.get(t2) > 0 : true);
  n.useEffect(() => {
    let R = u2.current;
    if (!(!R || r2.disabled))
      return R.addEventListener(Y2, E2), () => R.removeEventListener(Y2, E2);
  }, [y, r2.onSelect, r2.disabled]);
  function E2() {
    var R, h;
    C(), (h = (R = f.current).onSelect) == null || h.call(R, v2.current);
  }
  function C() {
    b.setState("value", v2.current, true);
  }
  if (!y)
    return null;
  let _a = r2, { disabled: H2, value: ge2, onSelect: $3, forceMount: O, keywords: te2 } = _a, B2 = __objRest(_a, ["disabled", "value", "onSelect", "forceMount", "keywords"]);
  return n.createElement(Primitive2.div, __spreadProps(__spreadValues({ ref: G2([u2, o2]) }, B2), { id: t2, "cmdk-item": "", role: "option", "aria-disabled": !!H2, "aria-selected": !!l, "data-disabled": !!H2, "data-selected": !!l, onPointerMove: H2 || d.getDisablePointerSelection() ? void 0 : C, onClick: H2 ? void 0 : E2 }), r2.children);
});
var Se = n.forwardRef((r2, o2) => {
  let _a = r2, { heading: t2, children: u2, forceMount: c } = _a, d = __objRest(_a, ["heading", "children", "forceMount"]), f = useId2(), p2 = n.useRef(null), v2 = n.useRef(null), b = useId2(), l = K2(), y = T((C) => c || l.filter() === false ? true : C.search ? C.filtered.groups.has(f) : true);
  M(() => l.group(f), []), ve(f, p2, [r2.value, r2.heading, v2]);
  let E2 = n.useMemo(() => ({ id: f, forceMount: c }), [c]);
  return n.createElement(Primitive2.div, __spreadProps(__spreadValues({ ref: G2([p2, o2]) }, d), { "cmdk-group": "", role: "presentation", hidden: y ? void 0 : true }), t2 && n.createElement("div", { ref: v2, "cmdk-group-heading": "", "aria-hidden": true, id: b }, t2), j(r2, (C) => n.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": t2 ? b : void 0 }, n.createElement(fe.Provider, { value: E2 }, C))));
});
var Ee = n.forwardRef((r2, o2) => {
  let _a = r2, { alwaysRender: t2 } = _a, u2 = __objRest(_a, ["alwaysRender"]), c = n.useRef(null), d = T((f) => !f.search);
  return !t2 && !d ? null : n.createElement(Primitive2.div, __spreadProps(__spreadValues({ ref: G2([c, o2]) }, u2), { "cmdk-separator": "", role: "separator" }));
});
var Ce = n.forwardRef((r2, o2) => {
  let _a = r2, { onValueChange: t2 } = _a, u2 = __objRest(_a, ["onValueChange"]), c = r2.value != null, d = ee(), f = T((l) => l.search), p2 = T((l) => l.value), v2 = K2(), b = n.useMemo(() => {
    var y;
    let l = (y = v2.listInnerRef.current) == null ? void 0 : y.querySelector(`${Z}[${I}="${encodeURIComponent(p2)}"]`);
    return l == null ? void 0 : l.getAttribute("id");
  }, []);
  return n.useEffect(() => {
    r2.value != null && d.setState("search", r2.value);
  }, [r2.value]), n.createElement(Primitive2.input, __spreadProps(__spreadValues({ ref: o2 }, u2), { "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: false, "aria-autocomplete": "list", role: "combobox", "aria-expanded": true, "aria-controls": v2.listId, "aria-labelledby": v2.labelId, "aria-activedescendant": b, id: v2.inputId, type: "text", value: c ? r2.value : f, onChange: (l) => {
    c || d.setState("search", l.target.value), t2 == null || t2(l.target.value);
  } }));
});
var xe = n.forwardRef((r2, o2) => {
  let _a = r2, { children: t2, label: u2 = "Suggestions" } = _a, c = __objRest(_a, ["children", "label"]), d = n.useRef(null), f = n.useRef(null), p2 = K2();
  return n.useEffect(() => {
    if (f.current && d.current) {
      let v2 = f.current, b = d.current, l, y = new ResizeObserver(() => {
        l = requestAnimationFrame(() => {
          let E2 = v2.offsetHeight;
          b.style.setProperty("--cmdk-list-height", E2.toFixed(1) + "px");
        });
      });
      return y.observe(v2), () => {
        cancelAnimationFrame(l), y.unobserve(v2);
      };
    }
  }, []), n.createElement(Primitive2.div, __spreadProps(__spreadValues({ ref: G2([d, o2]) }, c), { "cmdk-list": "", role: "listbox", "aria-label": u2, id: p2.listId }), j(r2, (v2) => n.createElement("div", { ref: G2([f, p2.listInnerRef]), "cmdk-list-sizer": "" }, v2)));
});
var Pe = n.forwardRef((r2, o2) => {
  let _a = r2, { open: t2, onOpenChange: u2, overlayClassName: c, contentClassName: d, container: f } = _a, p2 = __objRest(_a, ["open", "onOpenChange", "overlayClassName", "contentClassName", "container"]);
  return n.createElement(Root11, { open: t2, onOpenChange: u2 }, n.createElement(Portal5, { container: f }, n.createElement(Overlay3, { "cmdk-overlay": "", className: c }), n.createElement(Content5, { "aria-label": r2.label, "cmdk-dialog": "", className: d }, n.createElement(me, __spreadValues({ ref: o2 }, p2)))));
});
var we = n.forwardRef((r2, o2) => T((u2) => u2.filtered.count === 0) ? n.createElement(Primitive2.div, __spreadProps(__spreadValues({ ref: o2 }, r2), { "cmdk-empty": "", role: "presentation" })) : null);
var De = n.forwardRef((r2, o2) => {
  let _a = r2, { progress: t2, children: u2, label: c = "Loading..." } = _a, d = __objRest(_a, ["progress", "children", "label"]);
  return n.createElement(Primitive2.div, __spreadProps(__spreadValues({ ref: o2 }, d), { "cmdk-loading": "", role: "progressbar", "aria-valuenow": t2, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": c }), j(r2, (f) => n.createElement("div", { "aria-hidden": true }, f)));
});
var Ve = Object.assign(me, { List: xe, Item: ye, Input: Ce, Group: Se, Separator: Ee, Dialog: Pe, Empty: we, Loading: De });
function Ie(r2, o2) {
  let t2 = r2.nextElementSibling;
  for (; t2; ) {
    if (t2.matches(o2))
      return t2;
    t2 = t2.nextElementSibling;
  }
}
function Me(r2, o2) {
  let t2 = r2.previousElementSibling;
  for (; t2; ) {
    if (t2.matches(o2))
      return t2;
    t2 = t2.previousElementSibling;
  }
}
function pe(r2) {
  let o2 = n.useRef(r2);
  return M(() => {
    o2.current = r2;
  }), o2;
}
var M = typeof window == "undefined" ? n.useEffect : n.useLayoutEffect;
function k2(r2) {
  let o2 = n.useRef();
  return o2.current === void 0 && (o2.current = r2()), o2;
}
function G2(r2) {
  return (o2) => {
    r2.forEach((t2) => {
      typeof t2 == "function" ? t2(o2) : t2 != null && (t2.current = o2);
    });
  };
}
function T(r2) {
  let o2 = ee(), t2 = () => r2(o2.snapshot());
  return (0, import_shim2.useSyncExternalStore)(o2.subscribe, t2, t2);
}
function ve(r2, o2, t2, u2 = []) {
  let c = n.useRef(), d = K2();
  return M(() => {
    var v2;
    let f = (() => {
      var b;
      for (let l of t2) {
        if (typeof l == "string")
          return l.trim();
        if (typeof l == "object" && "current" in l)
          return l.current ? (b = l.current.textContent) == null ? void 0 : b.trim() : c.current;
      }
    })(), p2 = u2.map((b) => b.trim());
    d.value(r2, f, p2), (v2 = o2.current) == null || v2.setAttribute(I, f), c.current = f;
  }), c;
}
var Te = () => {
  let [r2, o2] = n.useState(), t2 = k2(() => /* @__PURE__ */ new Map());
  return M(() => {
    t2.current.forEach((u2) => u2()), t2.current = /* @__PURE__ */ new Map();
  }, [r2]), (u2, c) => {
    t2.current.set(u2, c), o2({});
  };
};
function ke(r2) {
  let o2 = r2.type;
  return typeof o2 == "function" ? o2(r2.props) : "render" in o2 ? o2.render(r2.props) : r2;
}
function j({ asChild: r2, children: o2 }, t2) {
  return r2 && n.isValidElement(o2) ? n.cloneElement(ke(o2), { ref: o2.ref }, t2(o2.props.children)) : t2(o2);
}
var Le = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };

// src/components/command.tsx
var import_utils22 = require("@nubras/utils");

// src/components/dialog.tsx
var React93 = __toESM(require("react"));
var import_utils21 = require("@nubras/utils");
var import_jsx_runtime40 = require("react/jsx-runtime");
var Dialog3 = Root11;
var DialogTrigger3 = Trigger5;
var DialogPortal3 = Portal5;
var DialogClose3 = Close2;
var DialogOverlay3 = React93.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    Overlay3,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils21.cn)(
        "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        className
      )
    }, props2)
  );
});
DialogOverlay3.displayName = Overlay3.displayName;
var DialogContent3 = React93.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(DialogPortal3, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(DialogOverlay3, {}),
    /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(
      Content5,
      __spreadProps(__spreadValues({
        ref: ref2,
        className: (0, import_utils21.cn)(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          className
        )
      }, props2), {
        children: [
          children,
          /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(Close2, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
            /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(X, { className: "h-4 w-4" }),
            /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("span", { className: "sr-only", children: "Close" })
          ] })
        ]
      })
    )
  ] });
});
DialogContent3.displayName = Content5.displayName;
var DialogHeader = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    "div",
    __spreadValues({
      className: (0, import_utils21.cn)(
        "flex flex-col space-y-1.5 text-center sm:text-left",
        className
      )
    }, props2)
  );
};
DialogHeader.displayName = "DialogHeader";
var DialogFooter = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    "div",
    __spreadValues({
      className: (0, import_utils21.cn)(
        "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
        className
      )
    }, props2)
  );
};
DialogFooter.displayName = "DialogFooter";
var DialogTitle3 = React93.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    Title3,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils21.cn)(
        "text-lg font-semibold leading-none tracking-tight",
        className
      )
    }, props2)
  );
});
DialogTitle3.displayName = Title3.displayName;
var DialogDescription3 = React93.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    Description3,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils21.cn)("text-sm text-muted-foreground", className)
    }, props2)
  );
});
DialogDescription3.displayName = Description3.displayName;

// src/components/command.tsx
var import_jsx_runtime41 = require("react/jsx-runtime");
var Command = React94.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    Ve,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils22.cn)(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        className
      )
    }, props2)
  );
});
Command.displayName = Ve.displayName;
var CommandDialog = (_a) => {
  var _b = _a, { children } = _b, props2 = __objRest(_b, ["children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Dialog3, __spreadProps(__spreadValues({}, props2), { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(DialogContent3, { className: "overflow-hidden p-0 shadow-lg", children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Command, { className: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5", children }) }) }));
};
var CommandInput = React94.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)("div", { className: "flex items-center border-b px-3", "cmdk-input-wrapper": "", children: [
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Search, { className: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
      Ve.Input,
      __spreadValues({
        ref: ref2,
        className: (0, import_utils22.cn)(
          "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          className
        )
      }, props2)
    )
  ] });
});
CommandInput.displayName = Ve.Input.displayName;
var CommandList = React94.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    Ve.List,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils22.cn)("max-h-[300px] overflow-y-auto overflow-x-hidden", className)
    }, props2)
  );
});
CommandList.displayName = Ve.List.displayName;
var CommandEmpty = React94.forwardRef((props2, ref2) => /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
  Ve.Empty,
  __spreadValues({
    ref: ref2,
    className: "py-6 text-center text-sm"
  }, props2)
));
CommandEmpty.displayName = Ve.Empty.displayName;
var CommandGroup = React94.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    Ve.Group,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils22.cn)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        className
      )
    }, props2)
  );
});
CommandGroup.displayName = Ve.Group.displayName;
var CommandSeparator = React94.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    Ve.Separator,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils22.cn)("-mx-1 h-px bg-border", className)
    }, props2)
  );
});
CommandSeparator.displayName = Ve.Separator.displayName;
var CommandItem = React94.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    Ve.Item,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils22.cn)(
        "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        className
      )
    }, props2)
  );
});
CommandItem.displayName = Ve.Item.displayName;
var CommandShortcut = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    "span",
    __spreadValues({
      className: (0, import_utils22.cn)(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )
    }, props2)
  );
};
CommandShortcut.displayName = "CommandShortcut";

// src/components/context-menu.tsx
var React98 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-context-menu@2.2.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_cnl24vvy5wzgsasieywi2uzh7e/node_modules/@radix-ui/react-context-menu/dist/index.mjs
var React97 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-menu@2.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_r_lrqgz6sxsgqbcu2xbq74o7m5di/node_modules/@radix-ui/react-menu/dist/index.mjs
var React96 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-roving-focus@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_kanfvqynev2kduvwvrnuaztu7a/node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React95 = __toESM(require("react"), 1);
var import_jsx_runtime42 = require("react/jsx-runtime");
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS3 = { bubbles: false, cancelable: true };
var GROUP_NAME2 = "RovingFocusGroup";
var [Collection3, useCollection3, createCollectionScope3] = createCollection(GROUP_NAME2);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME2,
  [createCollectionScope3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME2);
var RovingFocusGroup = React95.forwardRef(
  (props2, forwardedRef) => {
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(Collection3.Provider, { scope: props2.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(Collection3.Slot, { scope: props2.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(RovingFocusGroupImpl, __spreadProps(__spreadValues({}, props2), { ref: forwardedRef })) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME2;
var RovingFocusGroupImpl = React95.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false
  } = _a, groupProps = __objRest(_a, [
    "__scopeRovingFocusGroup",
    "orientation",
    "loop",
    "dir",
    "currentTabStopId",
    "defaultCurrentTabStopId",
    "onCurrentTabStopIdChange",
    "onEntryFocus",
    "preventScrollOnEntryFocus"
  ]);
  const ref2 = React95.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React95.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection3(__scopeRovingFocusGroup);
  const isClickFocusRef = React95.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React95.useState(0);
  React95.useEffect(() => {
    const node = ref2.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React95.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React95.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React95.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React95.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
        Primitive.div,
        __spreadProps(__spreadValues({
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation
        }, groupProps), {
          ref: composedRefs,
          style: __spreadValues({ outline: "none" }, props2.style),
          onMouseDown: composeEventHandlers(props2.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props2.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS3);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst3(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props2.onBlur, () => setIsTabbingBackOut(false))
        })
      )
    }
  );
});
var ITEM_NAME3 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React95.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId
    } = _a, itemProps = __objRest(_a, [
      "__scopeRovingFocusGroup",
      "focusable",
      "active",
      "tabStopId"
    ]);
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME3, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    React95.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
      Collection3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
          Primitive.span,
          __spreadProps(__spreadValues({
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation
          }, itemProps), {
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props2.onMouseDown, (event) => {
              if (!focusable)
                event.preventDefault();
              else
                context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props2.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget)
                return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
                  return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last")
                  candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev")
                    candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst3(candidateNodes));
              }
            })
          })
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME3;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst3(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root12 = RovingFocusGroup;
var Item3 = RovingFocusGroupItem;

// ../../node_modules/.pnpm/@radix-ui+react-menu@2.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_r_lrqgz6sxsgqbcu2xbq74o7m5di/node_modules/@radix-ui/react-menu/dist/index.mjs
var import_jsx_runtime43 = require("react/jsx-runtime");
var SELECTION_KEYS2 = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS2, "ArrowRight"],
  rtl: [...SELECTION_KEYS2, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection4, useCollection4, createCollectionScope4] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope4,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope2 = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props2) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props2;
  const popperScope = usePopperScope2(__scopeMenu);
  const [content, setContent] = React96.useState(null);
  const isUsingKeyboardRef = React96.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React96.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Root23, __spreadProps(__spreadValues({}, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React96.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) }));
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME2 = "MenuAnchor";
var MenuAnchor = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenu } = _a, anchorProps = __objRest(_a, ["__scopeMenu"]);
    const popperScope = usePopperScope2(__scopeMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Anchor, __spreadProps(__spreadValues(__spreadValues({}, popperScope), anchorProps), { ref: forwardedRef }));
  }
);
MenuAnchor.displayName = ANCHOR_NAME2;
var PORTAL_NAME7 = "MenuPortal";
var [PortalProvider3, usePortalContext3] = createMenuContext(PORTAL_NAME7, {
  forceMount: void 0
});
var MenuPortal = (props2) => {
  const { __scopeMenu, forceMount, children, container } = props2;
  const context = useMenuContext(PORTAL_NAME7, __scopeMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(PortalProvider3, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME7;
var CONTENT_NAME8 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME8);
var MenuContent = React96.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME8, props2.__scopeMenu);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, contentProps = __objRest(_a, ["forceMount"]);
    const context = useMenuContext(CONTENT_NAME8, props2.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME8, props2.__scopeMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Collection4.Provider, { scope: props2.__scopeMenu, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Collection4.Slot, { scope: props2.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(MenuRootContentModal, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) : /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(MenuRootContentNonModal, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) }) }) });
  }
);
var MenuRootContentModal = React96.forwardRef(
  (props2, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME8, props2.__scopeMenu);
    const ref2 = React96.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    React96.useEffect(() => {
      const content = ref2.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      MenuContentImpl,
      __spreadProps(__spreadValues({}, props2), {
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props2.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      })
    );
  }
);
var MenuRootContentNonModal = React96.forwardRef((props2, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME8, props2.__scopeMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
    MenuContentImpl,
    __spreadProps(__spreadValues({}, props2), {
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    })
  );
});
var MenuContentImpl = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll
    } = _a, contentProps = __objRest(_a, [
      "__scopeMenu",
      "loop",
      "trapFocus",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "disableOutsidePointerEvents",
      "onEntryFocus",
      "onEscapeKeyDown",
      "onPointerDownOutside",
      "onFocusOutside",
      "onInteractOutside",
      "onDismiss",
      "disableOutsideScroll"
    ]);
    const context = useMenuContext(CONTENT_NAME8, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME8, __scopeMenu);
    const popperScope = usePopperScope2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const getItems = useCollection4(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React96.useState(null);
    const contentRef = React96.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React96.useRef(0);
    const searchRef = React96.useRef("");
    const pointerGraceTimerRef = React96.useRef(0);
    const pointerGraceIntentRef = React96.useRef(null);
    const pointerDirRef = React96.useRef("right");
    const lastPointerXRef = React96.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React96.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a2, _b;
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a2 = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a2.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React96.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React96.useCallback((event) => {
      var _a2, _b;
      const isMovingTowards = pointerDirRef.current === ((_a2 = pointerGraceIntentRef.current) == null ? void 0 : _a2.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b = pointerGraceIntentRef.current) == null ? void 0 : _b.area);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React96.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event))
              event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React96.useCallback(
          (event) => {
            var _a2;
            if (isPointerMovingToSubmenu(event))
              return;
            (_a2 = contentRef.current) == null ? void 0 : _a2.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React96.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event))
              event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React96.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(ScrollLockWrapper, __spreadProps(__spreadValues({}, scrollLockWrapperProps), { children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a2;
              event.preventDefault();
              (_a2 = contentRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
                  Root12,
                  __spreadProps(__spreadValues({
                    asChild: true
                  }, rovingFocusGroupScope), {
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current)
                        event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
                      Content4,
                      __spreadProps(__spreadValues(__spreadValues({
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir
                      }, popperScope), contentProps), {
                        ref: composedRefs,
                        style: __spreadValues({ outline: "none" }, contentProps.style),
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab")
                              event.preventDefault();
                            if (!isModifierKey && isCharacterKey)
                              handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content)
                            return;
                          if (!FIRST_LAST_KEYS.includes(event.key))
                            return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key))
                            candidateNodes.reverse();
                          focusFirst4(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props2.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props2.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      })
                    )
                  })
                )
              }
            )
          }
        ) }))
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME8;
var GROUP_NAME3 = "MenuGroup";
var MenuGroup = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenu } = _a, groupProps = __objRest(_a, ["__scopeMenu"]);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Primitive.div, __spreadProps(__spreadValues({ role: "group" }, groupProps), { ref: forwardedRef }));
  }
);
MenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "MenuLabel";
var MenuLabel = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenu } = _a, labelProps = __objRest(_a, ["__scopeMenu"]);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Primitive.div, __spreadProps(__spreadValues({}, labelProps), { ref: forwardedRef }));
  }
);
MenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME4 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { disabled = false, onSelect } = _a, itemProps = __objRest(_a, ["disabled", "onSelect"]);
    const ref2 = React96.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME4, props2.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME4, props2.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const isPointerDownRef = React96.useRef(false);
    const handleSelect = () => {
      const menuItem = ref2.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      MenuItemImpl,
      __spreadProps(__spreadValues({}, itemProps), {
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props2.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a2;
          (_a2 = props2.onPointerDown) == null ? void 0 : _a2.call(props2, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props2.onPointerUp, (event) => {
          var _a2;
          if (!isPointerDownRef.current)
            (_a2 = event.currentTarget) == null ? void 0 : _a2.click();
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ")
            return;
          if (SELECTION_KEYS2.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      })
    );
  }
);
MenuItem.displayName = ITEM_NAME4;
var MenuItemImpl = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenu, disabled = false, textValue } = _a, itemProps = __objRest(_a, ["__scopeMenu", "disabled", "textValue"]);
    const contentContext = useMenuContentContext(ITEM_NAME4, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const ref2 = React96.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const [isFocused, setIsFocused] = React96.useState(false);
    const [textContent, setTextContent] = React96.useState("");
    React96.useEffect(() => {
      var _a2;
      const menuItem = ref2.current;
      if (menuItem) {
        setTextContent(((_a2 = menuItem.textContent) != null ? _a2 : "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      Collection4.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue != null ? textValue : textContent,
        children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Item3, __spreadProps(__spreadValues({ asChild: true }, rovingFocusGroupScope), { focusable: !disabled, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
          Primitive.div,
          __spreadProps(__spreadValues({
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0
          }, itemProps), {
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props2.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props2.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props2.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props2.onBlur, () => setIsFocused(false))
          })
        ) }))
      }
    );
  }
);
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { checked = false, onCheckedChange } = _a, checkboxItemProps = __objRest(_a, ["checked", "onCheckedChange"]);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(ItemIndicatorProvider, { scope: props2.__scopeMenu, checked, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      MenuItem,
      __spreadProps(__spreadValues({
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate2(checked) ? "mixed" : checked
      }, checkboxItemProps), {
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate2(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      })
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { value, onValueChange } = _a, groupProps = __objRest(_a, ["value", "onValueChange"]);
    const handleValueChange = useCallbackRef(onValueChange);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(RadioGroupProvider, { scope: props2.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(MenuGroup, __spreadProps(__spreadValues({}, groupProps), { ref: forwardedRef })) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { value } = _a, radioItemProps = __objRest(_a, ["value"]);
    const context = useRadioGroupContext(RADIO_ITEM_NAME, props2.__scopeMenu);
    const checked = value === context.value;
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(ItemIndicatorProvider, { scope: props2.__scopeMenu, checked, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      MenuItem,
      __spreadProps(__spreadValues({
        role: "menuitemradio",
        "aria-checked": checked
      }, radioItemProps), {
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a2;
            return (_a2 = context.onValueChange) == null ? void 0 : _a2.call(context, value);
          },
          { checkForDefaultPrevented: false }
        )
      })
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME2 = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME2,
  { checked: false }
);
var MenuItemIndicator = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenu, forceMount } = _a, itemIndicatorProps = __objRest(_a, ["__scopeMenu", "forceMount"]);
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME2, __scopeMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate2(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
          Primitive.span,
          __spreadProps(__spreadValues({}, itemIndicatorProps), {
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          })
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME2;
var SEPARATOR_NAME2 = "MenuSeparator";
var MenuSeparator = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenu } = _a, separatorProps = __objRest(_a, ["__scopeMenu"]);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      Primitive.div,
      __spreadProps(__spreadValues({
        role: "separator",
        "aria-orientation": "horizontal"
      }, separatorProps), {
        ref: forwardedRef
      })
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME3 = "MenuArrow";
var MenuArrow = React96.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenu } = _a, arrowProps = __objRest(_a, ["__scopeMenu"]);
    const popperScope = usePopperScope2(__scopeMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Arrow2, __spreadProps(__spreadValues(__spreadValues({}, popperScope), arrowProps), { ref: forwardedRef }));
  }
);
MenuArrow.displayName = ARROW_NAME3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props2) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props2;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope2(__scopeMenu);
  const [trigger, setTrigger] = React96.useState(null);
  const [content, setContent] = React96.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React96.useEffect(() => {
    if (parentMenuContext.open === false)
      handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Root23, __spreadProps(__spreadValues({}, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) }));
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React96.forwardRef(
  (props2, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const openTimerRef = React96.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props2.__scopeMenu };
    const clearOpenTimer = React96.useCallback(() => {
      if (openTimerRef.current)
        window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React96.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React96.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(MenuAnchor, __spreadProps(__spreadValues({ asChild: true }, scope), { children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      MenuItemImpl,
      __spreadProps(__spreadValues({
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open)
      }, props2), {
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a;
          (_a = props2.onClick) == null ? void 0 : _a.call(props2, event);
          if (props2.disabled || event.defaultPrevented)
            return;
          event.currentTarget.focus();
          if (!context.open)
            context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props2.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented)
              return;
            if (!props2.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props2.onPointerLeave,
          whenMouse((event) => {
            var _a, _b;
            clearOpenTimer();
            const contentRect = (_a = context.content) == null ? void 0 : _a.getBoundingClientRect();
            if (contentRect) {
              const side = (_b = context.content) == null ? void 0 : _b.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented)
                return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          var _a;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props2.disabled || isTypingAhead && event.key === " ")
            return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a = context.content) == null ? void 0 : _a.focus();
            event.preventDefault();
          }
        })
      })
    ) }));
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React96.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME8, props2.__scopeMenu);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, subContentProps = __objRest(_a, ["forceMount"]);
    const context = useMenuContext(CONTENT_NAME8, props2.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME8, props2.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props2.__scopeMenu);
    const ref2 = React96.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Collection4.Provider, { scope: props2.__scopeMenu, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Collection4.Slot, { scope: props2.__scopeMenu, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      MenuContentImpl,
      __spreadProps(__spreadValues({
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId
      }, subContentProps), {
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a2;
          if (rootContext.isUsingKeyboardRef.current)
            (_a2 = ref2.current) == null ? void 0 : _a2.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props2.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger)
            context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props2.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          var _a2;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a2 = subContext.trigger) == null ? void 0 : _a2.focus();
            event.preventDefault();
          }
        })
      })
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate2(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate2(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst4(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray3(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray3(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v2) => v2 !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon(point, polygon) {
  const { x: x2, y } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root32 = Menu;
var Anchor2 = MenuAnchor;
var Portal6 = MenuPortal;
var Content24 = MenuContent;
var Group2 = MenuGroup;
var Label2 = MenuLabel;
var Item22 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator2 = MenuItemIndicator;
var Separator2 = MenuSeparator;
var Arrow22 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;

// ../../node_modules/.pnpm/@radix-ui+react-context-menu@2.2.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_cnl24vvy5wzgsasieywi2uzh7e/node_modules/@radix-ui/react-context-menu/dist/index.mjs
var import_jsx_runtime44 = require("react/jsx-runtime");
var CONTEXT_MENU_NAME = "ContextMenu";
var [createContextMenuContext, createContextMenuScope] = createContextScope(CONTEXT_MENU_NAME, [
  createMenuScope
]);
var useMenuScope = createMenuScope();
var [ContextMenuProvider, useContextMenuContext] = createContextMenuContext(CONTEXT_MENU_NAME);
var ContextMenu = (props2) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props2;
  const [open, setOpen] = React97.useState(false);
  const menuScope = useMenuScope(__scopeContextMenu);
  const handleOpenChangeProp = useCallbackRef(onOpenChange);
  const handleOpenChange = React97.useCallback(
    (open2) => {
      setOpen(open2);
      handleOpenChangeProp(open2);
    },
    [handleOpenChangeProp]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
    ContextMenuProvider,
    {
      scope: __scopeContextMenu,
      open,
      onOpenChange: handleOpenChange,
      modal,
      children: /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
        Root32,
        __spreadProps(__spreadValues({}, menuScope), {
          dir,
          open,
          onOpenChange: handleOpenChange,
          modal,
          children
        })
      )
    }
  );
};
ContextMenu.displayName = CONTEXT_MENU_NAME;
var TRIGGER_NAME7 = "ContextMenuTrigger";
var ContextMenuTrigger = React97.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeContextMenu, disabled = false } = _a, triggerProps = __objRest(_a, ["__scopeContextMenu", "disabled"]);
    const context = useContextMenuContext(TRIGGER_NAME7, __scopeContextMenu);
    const menuScope = useMenuScope(__scopeContextMenu);
    const pointRef = React97.useRef({ x: 0, y: 0 });
    const virtualRef = React97.useRef({
      getBoundingClientRect: () => DOMRect.fromRect(__spreadValues({ width: 0, height: 0 }, pointRef.current))
    });
    const longPressTimerRef = React97.useRef(0);
    const clearLongPress = React97.useCallback(
      () => window.clearTimeout(longPressTimerRef.current),
      []
    );
    const handleOpen = (event) => {
      pointRef.current = { x: event.clientX, y: event.clientY };
      context.onOpenChange(true);
    };
    React97.useEffect(() => clearLongPress, [clearLongPress]);
    React97.useEffect(() => void (disabled && clearLongPress()), [disabled, clearLongPress]);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Anchor2, __spreadProps(__spreadValues({}, menuScope), { virtualRef })),
      /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
        Primitive.span,
        __spreadProps(__spreadValues({
          "data-state": context.open ? "open" : "closed",
          "data-disabled": disabled ? "" : void 0
        }, triggerProps), {
          ref: forwardedRef,
          style: __spreadValues({ WebkitTouchCallout: "none" }, props2.style),
          onContextMenu: disabled ? props2.onContextMenu : composeEventHandlers(props2.onContextMenu, (event) => {
            clearLongPress();
            handleOpen(event);
            event.preventDefault();
          }),
          onPointerDown: disabled ? props2.onPointerDown : composeEventHandlers(
            props2.onPointerDown,
            whenTouchOrPen((event) => {
              clearLongPress();
              longPressTimerRef.current = window.setTimeout(() => handleOpen(event), 700);
            })
          ),
          onPointerMove: disabled ? props2.onPointerMove : composeEventHandlers(props2.onPointerMove, whenTouchOrPen(clearLongPress)),
          onPointerCancel: disabled ? props2.onPointerCancel : composeEventHandlers(props2.onPointerCancel, whenTouchOrPen(clearLongPress)),
          onPointerUp: disabled ? props2.onPointerUp : composeEventHandlers(props2.onPointerUp, whenTouchOrPen(clearLongPress))
        })
      )
    ] });
  }
);
ContextMenuTrigger.displayName = TRIGGER_NAME7;
var PORTAL_NAME8 = "ContextMenuPortal";
var ContextMenuPortal = (props2) => {
  const _a = props2, { __scopeContextMenu } = _a, portalProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Portal6, __spreadValues(__spreadValues({}, menuScope), portalProps));
};
ContextMenuPortal.displayName = PORTAL_NAME8;
var CONTENT_NAME9 = "ContextMenuContent";
var ContextMenuContent = React97.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeContextMenu } = _a, contentProps = __objRest(_a, ["__scopeContextMenu"]);
    const context = useContextMenuContext(CONTENT_NAME9, __scopeContextMenu);
    const menuScope = useMenuScope(__scopeContextMenu);
    const hasInteractedOutsideRef = React97.useRef(false);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
      Content24,
      __spreadProps(__spreadValues(__spreadValues({}, menuScope), contentProps), {
        ref: forwardedRef,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (event) => {
          var _a2;
          (_a2 = props2.onCloseAutoFocus) == null ? void 0 : _a2.call(props2, event);
          if (!event.defaultPrevented && hasInteractedOutsideRef.current) {
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2;
          (_a2 = props2.onInteractOutside) == null ? void 0 : _a2.call(props2, event);
          if (!event.defaultPrevented && !context.modal)
            hasInteractedOutsideRef.current = true;
        },
        style: __spreadValues(__spreadValues({}, props2.style), {
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        })
      })
    );
  }
);
ContextMenuContent.displayName = CONTENT_NAME9;
var GROUP_NAME4 = "ContextMenuGroup";
var ContextMenuGroup = React97.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeContextMenu } = _a, groupProps = __objRest(_a, ["__scopeContextMenu"]);
    const menuScope = useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Group2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), groupProps), { ref: forwardedRef }));
  }
);
ContextMenuGroup.displayName = GROUP_NAME4;
var LABEL_NAME3 = "ContextMenuLabel";
var ContextMenuLabel = React97.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeContextMenu } = _a, labelProps = __objRest(_a, ["__scopeContextMenu"]);
    const menuScope = useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Label2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), labelProps), { ref: forwardedRef }));
  }
);
ContextMenuLabel.displayName = LABEL_NAME3;
var ITEM_NAME5 = "ContextMenuItem";
var ContextMenuItem = React97.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeContextMenu } = _a, itemProps = __objRest(_a, ["__scopeContextMenu"]);
    const menuScope = useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Item22, __spreadProps(__spreadValues(__spreadValues({}, menuScope), itemProps), { ref: forwardedRef }));
  }
);
ContextMenuItem.displayName = ITEM_NAME5;
var CHECKBOX_ITEM_NAME2 = "ContextMenuCheckboxItem";
var ContextMenuCheckboxItem = React97.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeContextMenu } = _a, checkboxItemProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(CheckboxItem, __spreadProps(__spreadValues(__spreadValues({}, menuScope), checkboxItemProps), { ref: forwardedRef }));
});
ContextMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "ContextMenuRadioGroup";
var ContextMenuRadioGroup = React97.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeContextMenu } = _a, radioGroupProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(RadioGroup, __spreadProps(__spreadValues(__spreadValues({}, menuScope), radioGroupProps), { ref: forwardedRef }));
});
ContextMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "ContextMenuRadioItem";
var ContextMenuRadioItem = React97.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeContextMenu } = _a, radioItemProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(RadioItem, __spreadProps(__spreadValues(__spreadValues({}, menuScope), radioItemProps), { ref: forwardedRef }));
});
ContextMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME2 = "ContextMenuItemIndicator";
var ContextMenuItemIndicator = React97.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeContextMenu } = _a, itemIndicatorProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(ItemIndicator2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), itemIndicatorProps), { ref: forwardedRef }));
});
ContextMenuItemIndicator.displayName = INDICATOR_NAME2;
var SEPARATOR_NAME3 = "ContextMenuSeparator";
var ContextMenuSeparator = React97.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeContextMenu } = _a, separatorProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Separator2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), separatorProps), { ref: forwardedRef }));
});
ContextMenuSeparator.displayName = SEPARATOR_NAME3;
var ARROW_NAME4 = "ContextMenuArrow";
var ContextMenuArrow = React97.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeContextMenu } = _a, arrowProps = __objRest(_a, ["__scopeContextMenu"]);
    const menuScope = useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Arrow22, __spreadProps(__spreadValues(__spreadValues({}, menuScope), arrowProps), { ref: forwardedRef }));
  }
);
ContextMenuArrow.displayName = ARROW_NAME4;
var SUB_NAME2 = "ContextMenuSub";
var ContextMenuSub = (props2) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props2;
  const menuScope = useMenuScope(__scopeContextMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Sub, __spreadProps(__spreadValues({}, menuScope), { open, onOpenChange: setOpen, children }));
};
ContextMenuSub.displayName = SUB_NAME2;
var SUB_TRIGGER_NAME2 = "ContextMenuSubTrigger";
var ContextMenuSubTrigger = React97.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeContextMenu } = _a, triggerItemProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(SubTrigger, __spreadProps(__spreadValues(__spreadValues({}, menuScope), triggerItemProps), { ref: forwardedRef }));
});
ContextMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "ContextMenuSubContent";
var ContextMenuSubContent = React97.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeContextMenu } = _a, subContentProps = __objRest(_a, ["__scopeContextMenu"]);
  const menuScope = useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
    SubContent,
    __spreadProps(__spreadValues(__spreadValues({}, menuScope), subContentProps), {
      ref: forwardedRef,
      style: __spreadValues(__spreadValues({}, props2.style), {
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      })
    })
  );
});
ContextMenuSubContent.displayName = SUB_CONTENT_NAME2;
function whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
}
var Root25 = ContextMenu;
var Trigger6 = ContextMenuTrigger;
var Portal23 = ContextMenuPortal;
var Content25 = ContextMenuContent;
var Group22 = ContextMenuGroup;
var Label22 = ContextMenuLabel;
var Item23 = ContextMenuItem;
var CheckboxItem2 = ContextMenuCheckboxItem;
var RadioGroup2 = ContextMenuRadioGroup;
var RadioItem2 = ContextMenuRadioItem;
var ItemIndicator22 = ContextMenuItemIndicator;
var Separator22 = ContextMenuSeparator;
var Sub2 = ContextMenuSub;
var SubTrigger2 = ContextMenuSubTrigger;
var SubContent2 = ContextMenuSubContent;

// src/components/context-menu.tsx
var import_utils23 = require("@nubras/utils");
var import_jsx_runtime45 = require("react/jsx-runtime");
var ContextMenu2 = Root25;
var ContextMenuTrigger2 = Trigger6;
var ContextMenuGroup2 = Group22;
var ContextMenuPortal2 = Portal23;
var ContextMenuSub2 = Sub2;
var ContextMenuRadioGroup2 = RadioGroup2;
var ContextMenuSubTrigger2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset, children } = _b, props2 = __objRest(_b, ["className", "inset", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(
    SubTrigger2,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        inset && "pl-8",
        className
      )
    }, props2), {
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(ChevronRight, { className: "ml-auto h-4 w-4" })
      ]
    })
  );
});
ContextMenuSubTrigger2.displayName = SubTrigger2.displayName;
var ContextMenuSubContent2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    SubContent2,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  );
});
ContextMenuSubContent2.displayName = SubContent2.displayName;
var ContextMenuContent2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(Portal23, { children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    Content25,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  ) });
});
ContextMenuContent2.displayName = Content25.displayName;
var ContextMenuItem2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset } = _b, props2 = __objRest(_b, ["className", "inset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    Item23,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        inset && "pl-8",
        className
      )
    }, props2)
  );
});
ContextMenuItem2.displayName = Item23.displayName;
var ContextMenuCheckboxItem2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className, children, checked } = _b, props2 = __objRest(_b, ["className", "children", "checked"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(
    CheckboxItem2,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      ),
      checked
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(ItemIndicator22, { children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(Check, { className: "h-4 w-4" }) }) }),
        children
      ]
    })
  );
});
ContextMenuCheckboxItem2.displayName = CheckboxItem2.displayName;
var ContextMenuRadioItem2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(
    RadioItem2,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(ItemIndicator22, { children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(Circle, { className: "h-2 w-2 fill-current" }) }) }),
        children
      ]
    })
  );
});
ContextMenuRadioItem2.displayName = RadioItem2.displayName;
var ContextMenuLabel2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset } = _b, props2 = __objRest(_b, ["className", "inset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    Label22,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)(
        "px-2 py-1.5 text-sm font-semibold text-foreground",
        inset && "pl-8",
        className
      )
    }, props2)
  );
});
ContextMenuLabel2.displayName = Label22.displayName;
var ContextMenuSeparator2 = React98.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    Separator22,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils23.cn)("-mx-1 my-1 h-px bg-border", className)
    }, props2)
  );
});
ContextMenuSeparator2.displayName = Separator22.displayName;
var ContextMenuShortcut = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    "span",
    __spreadValues({
      className: (0, import_utils23.cn)(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )
    }, props2)
  );
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

// src/components/date-picker.tsx
var import_utils26 = require("@nubras/utils");

// src/components/popover.tsx
var React100 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-popover@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1._w5ju2mbjjeybqlo7kn64kpzggi/node_modules/@radix-ui/react-popover/dist/index.mjs
var React99 = __toESM(require("react"), 1);
var import_jsx_runtime46 = require("react/jsx-runtime");
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope3 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props2) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props2;
  const popperScope = usePopperScope3(__scopePopover);
  const triggerRef = React99.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React99.useState(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Root23, __spreadProps(__spreadValues({}, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React99.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React99.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React99.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) }));
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME3 = "PopoverAnchor";
var PopoverAnchor = React99.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopePopover } = _a, anchorProps = __objRest(_a, ["__scopePopover"]);
    const context = usePopoverContext(ANCHOR_NAME3, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React99.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Anchor, __spreadProps(__spreadValues(__spreadValues({}, popperScope), anchorProps), { ref: forwardedRef }));
  }
);
PopoverAnchor.displayName = ANCHOR_NAME3;
var TRIGGER_NAME8 = "PopoverTrigger";
var PopoverTrigger = React99.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopePopover } = _a, triggerProps = __objRest(_a, ["__scopePopover"]);
    const context = usePopoverContext(TRIGGER_NAME8, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState6(context.open)
      }, triggerProps), {
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props2.onClick, context.onOpenToggle)
      })
    );
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Anchor, __spreadProps(__spreadValues({ asChild: true }, popperScope), { children: trigger }));
  }
);
PopoverTrigger.displayName = TRIGGER_NAME8;
var PORTAL_NAME9 = "PopoverPortal";
var [PortalProvider4, usePortalContext4] = createPopoverContext(PORTAL_NAME9, {
  forceMount: void 0
});
var PopoverPortal = (props2) => {
  const { __scopePopover, forceMount, children, container } = props2;
  const context = usePopoverContext(PORTAL_NAME9, __scopePopover);
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(PortalProvider4, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Portal, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME9;
var CONTENT_NAME10 = "PopoverContent";
var PopoverContent = React99.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext4(CONTENT_NAME10, props2.__scopePopover);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, contentProps = __objRest(_a, ["forceMount"]);
    const context = usePopoverContext(CONTENT_NAME10, props2.__scopePopover);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(PopoverContentModal, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) : /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(PopoverContentNonModal, __spreadProps(__spreadValues({}, contentProps), { ref: forwardedRef })) });
  }
);
PopoverContent.displayName = CONTENT_NAME10;
var PopoverContentModal = React99.forwardRef(
  (props2, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME10, props2.__scopePopover);
    const contentRef = React99.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React99.useRef(false);
    React99.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      PopoverContentImpl,
      __spreadProps(__spreadValues({}, props2), {
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props2.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          if (!isRightClickOutsideRef.current)
            (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props2.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props2.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      })
    ) });
  }
);
var PopoverContentNonModal = React99.forwardRef(
  (props2, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME10, props2.__scopePopover);
    const hasInteractedOutsideRef = React99.useRef(false);
    const hasPointerDownOutsideRef = React99.useRef(false);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      PopoverContentImpl,
      __spreadProps(__spreadValues({}, props2), {
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props2.onCloseAutoFocus) == null ? void 0 : _a.call(props2, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props2.onInteractOutside) == null ? void 0 : _a.call(props2, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      })
    );
  }
);
var PopoverContentImpl = React99.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside
    } = _a, contentProps = __objRest(_a, [
      "__scopePopover",
      "trapFocus",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "disableOutsidePointerEvents",
      "onEscapeKeyDown",
      "onPointerDownOutside",
      "onFocusOutside",
      "onInteractOutside"
    ]);
    const context = usePopoverContext(CONTENT_NAME10, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
              Content4,
              __spreadProps(__spreadValues(__spreadValues({
                "data-state": getState6(context.open),
                role: "dialog",
                id: context.contentId
              }, popperScope), contentProps), {
                ref: forwardedRef,
                style: __spreadValues(__spreadValues({}, contentProps.style), {
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                })
              })
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME3 = "PopoverClose";
var PopoverClose = React99.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopePopover } = _a, closeProps = __objRest(_a, ["__scopePopover"]);
    const context = usePopoverContext(CLOSE_NAME3, __scopePopover);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button"
      }, closeProps), {
        ref: forwardedRef,
        onClick: composeEventHandlers(props2.onClick, () => context.onOpenChange(false))
      })
    );
  }
);
PopoverClose.displayName = CLOSE_NAME3;
var ARROW_NAME5 = "PopoverArrow";
var PopoverArrow = React99.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopePopover } = _a, arrowProps = __objRest(_a, ["__scopePopover"]);
    const popperScope = usePopperScope3(__scopePopover);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(Arrow2, __spreadProps(__spreadValues(__spreadValues({}, popperScope), arrowProps), { ref: forwardedRef }));
  }
);
PopoverArrow.displayName = ARROW_NAME5;
function getState6(open) {
  return open ? "open" : "closed";
}
var Root26 = Popover;
var Trigger7 = PopoverTrigger;
var Portal7 = PopoverPortal;
var Content26 = PopoverContent;

// src/components/popover.tsx
var import_utils24 = require("@nubras/utils");
var import_jsx_runtime47 = require("react/jsx-runtime");
var Popover2 = Root26;
var PopoverTrigger2 = Trigger7;
var PopoverContent2 = React100.forwardRef((_a, ref2) => {
  var _b = _a, { className, align = "center", sideOffset = 4 } = _b, props2 = __objRest(_b, ["className", "align", "sideOffset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(Portal7, { children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
    Content26,
    __spreadValues({
      ref: ref2,
      align,
      sideOffset,
      className: (0, import_utils24.cn)(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  ) });
});
PopoverContent2.displayName = Content26.displayName;

// src/components/input.tsx
var React101 = __toESM(require("react"));
var import_utils25 = require("@nubras/utils");
var import_jsx_runtime48 = require("react/jsx-runtime");
var Input = React101.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className, type } = _b, props2 = __objRest(_b, ["className", "type"]);
    return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
      "input",
      __spreadValues({
        type,
        className: (0, import_utils25.cn)(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        ),
        ref: ref2
      }, props2)
    );
  }
);
Input.displayName = "Input";

// src/components/date-picker.tsx
var import_jsx_runtime49 = require("react/jsx-runtime");
function DatePicker(_a) {
  var _b = _a, { className, date, setDate } = _b, props2 = __objRest(_b, ["className", "date", "setDate"]);
  const handleChange = (e) => {
    const newDate = e.target.value ? new Date(e.target.value) : null;
    if (setDate) {
      setDate(newDate);
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)("div", { className: (0, import_utils26.cn)("relative", className), children: [
    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
      Input,
      __spreadValues({
        type: "date",
        className: "pl-10",
        value: date ? date.toISOString().split("T")[0] : "",
        onChange: handleChange
      }, props2)
    ),
    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(Calendar, { className: "absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" })
  ] });
}
function DatePickerWithRange({
  className,
  date,
  setDate
}) {
  return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("div", { className: (0, import_utils26.cn)("grid gap-2", className), children: /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(Popover2, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(PopoverTrigger2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(
      Button,
      {
        id: "date",
        variant: "outline",
        className: (0, import_utils26.cn)("w-full justify-start text-left font-normal", !date && "text-muted-foreground"),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(Calendar, { className: "mr-2 h-4 w-4" }),
          (date == null ? void 0 : date.from) ? date.to ? /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: [
            format(date.from, "LLL dd, y"),
            " - ",
            format(date.to, "LLL dd, y")
          ] }) : format(date.from, "LLL dd, y") : /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("span", { children: "Pick a date range" })
        ]
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(PopoverContent2, { className: "w-auto p-0", align: "start", children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
      Calendar2,
      {
        initialFocus: true,
        mode: "range",
        defaultMonth: date == null ? void 0 : date.from,
        selected: date,
        onSelect: setDate,
        numberOfMonths: 2
      }
    ) })
  ] }) });
}

// src/components/drawer.tsx
var React103 = __toESM(require("react"));

// ../../node_modules/.pnpm/vaul@0.9.9_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/vaul/dist/index.mjs
var React102 = __toESM(require("react"), 1);
var import_react40 = __toESM(require("react"), 1);
function __insertCSS(code) {
  if (!code || typeof document == "undefined")
    return;
  let head = document.head || document.getElementsByTagName("head")[0];
  let style2 = document.createElement("style");
  style2.type = "text/css";
  head.appendChild(style2);
  style2.styleSheet ? style2.styleSheet.cssText = code : style2.appendChild(document.createTextNode(code));
}
var DrawerContext = import_react40.default.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: false,
  isOpen: false,
  isDragging: false,
  keyboardIsOpen: {
    current: false
  },
  snapPointsOffset: null,
  snapPoints: null,
  handleOnly: false,
  modal: false,
  shouldFade: false,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  closeDrawer: () => {
  },
  direction: "bottom",
  shouldScaleBackground: false,
  setBackgroundColorOnScale: true,
  noBodyStyles: false,
  container: null,
  autoFocus: false
});
var useDrawerContext = () => {
  const context = import_react40.default.useContext(DrawerContext);
  if (!context) {
    throw new Error("useDrawerContext must be used within a Drawer.Root");
  }
  return context;
};
__insertCSS("[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(\n[data-state=closed]\n){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,100%,0)}}@keyframes slideFromTop{from{transform:translate3d(0,-100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,-100%,0)}}@keyframes slideFromLeft{from{transform:translate3d(-100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(-100%,0,0)}}@keyframes slideFromRight{from{transform:translate3d(100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(100%,0,0)}}");
var KEYBOARD_BUFFER = 24;
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react40.useLayoutEffect : import_react40.useEffect;
function chain$1(...callbacks) {
  return (...args) => {
    for (let callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function isMac() {
  return testPlatform(/^Mac/);
}
function isIPhone() {
  return testPlatform(/^iPhone/);
}
function isSafari() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function isIPad() {
  return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function testPlatform(re3) {
  return typeof window !== "undefined" && window.navigator != null ? re3.test(window.navigator.platform) : void 0;
}
var visualViewport = typeof document !== "undefined" && window.visualViewport;
function isScrollable(node) {
  let style2 = window.getComputedStyle(node);
  return /(auto|scroll)/.test(style2.overflow + style2.overflowX + style2.overflowY);
}
function getScrollParent(node) {
  if (isScrollable(node)) {
    node = node.parentElement;
  }
  while (node && !isScrollable(node)) {
    node = node.parentElement;
  }
  return node || document.scrollingElement || document.documentElement;
}
var nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
var preventScrollCount = 0;
var restore;
function usePreventScroll(options = {}) {
  let { isDisabled } = options;
  useIsomorphicLayoutEffect2(() => {
    if (isDisabled) {
      return;
    }
    preventScrollCount++;
    if (preventScrollCount === 1) {
      if (isIOS()) {
        restore = preventScrollMobileSafari();
      }
    }
    return () => {
      preventScrollCount--;
      if (preventScrollCount === 0) {
        restore == null ? void 0 : restore();
      }
    };
  }, [
    isDisabled
  ]);
}
function preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;
  let onTouchStart = (e) => {
    scrollable = getScrollParent(e.target);
    if (scrollable === document.documentElement && scrollable === document.body) {
      return;
    }
    lastY = e.changedTouches[0].pageY;
  };
  let onTouchMove = (e) => {
    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {
      e.preventDefault();
      return;
    }
    let y = e.changedTouches[0].pageY;
    let scrollTop = scrollable.scrollTop;
    let bottom = scrollable.scrollHeight - scrollable.clientHeight;
    if (bottom === 0) {
      return;
    }
    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {
      e.preventDefault();
    }
    lastY = y;
  };
  let onTouchEnd = (e) => {
    let target = e.target;
    if (isInput(target) && target !== document.activeElement) {
      e.preventDefault();
      target.style.transform = "translateY(-2000px)";
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = "";
      });
    }
  };
  let onFocus = (e) => {
    let target = e.target;
    if (isInput(target)) {
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";
        if (visualViewport) {
          if (visualViewport.height < window.innerHeight) {
            requestAnimationFrame(() => {
              scrollIntoView(target);
            });
          } else {
            visualViewport.addEventListener("resize", () => scrollIntoView(target), {
              once: true
            });
          }
        }
      });
    }
  };
  let onWindowScroll = () => {
    window.scrollTo(0, 0);
  };
  let scrollX = window.pageXOffset;
  let scrollY = window.pageYOffset;
  let restoreStyles = chain$1(setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let removeEvents = chain$1(addEvent(document, "touchstart", onTouchStart, {
    passive: false,
    capture: true
  }), addEvent(document, "touchmove", onTouchMove, {
    passive: false,
    capture: true
  }), addEvent(document, "touchend", onTouchEnd, {
    passive: false,
    capture: true
  }), addEvent(document, "focus", onFocus, true), addEvent(window, "scroll", onWindowScroll));
  return () => {
    restoreStyles();
    removeEvents();
    window.scrollTo(scrollX, scrollY);
  };
}
function setStyle(element, style2, value) {
  let cur = element.style[style2];
  element.style[style2] = value;
  return () => {
    element.style[style2] = cur;
  };
}
function addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}
function scrollIntoView(target) {
  let root = document.scrollingElement || document.documentElement;
  while (target && target !== root) {
    let scrollable = getScrollParent(target);
    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
      let scrollableTop = scrollable.getBoundingClientRect().top;
      let targetTop = target.getBoundingClientRect().top;
      let targetBottom = target.getBoundingClientRect().bottom;
      const keyboardHeight = scrollable.getBoundingClientRect().bottom + KEYBOARD_BUFFER;
      if (targetBottom > keyboardHeight) {
        scrollable.scrollTop += targetTop - scrollableTop;
      }
    }
    target = scrollable.parentElement;
  }
}
function isInput(target) {
  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}
function setRef3(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs3(...refs) {
  return (node) => refs.forEach((ref2) => setRef3(ref2, node));
}
function useComposedRefs3(...refs) {
  return React102.useCallback(composeRefs3(...refs), refs);
}
var cache = /* @__PURE__ */ new WeakMap();
function set(el, styles, ignoreCache = false) {
  if (!el || !(el instanceof HTMLElement))
    return;
  let originalStyles = {};
  Object.entries(styles).forEach(([key, value]) => {
    if (key.startsWith("--")) {
      el.style.setProperty(key, value);
      return;
    }
    originalStyles[key] = el.style[key];
    el.style[key] = value;
  });
  if (ignoreCache)
    return;
  cache.set(el, originalStyles);
}
function reset(el, prop) {
  if (!el || !(el instanceof HTMLElement))
    return;
  let originalStyles = cache.get(el);
  if (!originalStyles) {
    return;
  }
  {
    el.style[prop] = originalStyles[prop];
  }
}
var isVertical = (direction) => {
  switch (direction) {
    case "top":
    case "bottom":
      return true;
    case "left":
    case "right":
      return false;
    default:
      return direction;
  }
};
function getTranslate(element, direction) {
  if (!element) {
    return null;
  }
  const style2 = window.getComputedStyle(element);
  const transform = (
    // @ts-ignore
    style2.transform || style2.webkitTransform || style2.mozTransform
  );
  let mat = transform.match(/^matrix3d\((.+)\)$/);
  if (mat) {
    return parseFloat(mat[1].split(", ")[isVertical(direction) ? 13 : 12]);
  }
  mat = transform.match(/^matrix\((.+)\)$/);
  return mat ? parseFloat(mat[1].split(", ")[isVertical(direction) ? 5 : 4]) : null;
}
function dampenValue(v2) {
  return 8 * (Math.log(v2 + 1) - 2);
}
function assignStyle(element, style2) {
  if (!element)
    return () => {
    };
  const prevStyle = element.style.cssText;
  Object.assign(element.style, style2);
  return () => {
    element.style.cssText = prevStyle;
  };
}
function chain(...fns) {
  return (...args) => {
    for (const fn of fns) {
      if (typeof fn === "function") {
        fn(...args);
      }
    }
  };
}
var TRANSITIONS = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
};
var VELOCITY_THRESHOLD = 0.4;
var CLOSE_THRESHOLD = 0.25;
var SCROLL_LOCK_TIMEOUT = 100;
var BORDER_RADIUS = 8;
var NESTED_DISPLACEMENT = 16;
var WINDOW_TOP_OFFSET = 26;
var DRAG_CLASS = "vaul-dragging";
function useCallbackRef4(callback) {
  const callbackRef = import_react40.default.useRef(callback);
  import_react40.default.useEffect(() => {
    callbackRef.current = callback;
  });
  return import_react40.default.useMemo(() => (...args) => callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);
}
function useUncontrolledState3({ defaultProp, onChange }) {
  const uncontrolledState = import_react40.default.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = import_react40.default.useRef(value);
  const handleChange = useCallbackRef4(onChange);
  import_react40.default.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
function useControllableState3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState3({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef4(onChange);
  const setValue = import_react40.default.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value2 !== prop)
        handleChange(value2);
    } else {
      setUncontrolledProp(nextValue);
    }
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value,
    setValue
  ];
}
function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints, drawerRef, overlayRef, fadeFromIndex, onSnapPointChange, direction = "bottom", container, snapToSequentialPoint }) {
  const [activeSnapPoint, setActiveSnapPoint] = useControllableState3({
    prop: activeSnapPointProp,
    defaultProp: snapPoints == null ? void 0 : snapPoints[0],
    onChange: setActiveSnapPointProp
  });
  const [windowDimensions, setWindowDimensions] = import_react40.default.useState(typeof window !== "undefined" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  import_react40.default.useEffect(() => {
    function onResize() {
      setWindowDimensions({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);
  const isLastSnapPoint = import_react40.default.useMemo(() => activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [
    snapPoints,
    activeSnapPoint
  ]);
  const activeSnapPointIndex = import_react40.default.useMemo(() => snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint) => snapPoint === activeSnapPoint), [
    snapPoints,
    activeSnapPoint
  ]);
  const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;
  const snapPointsOffset = import_react40.default.useMemo(() => {
    const containerSize = container ? {
      width: container.getBoundingClientRect().width,
      height: container.getBoundingClientRect().height
    } : typeof window !== "undefined" ? {
      width: window.innerWidth,
      height: window.innerHeight
    } : {
      width: 0,
      height: 0
    };
    var _snapPoints_map;
    return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map((snapPoint) => {
      const isPx = typeof snapPoint === "string";
      let snapPointAsNumber = 0;
      if (isPx) {
        snapPointAsNumber = parseInt(snapPoint, 10);
      }
      if (isVertical(direction)) {
        const height = isPx ? snapPointAsNumber : windowDimensions ? snapPoint * containerSize.height : 0;
        if (windowDimensions) {
          return direction === "bottom" ? containerSize.height - height : -containerSize.height + height;
        }
        return height;
      }
      const width = isPx ? snapPointAsNumber : windowDimensions ? snapPoint * containerSize.width : 0;
      if (windowDimensions) {
        return direction === "right" ? containerSize.width - width : -containerSize.width + width;
      }
      return width;
    })) != null ? _snapPoints_map : [];
  }, [
    snapPoints,
    windowDimensions,
    container
  ]);
  const activeSnapPointOffset = import_react40.default.useMemo(() => activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [
    snapPointsOffset,
    activeSnapPointIndex
  ]);
  const snapToPoint = import_react40.default.useCallback((dimension) => {
    var _snapPointsOffset_findIndex;
    const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex((snapPointDim) => snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;
    onSnapPointChange(newSnapPointIndex);
    set(drawerRef.current, {
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      transform: isVertical(direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`
    });
    if (snapPointsOffset && newSnapPointIndex !== snapPointsOffset.length - 1 && newSnapPointIndex !== fadeFromIndex && newSnapPointIndex < fadeFromIndex) {
      set(overlayRef.current, {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        opacity: "0"
      });
    } else {
      set(overlayRef.current, {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        opacity: "1"
      });
    }
    setActiveSnapPoint(snapPoints == null ? void 0 : snapPoints[Math.max(newSnapPointIndex, 0)]);
  }, [
    drawerRef.current,
    snapPoints,
    snapPointsOffset,
    fadeFromIndex,
    overlayRef,
    setActiveSnapPoint
  ]);
  import_react40.default.useEffect(() => {
    if (activeSnapPoint || activeSnapPointProp) {
      var _snapPoints_findIndex;
      const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint) => snapPoint === activeSnapPointProp || snapPoint === activeSnapPoint)) != null ? _snapPoints_findIndex : -1;
      if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === "number") {
        snapToPoint(snapPointsOffset[newIndex]);
      }
    }
  }, [
    activeSnapPoint,
    activeSnapPointProp,
    snapPoints,
    snapPointsOffset,
    snapToPoint
  ]);
  function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {
    if (fadeFromIndex === void 0)
      return;
    const currentPosition = direction === "bottom" || direction === "right" ? (activeSnapPointOffset != null ? activeSnapPointOffset : 0) - draggedDistance : (activeSnapPointOffset != null ? activeSnapPointOffset : 0) + draggedDistance;
    const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;
    const isFirst = activeSnapPointIndex === 0;
    const hasDraggedUp = draggedDistance > 0;
    if (isOverlaySnapPoint) {
      set(overlayRef.current, {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    }
    if (!snapToSequentialPoint && velocity > 2 && !hasDraggedUp) {
      if (dismissible)
        closeDrawer();
      else
        snapToPoint(snapPointsOffset[0]);
      return;
    }
    if (!snapToSequentialPoint && velocity > 2 && hasDraggedUp && snapPointsOffset && snapPoints) {
      snapToPoint(snapPointsOffset[snapPoints.length - 1]);
      return;
    }
    const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr) => {
      if (typeof prev !== "number" || typeof curr !== "number")
        return prev;
      return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;
    });
    const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;
    if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {
      const dragDirection = hasDraggedUp ? 1 : -1;
      if (dragDirection > 0 && isLastSnapPoint) {
        snapToPoint(snapPointsOffset[snapPoints.length - 1]);
        return;
      }
      if (isFirst && dragDirection < 0 && dismissible) {
        closeDrawer();
      }
      if (activeSnapPointIndex === null)
        return;
      snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);
      return;
    }
    snapToPoint(closestSnapPoint);
  }
  function onDrag({ draggedDistance }) {
    if (activeSnapPointOffset === null)
      return;
    const newValue = direction === "bottom" || direction === "right" ? activeSnapPointOffset - draggedDistance : activeSnapPointOffset + draggedDistance;
    if ((direction === "bottom" || direction === "right") && newValue < snapPointsOffset[snapPointsOffset.length - 1]) {
      return;
    }
    if ((direction === "top" || direction === "left") && newValue > snapPointsOffset[snapPointsOffset.length - 1]) {
      return;
    }
    set(drawerRef.current, {
      transform: isVertical(direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`
    });
  }
  function getPercentageDragged(absDraggedDistance, isDraggingDown) {
    if (!snapPoints || typeof activeSnapPointIndex !== "number" || !snapPointsOffset || fadeFromIndex === void 0)
      return null;
    const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;
    const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex;
    if (isOverlaySnapPointOrHigher && isDraggingDown) {
      return 0;
    }
    if (isOverlaySnapPoint && !isDraggingDown)
      return 1;
    if (!shouldFade && !isOverlaySnapPoint)
      return null;
    const targetSnapPointIndex = isOverlaySnapPoint ? activeSnapPointIndex + 1 : activeSnapPointIndex - 1;
    const snapPointDistance = isOverlaySnapPoint ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1] : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];
    const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);
    if (isOverlaySnapPoint) {
      return 1 - percentageDragged;
    } else {
      return percentageDragged;
    }
  }
  return {
    isLastSnapPoint,
    activeSnapPoint,
    shouldFade,
    getPercentageDragged,
    setActiveSnapPoint,
    activeSnapPointIndex,
    onRelease,
    onDrag,
    snapPointsOffset
  };
}
var noop = () => () => {
};
function useScaleBackground() {
  const { direction, isOpen, shouldScaleBackground, setBackgroundColorOnScale, noBodyStyles } = useDrawerContext();
  const timeoutIdRef = import_react40.default.useRef(null);
  const initialBackgroundColor = (0, import_react40.useMemo)(() => document.body.style.backgroundColor, []);
  function getScale2() {
    return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;
  }
  import_react40.default.useEffect(() => {
    if (isOpen && shouldScaleBackground) {
      if (timeoutIdRef.current)
        clearTimeout(timeoutIdRef.current);
      const wrapper = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!wrapper)
        return;
      chain(setBackgroundColorOnScale && !noBodyStyles ? assignStyle(document.body, {
        background: "black"
      }) : noop, assignStyle(wrapper, {
        transformOrigin: isVertical(direction) ? "top" : "left",
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      }));
      const wrapperStylesCleanup = assignStyle(wrapper, __spreadValues({
        borderRadius: `${BORDER_RADIUS}px`,
        overflow: "hidden"
      }, isVertical(direction) ? {
        transform: `scale(${getScale2()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
      } : {
        transform: `scale(${getScale2()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
      }));
      return () => {
        wrapperStylesCleanup();
        timeoutIdRef.current = window.setTimeout(() => {
          if (initialBackgroundColor) {
            document.body.style.background = initialBackgroundColor;
          } else {
            document.body.style.removeProperty("background");
          }
        }, TRANSITIONS.DURATION * 1e3);
      };
    }
  }, [
    isOpen,
    shouldScaleBackground,
    initialBackgroundColor
  ]);
}
var previousBodyPosition = null;
function usePositionFixed({ isOpen, modal, nested, hasBeenOpened, preventScrollRestoration, noBodyStyles }) {
  const [activeUrl, setActiveUrl] = import_react40.default.useState(() => typeof window !== "undefined" ? window.location.href : "");
  const scrollPos = import_react40.default.useRef(0);
  const setPositionFixed = import_react40.default.useCallback(() => {
    if (!isSafari())
      return;
    if (previousBodyPosition === null && isOpen && !noBodyStyles) {
      previousBodyPosition = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX, innerHeight } = window;
      document.body.style.setProperty("position", "fixed", "important");
      Object.assign(document.body.style, {
        top: `${-scrollPos.current}px`,
        left: `${-scrollX}px`,
        right: "0px",
        height: "auto"
      });
      window.setTimeout(() => window.requestAnimationFrame(() => {
        const bottomBarHeight = innerHeight - window.innerHeight;
        if (bottomBarHeight && scrollPos.current >= innerHeight) {
          document.body.style.top = `${-(scrollPos.current + bottomBarHeight)}px`;
        }
      }), 300);
    }
  }, [
    isOpen
  ]);
  const restorePositionSetting = import_react40.default.useCallback(() => {
    if (!isSafari())
      return;
    if (previousBodyPosition !== null && !noBodyStyles) {
      const y = -parseInt(document.body.style.top, 10);
      const x2 = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, previousBodyPosition);
      window.requestAnimationFrame(() => {
        if (preventScrollRestoration && activeUrl !== window.location.href) {
          setActiveUrl(window.location.href);
          return;
        }
        window.scrollTo(x2, y);
      });
      previousBodyPosition = null;
    }
  }, [
    activeUrl
  ]);
  import_react40.default.useEffect(() => {
    function onScroll() {
      scrollPos.current = window.scrollY;
    }
    onScroll();
    window.addEventListener("scroll", onScroll);
    return () => {
      window.removeEventListener("scroll", onScroll);
    };
  }, []);
  import_react40.default.useEffect(() => {
    if (nested || !hasBeenOpened)
      return;
    if (isOpen) {
      const isStandalone = window.matchMedia("(display-mode: standalone)").matches;
      !isStandalone && setPositionFixed();
      if (!modal) {
        window.setTimeout(() => {
          restorePositionSetting();
        }, 500);
      }
    } else {
      restorePositionSetting();
    }
  }, [
    isOpen,
    hasBeenOpened,
    activeUrl,
    modal,
    nested,
    setPositionFixed,
    restorePositionSetting
  ]);
  return {
    restorePositionSetting
  };
}
function Root13({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRelease: onReleaseProp, snapPoints, shouldScaleBackground = false, setBackgroundColorOnScale = true, closeThreshold = CLOSE_THRESHOLD, scrollLockTimeout = SCROLL_LOCK_TIMEOUT, dismissible = true, handleOnly = false, fadeFromIndex = snapPoints && snapPoints.length - 1, activeSnapPoint: activeSnapPointProp, setActiveSnapPoint: setActiveSnapPointProp, fixed, modal = true, onClose, nested, noBodyStyles, direction = "bottom", defaultOpen = false, disablePreventScroll = true, snapToSequentialPoint = false, preventScrollRestoration = false, repositionInputs = true, onAnimationEnd, container, autoFocus = false }) {
  var _drawerRef_current, _drawerRef_current1;
  const [isOpen = false, setIsOpen] = useControllableState3({
    defaultProp: defaultOpen,
    prop: openProp,
    onChange: (o2) => {
      onOpenChange == null ? void 0 : onOpenChange(o2);
      if (!o2 && !nested) {
        restorePositionSetting();
      }
      setTimeout(() => {
        onAnimationEnd == null ? void 0 : onAnimationEnd(o2);
      }, TRANSITIONS.DURATION * 1e3);
      if (o2 && !modal) {
        if (typeof window !== "undefined") {
          window.requestAnimationFrame(() => {
            document.body.style.pointerEvents = "auto";
          });
        }
      }
      if (!o2) {
        document.body.style.pointerEvents = "auto";
      }
    }
  });
  const [hasBeenOpened, setHasBeenOpened] = import_react40.default.useState(false);
  const [isDragging2, setIsDragging] = import_react40.default.useState(false);
  const [justReleased, setJustReleased] = import_react40.default.useState(false);
  const overlayRef = import_react40.default.useRef(null);
  const openTime = import_react40.default.useRef(null);
  const dragStartTime = import_react40.default.useRef(null);
  const dragEndTime = import_react40.default.useRef(null);
  const lastTimeDragPrevented = import_react40.default.useRef(null);
  const isAllowedToDrag = import_react40.default.useRef(false);
  const nestedOpenChangeTimer = import_react40.default.useRef(null);
  const pointerStart = import_react40.default.useRef(0);
  const keyboardIsOpen = import_react40.default.useRef(false);
  const previousDiffFromInitial = import_react40.default.useRef(0);
  const drawerRef = import_react40.default.useRef(null);
  const drawerHeightRef = import_react40.default.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);
  const drawerWidthRef = import_react40.default.useRef(((_drawerRef_current1 = drawerRef.current) == null ? void 0 : _drawerRef_current1.getBoundingClientRect().width) || 0);
  const initialDrawerHeight = import_react40.default.useRef(0);
  const onSnapPointChange = import_react40.default.useCallback((activeSnapPointIndex2) => {
    if (snapPoints && activeSnapPointIndex2 === snapPointsOffset.length - 1)
      openTime.current = /* @__PURE__ */ new Date();
  }, []);
  const { activeSnapPoint, activeSnapPointIndex, setActiveSnapPoint, onRelease: onReleaseSnapPoints, snapPointsOffset, onDrag: onDragSnapPoints, shouldFade, getPercentageDragged: getSnapPointsPercentageDragged } = useSnapPoints({
    snapPoints,
    activeSnapPointProp,
    setActiveSnapPointProp,
    drawerRef,
    fadeFromIndex,
    overlayRef,
    onSnapPointChange,
    direction,
    container,
    snapToSequentialPoint
  });
  usePreventScroll({
    isDisabled: !isOpen || isDragging2 || !modal || justReleased || !hasBeenOpened || !repositionInputs || !disablePreventScroll
  });
  const { restorePositionSetting } = usePositionFixed({
    isOpen,
    modal,
    nested,
    hasBeenOpened,
    preventScrollRestoration,
    noBodyStyles
  });
  function getScale2() {
    return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;
  }
  function onPress(event) {
    var _drawerRef_current2, _drawerRef_current12;
    if (!dismissible && !snapPoints)
      return;
    if (drawerRef.current && !drawerRef.current.contains(event.target))
      return;
    drawerHeightRef.current = ((_drawerRef_current2 = drawerRef.current) == null ? void 0 : _drawerRef_current2.getBoundingClientRect().height) || 0;
    drawerWidthRef.current = ((_drawerRef_current12 = drawerRef.current) == null ? void 0 : _drawerRef_current12.getBoundingClientRect().width) || 0;
    setIsDragging(true);
    dragStartTime.current = /* @__PURE__ */ new Date();
    if (isIOS()) {
      window.addEventListener("touchend", () => isAllowedToDrag.current = false, {
        once: true
      });
    }
    event.target.setPointerCapture(event.pointerId);
    pointerStart.current = isVertical(direction) ? event.pageY : event.pageX;
  }
  function shouldDrag(el, isDraggingInDirection) {
    var _window_getSelection, _lastTimeDragPrevented_current;
    let element = el;
    const highlightedText = (_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString();
    const swipeAmount = drawerRef.current ? getTranslate(drawerRef.current, direction) : null;
    const date = /* @__PURE__ */ new Date();
    if (element.hasAttribute("data-vaul-no-drag") || element.closest("[data-vaul-no-drag]")) {
      return false;
    }
    if (direction === "right" || direction === "left") {
      return true;
    }
    if (openTime.current && date.getTime() - openTime.current.getTime() < 500) {
      return false;
    }
    if (swipeAmount !== null) {
      if (direction === "bottom" ? swipeAmount > 0 : swipeAmount < 0) {
        return true;
      }
    }
    if (highlightedText && highlightedText.length > 0) {
      return false;
    }
    if (date.getTime() - ((_lastTimeDragPrevented_current = lastTimeDragPrevented.current) == null ? void 0 : _lastTimeDragPrevented_current.getTime()) < scrollLockTimeout && swipeAmount === 0) {
      lastTimeDragPrevented.current = date;
      return false;
    }
    if (isDraggingInDirection) {
      lastTimeDragPrevented.current = date;
      return false;
    }
    while (element) {
      if (element.scrollHeight > element.clientHeight) {
        if (element.scrollTop !== 0) {
          lastTimeDragPrevented.current = /* @__PURE__ */ new Date();
          return false;
        }
        if (element.getAttribute("role") === "dialog") {
          return true;
        }
      }
      element = element.parentNode;
    }
    return true;
  }
  function onDrag(event) {
    if (!drawerRef.current) {
      return;
    }
    if (isDragging2) {
      const directionMultiplier = direction === "bottom" || direction === "right" ? 1 : -1;
      const draggedDistance = (pointerStart.current - (isVertical(direction) ? event.pageY : event.pageX)) * directionMultiplier;
      const isDraggingInDirection = draggedDistance > 0;
      const noCloseSnapPointsPreCondition = snapPoints && !dismissible && !isDraggingInDirection;
      if (noCloseSnapPointsPreCondition && activeSnapPointIndex === 0)
        return;
      const absDraggedDistance = Math.abs(draggedDistance);
      const wrapper = document.querySelector("[data-vaul-drawer-wrapper]");
      const drawerDimension = direction === "bottom" || direction === "top" ? drawerHeightRef.current : drawerWidthRef.current;
      let percentageDragged = absDraggedDistance / drawerDimension;
      const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);
      if (snapPointPercentageDragged !== null) {
        percentageDragged = snapPointPercentageDragged;
      }
      if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {
        return;
      }
      if (!isAllowedToDrag.current && !shouldDrag(event.target, isDraggingInDirection))
        return;
      drawerRef.current.classList.add(DRAG_CLASS);
      isAllowedToDrag.current = true;
      set(drawerRef.current, {
        transition: "none"
      });
      set(overlayRef.current, {
        transition: "none"
      });
      if (snapPoints) {
        onDragSnapPoints({
          draggedDistance
        });
      }
      if (isDraggingInDirection && !snapPoints) {
        const dampenedDraggedDistance = dampenValue(draggedDistance);
        const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;
        set(drawerRef.current, {
          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
        });
        return;
      }
      const opacityValue = 1 - percentageDragged;
      if (shouldFade || fadeFromIndex && activeSnapPointIndex === fadeFromIndex - 1) {
        onDragProp == null ? void 0 : onDragProp(event, percentageDragged);
        set(overlayRef.current, {
          opacity: `${opacityValue}`,
          transition: "none"
        }, true);
      }
      if (wrapper && overlayRef.current && shouldScaleBackground) {
        const scaleValue = Math.min(getScale2() + percentageDragged * (1 - getScale2()), 1);
        const borderRadiusValue = 8 - percentageDragged * 8;
        const translateValue = Math.max(0, 14 - percentageDragged * 14);
        set(wrapper, {
          borderRadius: `${borderRadiusValue}px`,
          transform: isVertical(direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,
          transition: "none"
        }, true);
      }
      if (!snapPoints) {
        const translateValue = absDraggedDistance * directionMultiplier;
        set(drawerRef.current, {
          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
        });
      }
    }
  }
  import_react40.default.useEffect(() => {
    var _window_visualViewport;
    function onVisualViewportChange() {
      if (!drawerRef.current || !repositionInputs)
        return;
      const focusedElement = document.activeElement;
      if (isInput(focusedElement) || keyboardIsOpen.current) {
        var _window_visualViewport2;
        const visualViewportHeight = ((_window_visualViewport2 = window.visualViewport) == null ? void 0 : _window_visualViewport2.height) || 0;
        const totalHeight = window.innerHeight;
        let diffFromInitial = totalHeight - visualViewportHeight;
        const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;
        const isTallEnough = drawerHeight > totalHeight * 0.8;
        if (!initialDrawerHeight.current) {
          initialDrawerHeight.current = drawerHeight;
        }
        const offsetFromTop = drawerRef.current.getBoundingClientRect().top;
        if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {
          keyboardIsOpen.current = !keyboardIsOpen.current;
        }
        if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {
          const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;
          diffFromInitial += activeSnapPointHeight;
        }
        previousDiffFromInitial.current = diffFromInitial;
        if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {
          const height = drawerRef.current.getBoundingClientRect().height;
          let newDrawerHeight = height;
          if (height > visualViewportHeight) {
            newDrawerHeight = visualViewportHeight - (isTallEnough ? offsetFromTop : WINDOW_TOP_OFFSET);
          }
          if (fixed) {
            drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;
          } else {
            drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;
          }
        } else {
          drawerRef.current.style.height = `${initialDrawerHeight.current}px`;
        }
        if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {
          drawerRef.current.style.bottom = `0px`;
        } else {
          drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;
        }
      }
    }
    (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener("resize", onVisualViewportChange);
    return () => {
      var _window_visualViewport2;
      return (_window_visualViewport2 = window.visualViewport) == null ? void 0 : _window_visualViewport2.removeEventListener("resize", onVisualViewportChange);
    };
  }, [
    activeSnapPointIndex,
    snapPoints,
    snapPointsOffset
  ]);
  function closeDrawer(fromWithin) {
    cancelDrag();
    onClose == null ? void 0 : onClose();
    if (!fromWithin) {
      setIsOpen(false);
    }
    setTimeout(() => {
      if (snapPoints) {
        setActiveSnapPoint(snapPoints[0]);
      }
    }, TRANSITIONS.DURATION * 1e3);
  }
  function resetDrawer() {
    if (!drawerRef.current)
      return;
    const wrapper = document.querySelector("[data-vaul-drawer-wrapper]");
    const currentSwipeAmount = getTranslate(drawerRef.current, direction);
    set(drawerRef.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    set(overlayRef.current, {
      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      opacity: "1"
    });
    if (shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && isOpen) {
      set(wrapper, __spreadProps(__spreadValues({
        borderRadius: `${BORDER_RADIUS}px`,
        overflow: "hidden"
      }, isVertical(direction) ? {
        transform: `scale(${getScale2()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
        transformOrigin: "top"
      } : {
        transform: `scale(${getScale2()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
        transformOrigin: "left"
      }), {
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      }), true);
    }
  }
  function cancelDrag() {
    if (!isDragging2 || !drawerRef.current)
      return;
    drawerRef.current.classList.remove(DRAG_CLASS);
    isAllowedToDrag.current = false;
    setIsDragging(false);
    dragEndTime.current = /* @__PURE__ */ new Date();
  }
  function onRelease(event) {
    if (!isDragging2 || !drawerRef.current)
      return;
    drawerRef.current.classList.remove(DRAG_CLASS);
    isAllowedToDrag.current = false;
    setIsDragging(false);
    dragEndTime.current = /* @__PURE__ */ new Date();
    const swipeAmount = getTranslate(drawerRef.current, direction);
    if (!shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount))
      return;
    if (dragStartTime.current === null)
      return;
    const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();
    const distMoved = pointerStart.current - (isVertical(direction) ? event.pageY : event.pageX);
    const velocity = Math.abs(distMoved) / timeTaken;
    if (velocity > 0.05) {
      setJustReleased(true);
      setTimeout(() => {
        setJustReleased(false);
      }, 200);
    }
    if (snapPoints) {
      const directionMultiplier = direction === "bottom" || direction === "right" ? 1 : -1;
      onReleaseSnapPoints({
        draggedDistance: distMoved * directionMultiplier,
        closeDrawer,
        velocity,
        dismissible
      });
      onReleaseProp == null ? void 0 : onReleaseProp(event, true);
      return;
    }
    if (direction === "bottom" || direction === "right" ? distMoved > 0 : distMoved < 0) {
      resetDrawer();
      onReleaseProp == null ? void 0 : onReleaseProp(event, true);
      return;
    }
    if (velocity > VELOCITY_THRESHOLD) {
      closeDrawer();
      onReleaseProp == null ? void 0 : onReleaseProp(event, false);
      return;
    }
    var _drawerRef_current_getBoundingClientRect_height;
    const visibleDrawerHeight = Math.min((_drawerRef_current_getBoundingClientRect_height = drawerRef.current.getBoundingClientRect().height) != null ? _drawerRef_current_getBoundingClientRect_height : 0, window.innerHeight);
    var _drawerRef_current_getBoundingClientRect_width;
    const visibleDrawerWidth = Math.min((_drawerRef_current_getBoundingClientRect_width = drawerRef.current.getBoundingClientRect().width) != null ? _drawerRef_current_getBoundingClientRect_width : 0, window.innerWidth);
    const isHorizontalSwipe = direction === "left" || direction === "right";
    if (Math.abs(swipeAmount) >= (isHorizontalSwipe ? visibleDrawerWidth : visibleDrawerHeight) * closeThreshold) {
      closeDrawer();
      onReleaseProp == null ? void 0 : onReleaseProp(event, false);
      return;
    }
    onReleaseProp == null ? void 0 : onReleaseProp(event, true);
    resetDrawer();
  }
  import_react40.default.useEffect(() => {
    if (isOpen) {
      set(document.documentElement, {
        scrollBehavior: "auto"
      });
      openTime.current = /* @__PURE__ */ new Date();
    }
    return () => {
      reset(document.documentElement, "scrollBehavior");
    };
  }, [
    isOpen
  ]);
  function onNestedOpenChange(o2) {
    const scale = o2 ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;
    const y = o2 ? -NESTED_DISPLACEMENT : 0;
    if (nestedOpenChangeTimer.current) {
      window.clearTimeout(nestedOpenChangeTimer.current);
    }
    set(drawerRef.current, {
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      transform: `scale(${scale}) translate3d(0, ${y}px, 0)`
    });
    if (!o2 && drawerRef.current) {
      nestedOpenChangeTimer.current = setTimeout(() => {
        const translateValue = getTranslate(drawerRef.current, direction);
        set(drawerRef.current, {
          transition: "none",
          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
        });
      }, 500);
    }
  }
  function onNestedDrag(_event, percentageDragged) {
    if (percentageDragged < 0)
      return;
    const initialScale = (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth;
    const newScale = initialScale + percentageDragged * (1 - initialScale);
    const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;
    set(drawerRef.current, {
      transform: isVertical(direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,
      transition: "none"
    });
  }
  function onNestedRelease(_event, o2) {
    const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;
    const scale = o2 ? (dim - NESTED_DISPLACEMENT) / dim : 1;
    const translate = o2 ? -NESTED_DISPLACEMENT : 0;
    if (o2) {
      set(drawerRef.current, {
        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`
      });
    }
  }
  return /* @__PURE__ */ import_react40.default.createElement(Root11, {
    defaultOpen,
    onOpenChange: (open) => {
      if (!dismissible && !open)
        return;
      if (open) {
        setHasBeenOpened(true);
      } else {
        closeDrawer(true);
      }
      setIsOpen(open);
    },
    open: isOpen
  }, /* @__PURE__ */ import_react40.default.createElement(DrawerContext.Provider, {
    value: {
      activeSnapPoint,
      snapPoints,
      setActiveSnapPoint,
      drawerRef,
      overlayRef,
      onOpenChange,
      onPress,
      onRelease,
      onDrag,
      dismissible,
      handleOnly,
      isOpen,
      isDragging: isDragging2,
      shouldFade,
      closeDrawer,
      onNestedDrag,
      onNestedOpenChange,
      onNestedRelease,
      keyboardIsOpen,
      modal,
      snapPointsOffset,
      direction,
      shouldScaleBackground,
      setBackgroundColorOnScale,
      noBodyStyles,
      container,
      autoFocus
    }
  }, children));
}
var Overlay4 = /* @__PURE__ */ import_react40.default.forwardRef(function(_a, ref2) {
  var rest = __objRest(_a, []);
  const { overlayRef, snapPoints, onRelease, shouldFade, isOpen, modal } = useDrawerContext();
  const composedRef = useComposedRefs3(ref2, overlayRef);
  const hasSnapPoints = snapPoints && snapPoints.length > 0;
  if (!modal) {
    if (typeof window !== "undefined") {
      window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      });
    }
    return null;
  }
  return /* @__PURE__ */ import_react40.default.createElement(Overlay3, __spreadValues({
    onMouseUp: onRelease,
    ref: composedRef,
    "data-vaul-overlay": "",
    "data-vaul-snap-points": isOpen && hasSnapPoints ? "true" : "false",
    "data-vaul-snap-points-overlay": isOpen && shouldFade ? "true" : "false"
  }, rest));
});
Overlay4.displayName = "Drawer.Overlay";
var Content6 = /* @__PURE__ */ import_react40.default.forwardRef(function(_a, ref2) {
  var _b = _a, { onPointerDownOutside, style: style2, onOpenAutoFocus } = _b, rest = __objRest(_b, ["onPointerDownOutside", "style", "onOpenAutoFocus"]);
  const { drawerRef, onPress, onRelease, onDrag, keyboardIsOpen, snapPointsOffset, modal, isOpen, direction, snapPoints, container, handleOnly, autoFocus } = useDrawerContext();
  const [delayedSnapPoints, setDelayedSnapPoints] = import_react40.default.useState(false);
  const composedRef = useComposedRefs3(ref2, drawerRef);
  const pointerStartRef = import_react40.default.useRef(null);
  const lastKnownPointerEventRef = import_react40.default.useRef(null);
  const wasBeyondThePointRef = import_react40.default.useRef(false);
  const hasSnapPoints = snapPoints && snapPoints.length > 0;
  useScaleBackground();
  const isDeltaInDirection2 = (delta, direction2, threshold = 0) => {
    if (wasBeyondThePointRef.current)
      return true;
    const deltaY = Math.abs(delta.y);
    const deltaX = Math.abs(delta.x);
    const isDeltaX = deltaX > deltaY;
    const dFactor = [
      "bottom",
      "right"
    ].includes(direction2) ? 1 : -1;
    if (direction2 === "left" || direction2 === "right") {
      const isReverseDirection = delta.x * dFactor < 0;
      if (!isReverseDirection && deltaX >= 0 && deltaX <= threshold) {
        return isDeltaX;
      }
    } else {
      const isReverseDirection = delta.y * dFactor < 0;
      if (!isReverseDirection && deltaY >= 0 && deltaY <= threshold) {
        return !isDeltaX;
      }
    }
    wasBeyondThePointRef.current = true;
    return true;
  };
  import_react40.default.useEffect(() => {
    if (hasSnapPoints) {
      window.requestAnimationFrame(() => {
        setDelayedSnapPoints(true);
      });
    }
  }, []);
  function handleOnPointerUp(event) {
    pointerStartRef.current = null;
    wasBeyondThePointRef.current = false;
    onRelease(event);
  }
  return /* @__PURE__ */ import_react40.default.createElement(Content5, __spreadProps(__spreadValues({
    "data-vaul-drawer-direction": direction,
    "data-vaul-drawer": "",
    "data-vaul-delayed-snap-points": delayedSnapPoints ? "true" : "false",
    "data-vaul-snap-points": isOpen && hasSnapPoints ? "true" : "false",
    "data-vaul-custom-container": container ? "true" : "false"
  }, rest), {
    ref: composedRef,
    style: snapPointsOffset && snapPointsOffset.length > 0 ? __spreadValues({
      "--snap-point-height": `${snapPointsOffset[0]}px`
    }, style2) : style2,
    onPointerDown: (event) => {
      if (handleOnly)
        return;
      rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);
      pointerStartRef.current = {
        x: event.pageX,
        y: event.pageY
      };
      onPress(event);
    },
    onOpenAutoFocus: (e) => {
      onOpenAutoFocus == null ? void 0 : onOpenAutoFocus(e);
      if (!autoFocus) {
        e.preventDefault();
      }
    },
    onPointerDownOutside: (e) => {
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);
      if (!modal || e.defaultPrevented) {
        e.preventDefault();
        return;
      }
      if (keyboardIsOpen.current) {
        keyboardIsOpen.current = false;
      }
    },
    onFocusOutside: (e) => {
      if (!modal) {
        e.preventDefault();
        return;
      }
    },
    onPointerMove: (event) => {
      lastKnownPointerEventRef.current = event;
      if (handleOnly)
        return;
      rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);
      if (!pointerStartRef.current)
        return;
      const yPosition = event.pageY - pointerStartRef.current.y;
      const xPosition = event.pageX - pointerStartRef.current.x;
      const swipeStartThreshold = event.pointerType === "touch" ? 10 : 2;
      const delta = {
        x: xPosition,
        y: yPosition
      };
      const isAllowedToSwipe = isDeltaInDirection2(delta, direction, swipeStartThreshold);
      if (isAllowedToSwipe)
        onDrag(event);
      else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {
        pointerStartRef.current = null;
      }
    },
    onPointerUp: (event) => {
      rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);
      pointerStartRef.current = null;
      wasBeyondThePointRef.current = false;
      onRelease(event);
    },
    onPointerOut: (event) => {
      rest.onPointerOut == null ? void 0 : rest.onPointerOut.call(rest, event);
      handleOnPointerUp(lastKnownPointerEventRef.current);
    },
    onContextMenu: (event) => {
      rest.onContextMenu == null ? void 0 : rest.onContextMenu.call(rest, event);
      handleOnPointerUp(lastKnownPointerEventRef.current);
    }
  }));
});
Content6.displayName = "Drawer.Content";
var LONG_HANDLE_PRESS_TIMEOUT = 250;
var DOUBLE_TAP_TIMEOUT = 120;
var Handle = /* @__PURE__ */ import_react40.default.forwardRef(function(_a, ref2) {
  var _b = _a, { preventCycle = false, children } = _b, rest = __objRest(_b, ["preventCycle", "children"]);
  const { closeDrawer, isDragging: isDragging2, snapPoints, activeSnapPoint, setActiveSnapPoint, dismissible, handleOnly, isOpen, onPress, onDrag } = useDrawerContext();
  const closeTimeoutIdRef = import_react40.default.useRef(null);
  const shouldCancelInteractionRef = import_react40.default.useRef(false);
  function handleStartCycle() {
    if (shouldCancelInteractionRef.current) {
      handleCancelInteraction();
      return;
    }
    window.setTimeout(() => {
      handleCycleSnapPoints();
    }, DOUBLE_TAP_TIMEOUT);
  }
  function handleCycleSnapPoints() {
    if (isDragging2 || preventCycle || shouldCancelInteractionRef.current) {
      handleCancelInteraction();
      return;
    }
    handleCancelInteraction();
    if ((!snapPoints || snapPoints.length === 0) && dismissible) {
      closeDrawer();
      return;
    }
    const isLastSnapPoint = activeSnapPoint === snapPoints[snapPoints.length - 1];
    if (isLastSnapPoint && dismissible) {
      closeDrawer();
      return;
    }
    const currentSnapIndex = snapPoints.findIndex((point) => point === activeSnapPoint);
    if (currentSnapIndex === -1)
      return;
    const nextSnapPoint = snapPoints[currentSnapIndex + 1];
    setActiveSnapPoint(nextSnapPoint);
  }
  function handleStartInteraction() {
    closeTimeoutIdRef.current = window.setTimeout(() => {
      shouldCancelInteractionRef.current = true;
    }, LONG_HANDLE_PRESS_TIMEOUT);
  }
  function handleCancelInteraction() {
    window.clearTimeout(closeTimeoutIdRef.current);
    shouldCancelInteractionRef.current = false;
  }
  return /* @__PURE__ */ import_react40.default.createElement("div", __spreadValues({
    onClick: handleStartCycle,
    onPointerCancel: handleCancelInteraction,
    onPointerDown: (e) => {
      if (handleOnly)
        onPress(e);
      handleStartInteraction();
    },
    onPointerMove: (e) => {
      if (handleOnly)
        onDrag(e);
    },
    // onPointerUp is already handled by the content component
    ref: ref2,
    "data-vaul-drawer-visible": isOpen ? "true" : "false",
    "data-vaul-handle": "",
    "aria-hidden": "true"
  }, rest), /* @__PURE__ */ import_react40.default.createElement("span", {
    "data-vaul-handle-hitarea": "",
    "aria-hidden": "true"
  }, children));
});
Handle.displayName = "Drawer.Handle";
function NestedRoot(_a) {
  var _b = _a, { onDrag, onOpenChange } = _b, rest = __objRest(_b, ["onDrag", "onOpenChange"]);
  const { onNestedDrag, onNestedOpenChange, onNestedRelease } = useDrawerContext();
  if (!onNestedDrag) {
    throw new Error("Drawer.NestedRoot must be placed in another drawer");
  }
  return /* @__PURE__ */ import_react40.default.createElement(Root13, __spreadValues({
    nested: true,
    onClose: () => {
      onNestedOpenChange(false);
    },
    onDrag: (e, p2) => {
      onNestedDrag(e, p2);
      onDrag == null ? void 0 : onDrag(e, p2);
    },
    onOpenChange: (o2) => {
      if (o2) {
        onNestedOpenChange(o2);
      }
    },
    onRelease: onNestedRelease
  }, rest));
}
function Portal8(props2) {
  const context = useDrawerContext();
  const _a = props2, { container = context.container } = _a, portalProps = __objRest(_a, ["container"]);
  return /* @__PURE__ */ import_react40.default.createElement(Portal5, __spreadValues({
    container
  }, portalProps));
}
var Drawer = {
  Root: Root13,
  NestedRoot,
  Content: Content6,
  Overlay: Overlay4,
  Trigger: Trigger5,
  Portal: Portal8,
  Handle,
  Close: Close2,
  Title: Title3,
  Description: Description3
};

// src/components/drawer.tsx
var import_utils27 = require("@nubras/utils");
var import_jsx_runtime50 = require("react/jsx-runtime");
var Drawer2 = (_a) => {
  var _b = _a, {
    shouldScaleBackground = true
  } = _b, props2 = __objRest(_b, [
    "shouldScaleBackground"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
    Drawer.Root,
    __spreadValues({
      shouldScaleBackground
    }, props2)
  );
};
Drawer2.displayName = "Drawer";
var DrawerTrigger = Drawer.Trigger;
var DrawerPortal = Drawer.Portal;
var DrawerClose = Drawer.Close;
var DrawerOverlay = React103.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
    Drawer.Overlay,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils27.cn)("fixed inset-0 z-50 bg-black/80", className)
    }, props2)
  );
});
DrawerOverlay.displayName = Drawer.Overlay.displayName;
var DrawerContent = React103.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(DrawerPortal, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(DrawerOverlay, {}),
    /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(
      Drawer.Content,
      __spreadProps(__spreadValues({
        ref: ref2,
        className: (0, import_utils27.cn)(
          "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
          className
        )
      }, props2), {
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
          children
        ]
      })
    )
  ] });
});
DrawerContent.displayName = "DrawerContent";
var DrawerHeader = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
    "div",
    __spreadValues({
      className: (0, import_utils27.cn)("grid gap-1.5 p-4 text-center sm:text-left", className)
    }, props2)
  );
};
DrawerHeader.displayName = "DrawerHeader";
var DrawerFooter = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
    "div",
    __spreadValues({
      className: (0, import_utils27.cn)("mt-auto flex flex-col gap-2 p-4", className)
    }, props2)
  );
};
DrawerFooter.displayName = "DrawerFooter";
var DrawerTitle = React103.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
    Drawer.Title,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils27.cn)(
        "text-lg font-semibold leading-none tracking-tight",
        className
      )
    }, props2)
  );
});
DrawerTitle.displayName = Drawer.Title.displayName;
var DrawerDescription = React103.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
    Drawer.Description,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils27.cn)("text-sm text-muted-foreground", className)
    }, props2)
  );
});
DrawerDescription.displayName = Drawer.Description.displayName;

// src/components/dropdown-menu.tsx
var React105 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-dropdown-menu@2.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react_yyphdzi7l3nk6tbwvlwldqneya/node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var React104 = __toESM(require("react"), 1);
var import_jsx_runtime51 = require("react/jsx-runtime");
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope2 = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props2) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props2;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const triggerRef = React104.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React104.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Root32, __spreadProps(__spreadValues({}, menuScope), { open, onOpenChange: setOpen, dir, modal, children }))
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME9 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React104.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDropdownMenu, disabled = false } = _a, triggerProps = __objRest(_a, ["__scopeDropdownMenu", "disabled"]);
    const context = useDropdownMenuContext(TRIGGER_NAME9, __scopeDropdownMenu);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Anchor2, __spreadProps(__spreadValues({ asChild: true }, menuScope), { children: /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled
      }, triggerProps), {
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props2.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open)
              event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          if (disabled)
            return;
          if (["Enter", " "].includes(event.key))
            context.onOpenToggle();
          if (event.key === "ArrowDown")
            context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key))
            event.preventDefault();
        })
      })
    ) }));
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME9;
var PORTAL_NAME10 = "DropdownMenuPortal";
var DropdownMenuPortal = (props2) => {
  const _a = props2, { __scopeDropdownMenu } = _a, portalProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Portal6, __spreadValues(__spreadValues({}, menuScope), portalProps));
};
DropdownMenuPortal.displayName = PORTAL_NAME10;
var CONTENT_NAME11 = "DropdownMenuContent";
var DropdownMenuContent = React104.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDropdownMenu } = _a, contentProps = __objRest(_a, ["__scopeDropdownMenu"]);
    const context = useDropdownMenuContext(CONTENT_NAME11, __scopeDropdownMenu);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React104.useRef(false);
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
      Content24,
      __spreadProps(__spreadValues(__spreadValues({
        id: context.contentId,
        "aria-labelledby": context.triggerId
      }, menuScope), contentProps), {
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props2.onCloseAutoFocus, (event) => {
          var _a2;
          if (!hasInteractedOutsideRef.current)
            (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props2.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick)
            hasInteractedOutsideRef.current = true;
        }),
        style: __spreadValues(__spreadValues({}, props2.style), {
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        })
      })
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME11;
var GROUP_NAME5 = "DropdownMenuGroup";
var DropdownMenuGroup = React104.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDropdownMenu } = _a, groupProps = __objRest(_a, ["__scopeDropdownMenu"]);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Group2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), groupProps), { ref: forwardedRef }));
  }
);
DropdownMenuGroup.displayName = GROUP_NAME5;
var LABEL_NAME4 = "DropdownMenuLabel";
var DropdownMenuLabel = React104.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDropdownMenu } = _a, labelProps = __objRest(_a, ["__scopeDropdownMenu"]);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Label2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), labelProps), { ref: forwardedRef }));
  }
);
DropdownMenuLabel.displayName = LABEL_NAME4;
var ITEM_NAME6 = "DropdownMenuItem";
var DropdownMenuItem = React104.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDropdownMenu } = _a, itemProps = __objRest(_a, ["__scopeDropdownMenu"]);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Item22, __spreadProps(__spreadValues(__spreadValues({}, menuScope), itemProps), { ref: forwardedRef }));
  }
);
DropdownMenuItem.displayName = ITEM_NAME6;
var CHECKBOX_ITEM_NAME3 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React104.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeDropdownMenu } = _a, checkboxItemProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(CheckboxItem, __spreadProps(__spreadValues(__spreadValues({}, menuScope), checkboxItemProps), { ref: forwardedRef }));
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME3;
var RADIO_GROUP_NAME3 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React104.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeDropdownMenu } = _a, radioGroupProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(RadioGroup, __spreadProps(__spreadValues(__spreadValues({}, menuScope), radioGroupProps), { ref: forwardedRef }));
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME3;
var RADIO_ITEM_NAME3 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React104.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeDropdownMenu } = _a, radioItemProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(RadioItem, __spreadProps(__spreadValues(__spreadValues({}, menuScope), radioItemProps), { ref: forwardedRef }));
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME3;
var INDICATOR_NAME3 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React104.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeDropdownMenu } = _a, itemIndicatorProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(ItemIndicator2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), itemIndicatorProps), { ref: forwardedRef }));
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME3;
var SEPARATOR_NAME4 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React104.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeDropdownMenu } = _a, separatorProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Separator2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), separatorProps), { ref: forwardedRef }));
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME4;
var ARROW_NAME6 = "DropdownMenuArrow";
var DropdownMenuArrow = React104.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeDropdownMenu } = _a, arrowProps = __objRest(_a, ["__scopeDropdownMenu"]);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Arrow22, __spreadProps(__spreadValues(__spreadValues({}, menuScope), arrowProps), { ref: forwardedRef }));
  }
);
DropdownMenuArrow.displayName = ARROW_NAME6;
var DropdownMenuSub = (props2) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props2;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(Sub, __spreadProps(__spreadValues({}, menuScope), { open, onOpenChange: setOpen, children }));
};
var SUB_TRIGGER_NAME3 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React104.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeDropdownMenu } = _a, subTriggerProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(SubTrigger, __spreadProps(__spreadValues(__spreadValues({}, menuScope), subTriggerProps), { ref: forwardedRef }));
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME3;
var SUB_CONTENT_NAME3 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React104.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeDropdownMenu } = _a, subContentProps = __objRest(_a, ["__scopeDropdownMenu"]);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
    SubContent,
    __spreadProps(__spreadValues(__spreadValues({}, menuScope), subContentProps), {
      ref: forwardedRef,
      style: __spreadValues(__spreadValues({}, props2.style), {
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      })
    })
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME3;
var Root27 = DropdownMenu;
var Trigger8 = DropdownMenuTrigger;
var Portal24 = DropdownMenuPortal;
var Content27 = DropdownMenuContent;
var Group23 = DropdownMenuGroup;
var Label23 = DropdownMenuLabel;
var Item24 = DropdownMenuItem;
var CheckboxItem22 = DropdownMenuCheckboxItem;
var RadioGroup22 = DropdownMenuRadioGroup;
var RadioItem22 = DropdownMenuRadioItem;
var ItemIndicator23 = DropdownMenuItemIndicator;
var Separator23 = DropdownMenuSeparator;
var Sub22 = DropdownMenuSub;
var SubTrigger22 = DropdownMenuSubTrigger;
var SubContent22 = DropdownMenuSubContent;

// src/components/dropdown-menu.tsx
var import_utils28 = require("@nubras/utils");
var import_jsx_runtime52 = require("react/jsx-runtime");
var DropdownMenu2 = Root27;
var DropdownMenuTrigger2 = Trigger8;
var DropdownMenuGroup2 = Group23;
var DropdownMenuPortal2 = Portal24;
var DropdownMenuSub2 = Sub22;
var DropdownMenuRadioGroup2 = RadioGroup22;
var DropdownMenuSubTrigger2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset, children } = _b, props2 = __objRest(_b, ["className", "inset", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
    SubTrigger22,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils28.cn)(
        "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        className
      )
    }, props2), {
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(ChevronRight, { className: "ml-auto" })
      ]
    })
  );
});
DropdownMenuSubTrigger2.displayName = SubTrigger22.displayName;
var DropdownMenuSubContent2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
    SubContent22,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils28.cn)(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  );
});
DropdownMenuSubContent2.displayName = SubContent22.displayName;
var DropdownMenuContent2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className, sideOffset = 4 } = _b, props2 = __objRest(_b, ["className", "sideOffset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(Portal24, { children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
    Content27,
    __spreadValues({
      ref: ref2,
      sideOffset,
      className: (0, import_utils28.cn)(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  ) });
});
DropdownMenuContent2.displayName = Content27.displayName;
var DropdownMenuItem2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset } = _b, props2 = __objRest(_b, ["className", "inset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
    Item24,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils28.cn)(
        "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        className
      )
    }, props2)
  );
});
DropdownMenuItem2.displayName = Item24.displayName;
var DropdownMenuCheckboxItem2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className, children, checked } = _b, props2 = __objRest(_b, ["className", "children", "checked"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
    CheckboxItem22,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils28.cn)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      ),
      checked
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(ItemIndicator23, { children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(Check, { className: "h-4 w-4" }) }) }),
        children
      ]
    })
  );
});
DropdownMenuCheckboxItem2.displayName = CheckboxItem22.displayName;
var DropdownMenuRadioItem2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
    RadioItem22,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils28.cn)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(ItemIndicator23, { children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(Circle, { className: "h-2 w-2 fill-current" }) }) }),
        children
      ]
    })
  );
});
DropdownMenuRadioItem2.displayName = RadioItem22.displayName;
var DropdownMenuLabel2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset } = _b, props2 = __objRest(_b, ["className", "inset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
    Label23,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils28.cn)(
        "px-2 py-1.5 text-sm font-semibold",
        inset && "pl-8",
        className
      )
    }, props2)
  );
});
DropdownMenuLabel2.displayName = Label23.displayName;
var DropdownMenuSeparator2 = React105.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
    Separator23,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils28.cn)("-mx-1 my-1 h-px bg-muted", className)
    }, props2)
  );
});
DropdownMenuSeparator2.displayName = Separator23.displayName;
var DropdownMenuShortcut = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
    "span",
    __spreadValues({
      className: (0, import_utils28.cn)("ml-auto text-xs tracking-widest opacity-60", className)
    }, props2)
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

// src/components/form.tsx
var React109 = __toESM(require("react"));

// ../../node_modules/.pnpm/react-hook-form@7.56.3_react@19.1.0/node_modules/react-hook-form/dist/index.esm.mjs
var React106 = __toESM(require("react"), 1);
var import_react41 = __toESM(require("react"), 1);
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject3 = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject3(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject3(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy;
  const isArray = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject3(data))) {
    copy = isArray ? [] : {};
    if (!isArray && !isPlainObject(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (object, path, defaultValue) => {
  if (!path || !isObject3(object)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean2 = (value) => typeof value === "boolean";
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var set2 = (object, path, value) => {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject3(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var HookFormContext = import_react41.default.createContext(null);
var useFormContext = () => import_react41.default.useContext(HookFormContext);
var FormProvider = (props2) => {
  const _a = props2, { children } = _a, data = __objRest(_a, ["children"]);
  return import_react41.default.createElement(HookFormContext.Provider, { value: data }, children);
};
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? React106.useLayoutEffect : React106.useEffect;
function useFormState(props2) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props2 || {};
  const [formState, updateFormState] = import_react41.default.useState(control._formState);
  const _localProxyFormState = import_react41.default.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  useIsomorphicLayoutEffect3(() => control._subscribe({
    name,
    formState: _localProxyFormState.current,
    exact,
    callback: (formState2) => {
      !disabled && updateFormState(__spreadValues(__spreadValues({}, control._formState), formState2));
    }
  }), [name, disabled, exact]);
  import_react41.default.useEffect(() => {
    _localProxyFormState.current.isValid && control._setValid(true);
  }, [control]);
  return import_react41.default.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString2 = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString2(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props2) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact } = props2 || {};
  const _defaultValue = import_react41.default.useRef(defaultValue);
  const [value, updateValue] = import_react41.default.useState(control._getWatch(name, _defaultValue.current));
  useIsomorphicLayoutEffect3(() => control._subscribe({
    name,
    formState: {
      values: true
    },
    exact,
    callback: (formState) => !disabled && updateValue(generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current))
  }), [name, control, disabled, exact]);
  import_react41.default.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props2) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister } = props2;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props2.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _props = import_react41.default.useRef(props2);
  const _registerProps = import_react41.default.useRef(control.register(name, __spreadValues(__spreadProps(__spreadValues({}, props2.rules), {
    value
  }), isBoolean2(props2.disabled) ? { disabled: props2.disabled } : {})));
  const fieldState = import_react41.default.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get(formState.errors, name)
    }
  }), [formState, name]);
  const onChange = import_react41.default.useCallback((event) => _registerProps.current.onChange({
    target: {
      value: getEventValue(event),
      name
    },
    type: EVENTS.CHANGE
  }), [name]);
  const onBlur = import_react41.default.useCallback(() => _registerProps.current.onBlur({
    target: {
      value: get(control._formValues, name),
      name
    },
    type: EVENTS.BLUR
  }), [name, control._formValues]);
  const ref2 = import_react41.default.useCallback((elm) => {
    const field2 = get(control._fields, name);
    if (field2 && elm) {
      field2._f.ref = {
        focus: () => elm.focus(),
        select: () => elm.select(),
        setCustomValidity: (message2) => elm.setCustomValidity(message2),
        reportValidity: () => elm.reportValidity()
      };
    }
  }, [control._fields, name]);
  const field = import_react41.default.useMemo(() => __spreadProps(__spreadValues({
    name,
    value
  }, isBoolean2(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {}), {
    onChange,
    onBlur,
    ref: ref2
  }), [name, disabled, formState.disabled, onChange, onBlur, ref2, value]);
  import_react41.default.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    control.register(name, __spreadValues(__spreadValues({}, _props.current.rules), isBoolean2(_props.current.disabled) ? { disabled: _props.current.disabled } : {}));
    const updateMounted = (name2, value2) => {
      const field2 = get(control._fields, name2);
      if (field2 && field2._f) {
        field2._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name));
      set2(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set2(control._formValues, name, value2);
      }
    }
    !isArrayField && control.register(name);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  import_react41.default.useEffect(() => {
    control._setDisabledField({
      disabled,
      name
    });
  }, [disabled, name, control]);
  return import_react41.default.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
var Controller = (props2) => props2.render(useController(props2));
var defaultOptions3 = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};

// src/components/form.tsx
var import_utils30 = require("@nubras/utils");

// src/components/label.tsx
var React108 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-label@2.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3__w2gp6ucfzrdulxc3qwl267b6ri/node_modules/@radix-ui/react-label/dist/index.mjs
var React107 = __toESM(require("react"), 1);
var import_jsx_runtime53 = require("react/jsx-runtime");
var NAME4 = "Label";
var Label3 = React107.forwardRef((props2, forwardedRef) => {
  return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
    Primitive.label,
    __spreadProps(__spreadValues({}, props2), {
      ref: forwardedRef,
      onMouseDown: (event) => {
        var _a;
        const target = event.target;
        if (target.closest("button, input, select, textarea"))
          return;
        (_a = props2.onMouseDown) == null ? void 0 : _a.call(props2, event);
        if (!event.defaultPrevented && event.detail > 1)
          event.preventDefault();
      }
    })
  );
});
Label3.displayName = NAME4;
var Root14 = Label3;

// src/components/label.tsx
var import_utils29 = require("@nubras/utils");
var import_jsx_runtime54 = require("react/jsx-runtime");
var labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);
var Label4 = React108.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
    Root14,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils29.cn)(labelVariants(), className)
    }, props2)
  );
});
Label4.displayName = Root14.displayName;

// src/components/form.tsx
var import_jsx_runtime55 = require("react/jsx-runtime");
var Form = FormProvider;
var FormFieldContext = React109.createContext(
  {}
);
var FormField = (_a) => {
  var props2 = __objRest(_a, []);
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(FormFieldContext.Provider, { value: { name: props2.name }, children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Controller, __spreadValues({}, props2)) });
};
var useFormField = () => {
  const fieldContext = React109.useContext(FormFieldContext);
  const itemContext = React109.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();
  const fieldState = getFieldState(fieldContext.name, formState);
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }
  const { id } = itemContext;
  return __spreadValues({
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`
  }, fieldState);
};
var FormItemContext = React109.createContext(
  {}
);
var FormItem = React109.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  const id = React109.useId();
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(FormItemContext.Provider, { value: { id }, children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", __spreadValues({ ref: ref2, className: (0, import_utils30.cn)("space-y-2", className) }, props2)) });
});
FormItem.displayName = "FormItem";
var FormLabel = React109.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  const { error: error2, formItemId } = useFormField();
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
    Label4,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils30.cn)(error2 && "text-destructive", className),
      htmlFor: formItemId
    }, props2)
  );
});
FormLabel.displayName = "FormLabel";
var FormControl = React109.forwardRef((_a, ref2) => {
  var props2 = __objRest(_a, []);
  const { error: error2, formItemId, formDescriptionId, formMessageId } = useFormField();
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
    Slot2,
    __spreadValues({
      ref: ref2,
      id: formItemId,
      "aria-describedby": !error2 ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
      "aria-invalid": !!error2
    }, props2)
  );
});
FormControl.displayName = "FormControl";
var FormDescription = React109.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  const { formDescriptionId } = useFormField();
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
    "p",
    __spreadValues({
      ref: ref2,
      id: formDescriptionId,
      className: (0, import_utils30.cn)("text-sm text-muted-foreground", className)
    }, props2)
  );
});
FormDescription.displayName = "FormDescription";
var FormMessage = React109.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  const { error: error2, formMessageId } = useFormField();
  const body = error2 ? String(error2 == null ? void 0 : error2.message) : children;
  if (!body) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
    "p",
    __spreadProps(__spreadValues({
      ref: ref2,
      id: formMessageId,
      className: (0, import_utils30.cn)("text-sm font-medium text-destructive", className)
    }, props2), {
      children: body
    })
  );
});
FormMessage.displayName = "FormMessage";

// src/components/hover-card.tsx
var React111 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-hover-card@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19_mq6zztchg6n3ku2dnvengwiapi/node_modules/@radix-ui/react-hover-card/dist/index.mjs
var React110 = __toESM(require("react"), 1);
var import_jsx_runtime56 = require("react/jsx-runtime");
var originalBodyUserSelect;
var HOVERCARD_NAME = "HoverCard";
var [createHoverCardContext, createHoverCardScope] = createContextScope(HOVERCARD_NAME, [
  createPopperScope
]);
var usePopperScope4 = createPopperScope();
var [HoverCardProvider, useHoverCardContext] = createHoverCardContext(HOVERCARD_NAME);
var HoverCard = (props2) => {
  const {
    __scopeHoverCard,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    openDelay = 700,
    closeDelay = 300
  } = props2;
  const popperScope = usePopperScope4(__scopeHoverCard);
  const openTimerRef = React110.useRef(0);
  const closeTimerRef = React110.useRef(0);
  const hasSelectionRef = React110.useRef(false);
  const isPointerDownOnContentRef = React110.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const handleOpen = React110.useCallback(() => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = window.setTimeout(() => setOpen(true), openDelay);
  }, [openDelay, setOpen]);
  const handleClose = React110.useCallback(() => {
    clearTimeout(openTimerRef.current);
    if (!hasSelectionRef.current && !isPointerDownOnContentRef.current) {
      closeTimerRef.current = window.setTimeout(() => setOpen(false), closeDelay);
    }
  }, [closeDelay, setOpen]);
  const handleDismiss = React110.useCallback(() => setOpen(false), [setOpen]);
  React110.useEffect(() => {
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
    HoverCardProvider,
    {
      scope: __scopeHoverCard,
      open,
      onOpenChange: setOpen,
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Root23, __spreadProps(__spreadValues({}, popperScope), { children }))
    }
  );
};
HoverCard.displayName = HOVERCARD_NAME;
var TRIGGER_NAME10 = "HoverCardTrigger";
var HoverCardTrigger = React110.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeHoverCard } = _a, triggerProps = __objRest(_a, ["__scopeHoverCard"]);
    const context = useHoverCardContext(TRIGGER_NAME10, __scopeHoverCard);
    const popperScope = usePopperScope4(__scopeHoverCard);
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Anchor, __spreadProps(__spreadValues({ asChild: true }, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
      Primitive.a,
      __spreadProps(__spreadValues({
        "data-state": context.open ? "open" : "closed"
      }, triggerProps), {
        ref: forwardedRef,
        onPointerEnter: composeEventHandlers(props2.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props2.onPointerLeave, excludeTouch(context.onClose)),
        onFocus: composeEventHandlers(props2.onFocus, context.onOpen),
        onBlur: composeEventHandlers(props2.onBlur, context.onClose),
        onTouchStart: composeEventHandlers(props2.onTouchStart, (event) => event.preventDefault())
      })
    ) }));
  }
);
HoverCardTrigger.displayName = TRIGGER_NAME10;
var PORTAL_NAME11 = "HoverCardPortal";
var [PortalProvider5, usePortalContext5] = createHoverCardContext(PORTAL_NAME11, {
  forceMount: void 0
});
var HoverCardPortal = (props2) => {
  const { __scopeHoverCard, forceMount, children, container } = props2;
  const context = useHoverCardContext(PORTAL_NAME11, __scopeHoverCard);
  return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(PortalProvider5, { scope: __scopeHoverCard, forceMount, children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Portal, { asChild: true, container, children }) }) });
};
HoverCardPortal.displayName = PORTAL_NAME11;
var CONTENT_NAME12 = "HoverCardContent";
var HoverCardContent = React110.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext5(CONTENT_NAME12, props2.__scopeHoverCard);
    const _a = props2, { forceMount = portalContext.forceMount } = _a, contentProps = __objRest(_a, ["forceMount"]);
    const context = useHoverCardContext(CONTENT_NAME12, props2.__scopeHoverCard);
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
      HoverCardContentImpl,
      __spreadProps(__spreadValues({
        "data-state": context.open ? "open" : "closed"
      }, contentProps), {
        onPointerEnter: composeEventHandlers(props2.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props2.onPointerLeave, excludeTouch(context.onClose)),
        ref: forwardedRef
      })
    ) });
  }
);
HoverCardContent.displayName = CONTENT_NAME12;
var HoverCardContentImpl = React110.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    __scopeHoverCard,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside
  } = _a, contentProps = __objRest(_a, [
    "__scopeHoverCard",
    "onEscapeKeyDown",
    "onPointerDownOutside",
    "onFocusOutside",
    "onInteractOutside"
  ]);
  const context = useHoverCardContext(CONTENT_NAME12, __scopeHoverCard);
  const popperScope = usePopperScope4(__scopeHoverCard);
  const ref2 = React110.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const [containSelection, setContainSelection] = React110.useState(false);
  React110.useEffect(() => {
    if (containSelection) {
      const body = document.body;
      originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      return () => {
        body.style.userSelect = originalBodyUserSelect;
        body.style.webkitUserSelect = originalBodyUserSelect;
      };
    }
  }, [containSelection]);
  React110.useEffect(() => {
    if (ref2.current) {
      const handlePointerUp2 = () => {
        setContainSelection(false);
        context.isPointerDownOnContentRef.current = false;
        setTimeout(() => {
          var _a2;
          const hasSelection = ((_a2 = document.getSelection()) == null ? void 0 : _a2.toString()) !== "";
          if (hasSelection)
            context.hasSelectionRef.current = true;
        });
      };
      document.addEventListener("pointerup", handlePointerUp2);
      return () => {
        document.removeEventListener("pointerup", handlePointerUp2);
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = false;
      };
    }
  }, [context.isPointerDownOnContentRef, context.hasSelectionRef]);
  React110.useEffect(() => {
    if (ref2.current) {
      const tabbables = getTabbableNodes(ref2.current);
      tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
    }
  });
  return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
    DismissableLayer,
    {
      asChild: true,
      disableOutsidePointerEvents: false,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside: composeEventHandlers(onFocusOutside, (event) => {
        event.preventDefault();
      }),
      onDismiss: context.onDismiss,
      children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
        Content4,
        __spreadProps(__spreadValues(__spreadValues({}, popperScope), contentProps), {
          onPointerDown: composeEventHandlers(contentProps.onPointerDown, (event) => {
            if (event.currentTarget.contains(event.target)) {
              setContainSelection(true);
            }
            context.hasSelectionRef.current = false;
            context.isPointerDownOnContentRef.current = true;
          }),
          ref: composedRefs,
          style: __spreadValues(__spreadProps(__spreadValues({}, contentProps.style), {
            userSelect: containSelection ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: containSelection ? "text" : void 0
          }), {
            "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
            "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
            "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
          })
        })
      )
    }
  );
});
var ARROW_NAME7 = "HoverCardArrow";
var HoverCardArrow = React110.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeHoverCard } = _a, arrowProps = __objRest(_a, ["__scopeHoverCard"]);
    const popperScope = usePopperScope4(__scopeHoverCard);
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Arrow2, __spreadProps(__spreadValues(__spreadValues({}, popperScope), arrowProps), { ref: forwardedRef }));
  }
);
HoverCardArrow.displayName = ARROW_NAME7;
function excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
var Root28 = HoverCard;
var Trigger9 = HoverCardTrigger;
var Content28 = HoverCardContent;

// src/components/hover-card.tsx
var import_utils31 = require("@nubras/utils");
var import_jsx_runtime57 = require("react/jsx-runtime");
var HoverCard2 = Root28;
var HoverCardTrigger2 = Trigger9;
var HoverCardContent2 = React111.forwardRef((_a, ref2) => {
  var _b = _a, { className, align = "center", sideOffset = 4 } = _b, props2 = __objRest(_b, ["className", "align", "sideOffset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
    Content28,
    __spreadValues({
      ref: ref2,
      align,
      sideOffset,
      className: (0, import_utils31.cn)(
        "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  );
});
HoverCardContent2.displayName = Content28.displayName;

// src/components/input-otp.tsx
var React112 = __toESM(require("react"));

// ../../node_modules/.pnpm/input-otp@1.4.1_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/input-otp/dist/index.mjs
var n2 = __toESM(require("react"), 1);
var U2 = __toESM(require("react"), 1);
var S = __toESM(require("react"), 1);
var Bt = Object.defineProperty;
var At = Object.defineProperties;
var kt = Object.getOwnPropertyDescriptors;
var Y3 = Object.getOwnPropertySymbols;
var gt = Object.prototype.hasOwnProperty;
var Et = Object.prototype.propertyIsEnumerable;
var vt = (r2, s, e) => s in r2 ? Bt(r2, s, { enumerable: true, configurable: true, writable: true, value: e }) : r2[s] = e;
var St = (r2, s) => {
  for (var e in s || (s = {}))
    gt.call(s, e) && vt(r2, e, s[e]);
  if (Y3)
    for (var e of Y3(s))
      Et.call(s, e) && vt(r2, e, s[e]);
  return r2;
};
var bt = (r2, s) => At(r2, kt(s));
var Pt = (r2, s) => {
  var e = {};
  for (var u2 in r2)
    gt.call(r2, u2) && s.indexOf(u2) < 0 && (e[u2] = r2[u2]);
  if (r2 != null && Y3)
    for (var u2 of Y3(r2))
      s.indexOf(u2) < 0 && Et.call(r2, u2) && (e[u2] = r2[u2]);
  return e;
};
function ht(r2) {
  let s = setTimeout(r2, 0), e = setTimeout(r2, 10), u2 = setTimeout(r2, 50);
  return [s, e, u2];
}
function _t(r2) {
  let s = U2.useRef();
  return U2.useEffect(() => {
    s.current = r2;
  }), s.current;
}
var Ot = 18;
var wt = 40;
var Gt = `${wt}px`;
var xt = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
function Tt({ containerRef: r2, inputRef: s, pushPasswordManagerStrategy: e, isFocused: u2 }) {
  let [P, D2] = S.useState(false), [G3, H2] = S.useState(false), [F, W2] = S.useState(false), Z2 = S.useMemo(() => e === "none" ? false : (e === "increase-width" || e === "experimental-no-flickering") && P && G3, [P, G3, e]), T2 = S.useCallback(() => {
    let f = r2.current, h = s.current;
    if (!f || !h || F || e === "none")
      return;
    let a = f, B2 = a.getBoundingClientRect().left + a.offsetWidth, A = a.getBoundingClientRect().top + a.offsetHeight / 2, z2 = B2 - Ot, q = A;
    document.querySelectorAll(xt).length === 0 && document.elementFromPoint(z2, q) === f || (D2(true), W2(true));
  }, [r2, s, F, e]);
  return S.useEffect(() => {
    let f = r2.current;
    if (!f || e === "none")
      return;
    function h() {
      let A = window.innerWidth - f.getBoundingClientRect().right;
      H2(A >= wt);
    }
    h();
    let a = setInterval(h, 1e3);
    return () => {
      clearInterval(a);
    };
  }, [r2, e]), S.useEffect(() => {
    let f = u2 || document.activeElement === s.current;
    if (e === "none" || !f)
      return;
    let h = setTimeout(T2, 0), a = setTimeout(T2, 2e3), B2 = setTimeout(T2, 5e3), A = setTimeout(() => {
      W2(true);
    }, 6e3);
    return () => {
      clearTimeout(h), clearTimeout(a), clearTimeout(B2), clearTimeout(A);
    };
  }, [s, u2, e, T2]), { hasPWMBadge: P, willPushPWMBadge: Z2, PWM_BADGE_SPACE_WIDTH: Gt };
}
var jt = n2.createContext({});
var Lt = n2.forwardRef((A, B2) => {
  var z2 = A, { value: r2, onChange: s, maxLength: e, textAlign: u2 = "left", pattern: P, placeholder: D2, inputMode: G3 = "numeric", onComplete: H2, pushPasswordManagerStrategy: F = "increase-width", pasteTransformer: W2, containerClassName: Z2, noScriptCSSFallback: T2 = Nt, render: f, children: h } = z2, a = Pt(z2, ["value", "onChange", "maxLength", "textAlign", "pattern", "placeholder", "inputMode", "onComplete", "pushPasswordManagerStrategy", "pasteTransformer", "containerClassName", "noScriptCSSFallback", "render", "children"]);
  var X3, lt, ut, dt, ft;
  let [q, nt] = n2.useState(typeof a.defaultValue == "string" ? a.defaultValue : ""), i = r2 != null ? r2 : q, I2 = _t(i), x2 = n2.useCallback((t2) => {
    s == null || s(t2), nt(t2);
  }, [s]), m2 = n2.useMemo(() => P ? typeof P == "string" ? new RegExp(P) : P : null, [P]), l = n2.useRef(null), K3 = n2.useRef(null), J2 = n2.useRef({ value: i, onChange: x2, isIOS: typeof window != "undefined" && ((lt = (X3 = window == null ? void 0 : window.CSS) == null ? void 0 : X3.supports) == null ? void 0 : lt.call(X3, "-webkit-touch-callout", "none")) }), V = n2.useRef({ prev: [(ut = l.current) == null ? void 0 : ut.selectionStart, (dt = l.current) == null ? void 0 : dt.selectionEnd, (ft = l.current) == null ? void 0 : ft.selectionDirection] });
  n2.useImperativeHandle(B2, () => l.current, []), n2.useEffect(() => {
    let t2 = l.current, o2 = K3.current;
    if (!t2 || !o2)
      return;
    J2.current.value !== t2.value && J2.current.onChange(t2.value), V.current.prev = [t2.selectionStart, t2.selectionEnd, t2.selectionDirection];
    function d() {
      if (document.activeElement !== t2) {
        L(null), N2(null);
        return;
      }
      let c = t2.selectionStart, b = t2.selectionEnd, mt = t2.selectionDirection, v2 = t2.maxLength, C = t2.value, _2 = V.current.prev, g = -1, E2 = -1, w;
      if (C.length !== 0 && c !== null && b !== null) {
        let Dt = c === b, Ht = c === C.length && C.length < v2;
        if (Dt && !Ht) {
          let y = c;
          if (y === 0)
            g = 0, E2 = 1, w = "forward";
          else if (y === v2)
            g = y - 1, E2 = y, w = "backward";
          else if (v2 > 1 && C.length > 1) {
            let et = 0;
            if (_2[0] !== null && _2[1] !== null) {
              w = y < _2[1] ? "backward" : "forward";
              let Wt2 = _2[0] === _2[1] && _2[0] < v2;
              w === "backward" && !Wt2 && (et = -1);
            }
            g = et + y, E2 = et + y + 1;
          }
        }
        g !== -1 && E2 !== -1 && g !== E2 && l.current.setSelectionRange(g, E2, w);
      }
      let pt = g !== -1 ? g : c, Rt = E2 !== -1 ? E2 : b, yt2 = w != null ? w : mt;
      L(pt), N2(Rt), V.current.prev = [pt, Rt, yt2];
    }
    if (document.addEventListener("selectionchange", d, { capture: true }), d(), document.activeElement === t2 && Q2(true), !document.getElementById("input-otp-style")) {
      let c = document.createElement("style");
      if (c.id = "input-otp-style", document.head.appendChild(c), c.sheet) {
        let b = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        $2(c.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), $2(c.sheet, `[data-input-otp]:autofill { ${b} }`), $2(c.sheet, `[data-input-otp]:-webkit-autofill { ${b} }`), $2(c.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), $2(c.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
      }
    }
    let p2 = () => {
      o2 && o2.style.setProperty("--root-height", `${t2.clientHeight}px`);
    };
    p2();
    let R = new ResizeObserver(p2);
    return R.observe(t2), () => {
      document.removeEventListener("selectionchange", d, { capture: true }), R.disconnect();
    };
  }, []);
  let [ot, rt] = n2.useState(false), [j2, Q2] = n2.useState(false), [M4, L] = n2.useState(null), [k3, N2] = n2.useState(null);
  n2.useEffect(() => {
    ht(() => {
      var p2, R, c, b;
      (p2 = l.current) == null || p2.dispatchEvent(new Event("input"));
      let t2 = (R = l.current) == null ? void 0 : R.selectionStart, o2 = (c = l.current) == null ? void 0 : c.selectionEnd, d = (b = l.current) == null ? void 0 : b.selectionDirection;
      t2 !== null && o2 !== null && (L(t2), N2(o2), V.current.prev = [t2, o2, d]);
    });
  }, [i, j2]), n2.useEffect(() => {
    I2 !== void 0 && i !== I2 && I2.length < e && i.length === e && (H2 == null || H2(i));
  }, [e, H2, I2, i]);
  let O = Tt({ containerRef: K3, inputRef: l, pushPasswordManagerStrategy: F, isFocused: j2 }), st = n2.useCallback((t2) => {
    let o2 = t2.currentTarget.value.slice(0, e);
    if (o2.length > 0 && m2 && !m2.test(o2)) {
      t2.preventDefault();
      return;
    }
    typeof I2 == "string" && o2.length < I2.length && document.dispatchEvent(new Event("selectionchange")), x2(o2);
  }, [e, x2, I2, m2]), at = n2.useCallback(() => {
    var t2;
    if (l.current) {
      let o2 = Math.min(l.current.value.length, e - 1), d = l.current.value.length;
      (t2 = l.current) == null || t2.setSelectionRange(o2, d), L(o2), N2(d);
    }
    Q2(true);
  }, [e]), ct = n2.useCallback((t2) => {
    var g, E2;
    let o2 = l.current;
    if (!W2 && (!J2.current.isIOS || !t2.clipboardData || !o2))
      return;
    let d = t2.clipboardData.getData("text/plain"), p2 = W2 ? W2(d) : d;
    console.log({ _content: d, content: p2 }), t2.preventDefault();
    let R = (g = l.current) == null ? void 0 : g.selectionStart, c = (E2 = l.current) == null ? void 0 : E2.selectionEnd, v2 = (R !== c ? i.slice(0, R) + p2 + i.slice(c) : i.slice(0, R) + p2 + i.slice(R)).slice(0, e);
    if (v2.length > 0 && m2 && !m2.test(v2))
      return;
    o2.value = v2, x2(v2);
    let C = Math.min(v2.length, e - 1), _2 = v2.length;
    o2.setSelectionRange(C, _2), L(C), N2(_2);
  }, [e, x2, m2, i]), It = n2.useMemo(() => ({ position: "relative", cursor: a.disabled ? "default" : "text", userSelect: "none", WebkitUserSelect: "none", pointerEvents: "none" }), [a.disabled]), it = n2.useMemo(() => ({ position: "absolute", inset: 0, width: O.willPushPWMBadge ? `calc(100% + ${O.PWM_BADGE_SPACE_WIDTH})` : "100%", clipPath: O.willPushPWMBadge ? `inset(0 ${O.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0, height: "100%", display: "flex", textAlign: u2, opacity: "1", color: "transparent", pointerEvents: "all", background: "transparent", caretColor: "transparent", border: "0 solid transparent", outline: "0 solid transparent", boxShadow: "none", lineHeight: "1", letterSpacing: "-.5em", fontSize: "var(--root-height)", fontFamily: "monospace", fontVariantNumeric: "tabular-nums" }), [O.PWM_BADGE_SPACE_WIDTH, O.willPushPWMBadge, u2]), Mt = n2.useMemo(() => n2.createElement("input", bt(St({ autoComplete: a.autoComplete || "one-time-code" }, a), { "data-input-otp": true, "data-input-otp-placeholder-shown": i.length === 0 || void 0, "data-input-otp-mss": M4, "data-input-otp-mse": k3, inputMode: G3, pattern: m2 == null ? void 0 : m2.source, "aria-placeholder": D2, style: it, maxLength: e, value: i, ref: l, onPaste: (t2) => {
    var o2;
    ct(t2), (o2 = a.onPaste) == null || o2.call(a, t2);
  }, onChange: st, onMouseOver: (t2) => {
    var o2;
    rt(true), (o2 = a.onMouseOver) == null || o2.call(a, t2);
  }, onMouseLeave: (t2) => {
    var o2;
    rt(false), (o2 = a.onMouseLeave) == null || o2.call(a, t2);
  }, onFocus: (t2) => {
    var o2;
    at(), (o2 = a.onFocus) == null || o2.call(a, t2);
  }, onBlur: (t2) => {
    var o2;
    Q2(false), (o2 = a.onBlur) == null || o2.call(a, t2);
  } })), [st, at, ct, G3, it, e, k3, M4, a, m2 == null ? void 0 : m2.source, i]), tt2 = n2.useMemo(() => ({ slots: Array.from({ length: e }).map((t2, o2) => {
    var c;
    let d = j2 && M4 !== null && k3 !== null && (M4 === k3 && o2 === M4 || o2 >= M4 && o2 < k3), p2 = i[o2] !== void 0 ? i[o2] : null, R = i[0] !== void 0 ? null : (c = D2 == null ? void 0 : D2[o2]) != null ? c : null;
    return { char: p2, placeholderChar: R, isActive: d, hasFakeCaret: d && p2 === null };
  }), isFocused: j2, isHovering: !a.disabled && ot }), [j2, ot, e, k3, M4, a.disabled, i]), Ct = n2.useMemo(() => f ? f(tt2) : n2.createElement(jt.Provider, { value: tt2 }, h), [h, tt2, f]);
  return n2.createElement(n2.Fragment, null, T2 !== null && n2.createElement("noscript", null, n2.createElement("style", null, T2)), n2.createElement("div", { ref: K3, "data-input-otp-container": true, style: It, className: Z2 }, Ct, n2.createElement("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" } }, Mt)));
});
Lt.displayName = "Input";
function $2(r2, s) {
  try {
    r2.insertRule(s);
  } catch (e) {
    console.error("input-otp could not insert CSS rule:", s);
  }
}
var Nt = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;

// src/components/input-otp.tsx
var import_utils32 = require("@nubras/utils");
var import_jsx_runtime58 = require("react/jsx-runtime");
var InputOTP = React112.forwardRef((_a, ref2) => {
  var _b = _a, { className, containerClassName } = _b, props2 = __objRest(_b, ["className", "containerClassName"]);
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
    Lt,
    __spreadValues({
      ref: ref2,
      containerClassName: (0, import_utils32.cn)(
        "flex items-center gap-2 has-[:disabled]:opacity-50",
        containerClassName
      ),
      className: (0, import_utils32.cn)("disabled:cursor-not-allowed", className)
    }, props2)
  );
});
InputOTP.displayName = "InputOTP";
var InputOTPGroup = React112.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", __spreadValues({ ref: ref2, className: (0, import_utils32.cn)("flex items-center", className) }, props2));
});
InputOTPGroup.displayName = "InputOTPGroup";
var InputOTPSlot = React112.forwardRef((_a, ref2) => {
  var _b = _a, { index: index2, className } = _b, props2 = __objRest(_b, ["index", "className"]);
  const inputOTPContext = React112.useContext(jt);
  const { char, hasFakeCaret, isActive: isActive2 } = inputOTPContext.slots[index2];
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(
    "div",
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils32.cn)(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive2 && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )
    }, props2), {
      children: [
        char,
        hasFakeCaret && /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { className: "pointer-events-none absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { className: "h-4 w-px animate-caret-blink bg-foreground duration-1000" }) })
      ]
    })
  );
});
InputOTPSlot.displayName = "InputOTPSlot";
var InputOTPSeparator = React112.forwardRef((_a, ref2) => {
  var props2 = __objRest(_a, []);
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", __spreadProps(__spreadValues({ ref: ref2, role: "separator" }, props2), { children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Dot, {}) }));
});
InputOTPSeparator.displayName = "InputOTPSeparator";

// ../../node_modules/.pnpm/@hello-pangea+dnd@18.0.1_@types+react@19.1.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@hello-pangea/dnd/dist/dnd.esm.js
var import_react42 = __toESM(require("react"));
var import_react_dom4 = __toESM(require("react-dom"));

// ../../node_modules/.pnpm/redux@5.0.1/node_modules/redux/dist/redux.mjs
function formatProdErrorMessage(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject2(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate2(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate2(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (process.env.NODE_ENV !== "production") {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer4, preloadedState, enhancer) {
  if (typeof reducer4 !== "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer4)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer4, preloadedState);
  }
  let currentReducer = reducer4;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState9() {
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe2(listener) {
    if (typeof listener !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch3(action) {
    if (!isPlainObject2(action)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners3 = currentListeners = nextListeners;
    listeners3.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch3({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe2;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState9());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch3({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch: dispatch3,
    subscribe: subscribe2,
    getState: getState9,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function bindActionCreator(actionCreator, dispatch3) {
  return function(...args) {
    return dispatch3(actionCreator.apply(this, args));
  };
}
function bindActionCreators(actionCreators, dispatch3) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch3);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(16) : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  }
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch3);
    }
  }
  return boundActionCreators;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore22) => (reducer4, preloadedState) => {
    const store = createStore22(reducer4, preloadedState);
    let dispatch3 = () => {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch3(action, ...args)
    };
    const chain2 = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch3 = compose(...chain2)(store.dispatch);
    return __spreadProps(__spreadValues({}, store), {
      dispatch: dispatch3
    });
  };
}

// ../../node_modules/.pnpm/react-redux@9.2.0_@types+react@19.1.3_react@19.1.0_redux@5.0.1/node_modules/react-redux/dist/react-redux.mjs
var React113 = __toESM(require("react"), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var IS_REACT_19 = /* @__PURE__ */ React113.version.startsWith("19");
var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(
  IS_REACT_19 ? "react.transitional.element" : "react.element"
);
var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(
  "react.suspense_list"
);
var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(
  "react.client.reference"
);
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function isValidElementType(type) {
  return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;
}
function typeOf(object) {
  if (typeof object === "object" && object !== null) {
    const { $$typeof } = object;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        switch (object = object.type, object) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return object;
          default:
            switch (object = object && object.$$typeof, object) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
                return object;
              case REACT_CONSUMER_TYPE:
                return object;
              default:
                return $$typeof;
            }
        }
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }
}
function isContextConsumer(object) {
  return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function warning(message2) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message2);
  }
  try {
    throw new Error(message2);
  } catch (e) {
  }
}
function verify(selector, methodName) {
  if (!selector) {
    throw new Error(`Unexpected value for ${methodName} in connect.`);
  } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
    if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
      warning(
        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`
      );
    }
  }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps3) {
  verify(mapStateToProps, "mapStateToProps");
  verify(mapDispatchToProps2, "mapDispatchToProps");
  verify(mergeProps3, "mergeProps");
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps3, dispatch3, {
  areStatesEqual,
  areOwnPropsEqual,
  areStatePropsEqual
}) {
  let hasRunAtLeastOnce = false;
  let state;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch3, ownProps);
    mergedProps = mergeProps3(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch3, ownProps);
    mergedProps = mergeProps3(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch3, ownProps);
    mergedProps = mergeProps3(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps3(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(
      nextState,
      state,
      nextOwnProps,
      ownProps
    );
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch3, _a) {
  var _b = _a, {
    initMapStateToProps,
    initMapDispatchToProps,
    initMergeProps
  } = _b, options = __objRest(_b, [
    "initMapStateToProps",
    "initMapDispatchToProps",
    "initMergeProps"
  ]);
  const mapStateToProps = initMapStateToProps(dispatch3, options);
  const mapDispatchToProps2 = initMapDispatchToProps(dispatch3, options);
  const mergeProps3 = initMergeProps(dispatch3, options);
  if (process.env.NODE_ENV !== "production") {
    verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps3);
  }
  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps3, dispatch3, options);
}
function bindActionCreators2(actionCreators, dispatch3) {
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = (...args) => dispatch3(actionCreator(...args));
    }
  }
  return boundActionCreators;
}
function isPlainObject3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  const proto = Object.getPrototypeOf(obj);
  if (proto === null)
    return true;
  let baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
function verifyPlainObject(value, displayName, methodName) {
  if (!isPlainObject3(value)) {
    warning(
      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`
    );
  }
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch3) {
    const constant = getConstant(dispatch3);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch3, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props2 = proxy(stateOrDispatch, ownProps);
      if (typeof props2 === "function") {
        proxy.mapToProps = props2;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props2);
        props2 = proxy(stateOrDispatch, ownProps);
      }
      if (process.env.NODE_ENV !== "production")
        verifyPlainObject(props2, displayName, methodName);
      return props2;
    };
    return proxy;
  };
}
function createInvalidArgFactory(arg, name) {
  return (dispatch3, options) => {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`
    );
  };
}
function mapDispatchToPropsFactory(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant(
    (dispatch3) => (
      // @ts-ignore
      bindActionCreators2(mapDispatchToProps2, dispatch3)
    )
  ) : !mapDispatchToProps2 ? wrapMapToPropsConstant((dispatch3) => ({
    dispatch: dispatch3
  })) : typeof mapDispatchToProps2 === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps2, "mapDispatchToProps")
  ) : createInvalidArgFactory(mapDispatchToProps2, "mapDispatchToProps");
}
function mapStateToPropsFactory(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps, "mapStateToProps")
  ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return __spreadValues(__spreadValues(__spreadValues({}, ownProps), stateProps), dispatchProps);
}
function wrapMergePropsFunc(mergeProps3) {
  return function initMergePropsProxy(dispatch3, { displayName, areMergedPropsEqual }) {
    let hasRunOnce = false;
    let mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps3(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (process.env.NODE_ENV !== "production")
          verifyPlainObject(mergedProps, displayName, "mergeProps");
      }
      return mergedProps;
    };
  };
}
function mergePropsFactory(mergeProps3) {
  return !mergeProps3 ? () => defaultMergeProps : typeof mergeProps3 === "function" ? wrapMergePropsFunc(mergeProps3) : createInvalidArgFactory(mergeProps3, "mergeProps");
}
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners3 = [];
      let listener = first;
      while (listener) {
        listeners3.push(listener);
        listener = listener.next;
      }
      return listeners3;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners3 = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners3.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners3.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners3 = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners3.clear();
      listeners3 = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners3
  };
  return subscription;
}
var canUseDOM2 = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM2();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React113.useLayoutEffect : React113.useEffect;
var useIsomorphicLayoutEffect4 = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
function is(x2, y) {
  if (x2 === y) {
    return x2 !== 0 || y !== 0 || 1 / x2 === 1 / y;
  } else {
    return x2 !== x2 && y !== y;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
function getStatics(component) {
  if (isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      const inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent);
      }
    }
    let keys = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }
    const targetStatics = getStatics(targetComponent);
    const sourceStatics = getStatics(sourceComponent);
    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {
        }
      }
    }
  }
  return targetComponent;
}
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  var _a;
  if (!React113.createContext)
    return {};
  const contextMap = (_a = gT[ContextKey]) != null ? _a : gT[ContextKey] = /* @__PURE__ */ new Map();
  let realContext = contextMap.get(React113.createContext);
  if (!realContext) {
    realContext = React113.createContext(
      null
    );
    if (process.env.NODE_ENV !== "production") {
      realContext.displayName = "ReactRedux";
    }
    contextMap.set(React113.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
var NO_SUBSCRIPTION_ARRAY = [null, null];
var stringifyComponent = (Comp) => {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect4(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges)
    return () => {
    };
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store.getState();
    let newChildProps, error2;
    try {
      newChildProps = childPropsSelector(
        latestStoreState,
        lastWrapperProps.current
      );
    } catch (e) {
      error2 = e;
      lastThrownError = e;
    }
    if (!error2) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a, b) {
  return a === b;
}
var hasWarnedAboutDeprecatedPureOption = false;
function connect(mapStateToProps, mapDispatchToProps2, mergeProps3, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual = shallowEqual,
  areStatePropsEqual = shallowEqual,
  areMergedPropsEqual = shallowEqual,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef: forwardRef90 = false,
  // the context consumer to use
  context = ReactReduxContext
} = {}) {
  if (process.env.NODE_ENV !== "production") {
    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
      hasWarnedAboutDeprecatedPureOption = true;
      warning(
        'The `pure` option has been removed. `connect` is now always a "pure/memoized" component'
      );
    }
  }
  const Context = context;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps2);
  const initMergeProps = mergePropsFactory(mergeProps3);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = (WrappedComponent) => {
    if (process.env.NODE_ENV !== "production") {
      const isValid2 = /* @__PURE__ */ isValidElementType(WrappedComponent);
      if (!isValid2)
        throw new Error(
          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(
            WrappedComponent
          )}`
        );
    }
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props2) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = React113.useMemo(() => {
        const _a = props2, { reactReduxForwardedRef: reactReduxForwardedRef2 } = _a, wrapperProps2 = __objRest(_a, ["reactReduxForwardedRef"]);
        return [props2.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props2]);
      const ContextToUse = React113.useMemo(() => {
        let ResultContext = Context;
        if (propsContext == null ? void 0 : propsContext.Consumer) {
          if (process.env.NODE_ENV !== "production") {
            const isValid2 = /* @__PURE__ */ isContextConsumer(
              // @ts-ignore
              /* @__PURE__ */ React113.createElement(propsContext.Consumer, null)
            );
            if (!isValid2) {
              throw new Error(
                "You must pass a valid React context consumer as `props.context`"
              );
            }
            ResultContext = propsContext;
          }
        }
        return ResultContext;
      }, [propsContext, Context]);
      const contextValue = React113.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props2.store) && Boolean(props2.store.getState) && Boolean(props2.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      if (process.env.NODE_ENV !== "production" && !didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error(
          `Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`
        );
      }
      const store = didStoreComeFromProps ? props2.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector = React113.useMemo(() => {
        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
      }, [store]);
      const [subscription, notifyNestedSubs] = React113.useMemo(() => {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(
          store,
          didStoreComeFromProps ? void 0 : contextValue.subscription
        );
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = React113.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return __spreadProps(__spreadValues({}, contextValue), {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = React113.useRef(void 0);
      const lastWrapperProps = React113.useRef(wrapperProps);
      const childPropsFromStoreUpdate = React113.useRef(void 0);
      const renderIsScheduled = React113.useRef(false);
      const isMounted = React113.useRef(false);
      const latestSubscriptionCallbackError = React113.useRef(
        void 0
      );
      useIsomorphicLayoutEffect4(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = React113.useMemo(() => {
        const selector = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector;
      }, [store, wrapperProps]);
      const subscribeForReact = React113.useMemo(() => {
        const subscribe2 = (reactListener) => {
          if (!subscription) {
            return () => {
            };
          }
          return subscribeUpdates(
            shouldHandleStateChanges,
            store,
            subscription,
            // @ts-ignore
            childPropsSelector,
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            isMounted,
            childPropsFromStoreUpdate,
            notifyNestedSubs,
            reactListener
          );
        };
        return subscribe2;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
        lastWrapperProps,
        lastChildProps,
        renderIsScheduled,
        wrapperProps,
        childPropsFromStoreUpdate,
        notifyNestedSubs
      ]);
      let actualChildProps;
      try {
        actualChildProps = React113.useSyncExternalStore(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          subscribeForReact,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          actualChildPropsSelector,
          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
        );
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          ;
          err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
        }
        throw err;
      }
      useIsomorphicLayoutEffect4(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = React113.useMemo(() => {
        return (
          // @ts-ignore
          /* @__PURE__ */ React113.createElement(
            WrappedComponent,
            __spreadProps(__spreadValues({}, actualChildProps), {
              ref: reactReduxForwardedRef
            })
          )
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = React113.useMemo(() => {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ React113.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = React113.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef90) {
      const _forwarded = React113.forwardRef(
        function forwardConnectRef(props2, ref2) {
          return /* @__PURE__ */ React113.createElement(Connect, __spreadProps(__spreadValues({}, props2), { reactReduxForwardedRef: ref2 }));
        }
      );
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);
    }
    return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
var connect_default = connect;
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = React113.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    if (process.env.NODE_ENV === "production") {
      return baseContextValue;
    } else {
      const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
      return /* @__PURE__ */ Object.assign(baseContextValue, {
        stabilityCheck,
        identityFunctionCheck
      });
    }
  }, [store, serverState]);
  const previousState = React113.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect4(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */ React113.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;

// ../../node_modules/.pnpm/tiny-invariant@1.3.3/node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = process.env.NODE_ENV === "production";
var prefix = "Invariant failed";
function invariant(condition, message2) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message2 === "function" ? message2() : message2;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// ../../node_modules/.pnpm/css-box-model@1.2.1/node_modules/css-box-model/dist/css-box-model.esm.js
var getRect = function getRect2(_ref) {
  var top = _ref.top, right = _ref.right, bottom = _ref.bottom, left = _ref.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top,
    right,
    bottom,
    left,
    width,
    height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var shift4 = function shift5(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse2 = function parse3(raw) {
  var value = raw.slice(0, -2);
  var suffix2 = raw.slice(-2);
  if (suffix2 !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? process.env.NODE_ENV !== "production" ? invariant(false, "Could not parse value [raw: " + raw + ", without suffix: " + value + "]") : invariant(false) : void 0;
  return result;
};
var getWindowScroll = function getWindowScroll2() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset4 = function offset5(original, change) {
  var borderBox = original.borderBox, border = original.border, margin = original.margin, padding = original.padding;
  var shifted = shift4(borderBox, change);
  return createBox({
    borderBox: shifted,
    border,
    margin,
    padding
  });
};
var withScroll = function withScroll2(original, scroll2) {
  if (scroll2 === void 0) {
    scroll2 = getWindowScroll();
  }
  return offset4(original, scroll2);
};
var calculateBox = function calculateBox2(borderBox, styles) {
  var margin = {
    top: parse2(styles.marginTop),
    right: parse2(styles.marginRight),
    bottom: parse2(styles.marginBottom),
    left: parse2(styles.marginLeft)
  };
  var padding = {
    top: parse2(styles.paddingTop),
    right: parse2(styles.paddingRight),
    bottom: parse2(styles.paddingBottom),
    left: parse2(styles.paddingLeft)
  };
  var border = {
    top: parse2(styles.borderTopWidth),
    right: parse2(styles.borderRightWidth),
    bottom: parse2(styles.borderBottomWidth),
    left: parse2(styles.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el) {
  var borderBox = el.getBoundingClientRect();
  var styles = window.getComputedStyle(el);
  return calculateBox(borderBox, styles);
};

// ../../node_modules/.pnpm/raf-schd@4.0.3/node_modules/raf-schd/dist/raf-schd.esm.js
var rafSchd = function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
var raf_schd_esm_default = rafSchd;

// ../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r2 in t2)
        ({}).hasOwnProperty.call(t2, r2) && (n3[r2] = t2[r2]);
    }
    return n3;
  }, _extends.apply(null, arguments);
}

// ../../node_modules/.pnpm/@hello-pangea+dnd@18.0.1_@types+react@19.1.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@hello-pangea/dnd/dist/dnd.esm.js
var isProduction$1 = process.env.NODE_ENV === "production";
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;
var clean$2 = (value) => value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
var getDevMessage = (message2) => clean$2(`
  %c@hello-pangea/dnd

  %c${clean$2(message2)}

  %c\u{1F477}\u200D This is a development only message. It will be removed in production builds.
`);
var getFormattedMessage = (message2) => [getDevMessage(message2), "color: #00C584; font-size: 1.2em; font-weight: bold;", "line-height: 1.5", "color: #723874;"];
var isDisabledFlag = "__@hello-pangea/dnd-disable-dev-warnings";
function log(type, message2) {
  if (isProduction$1) {
    return;
  }
  if (typeof window !== "undefined" && window[isDisabledFlag]) {
    return;
  }
  console[type](...getFormattedMessage(message2));
}
var warning2 = log.bind(null, "warn");
var error = log.bind(null, "error");
function noop$2() {
}
function getOptions(shared2, fromBinding) {
  return __spreadValues(__spreadValues({}, shared2), fromBinding);
}
function bindEvents(el, bindings, sharedOptions) {
  const unbindings = bindings.map((binding) => {
    const options = getOptions(sharedOptions, binding.options);
    el.addEventListener(binding.eventName, binding.fn, options);
    return function unbind() {
      el.removeEventListener(binding.eventName, binding.fn, options);
    };
  });
  return function unbindAll() {
    unbindings.forEach((unbind) => {
      unbind();
    });
  };
}
var isProduction2 = process.env.NODE_ENV === "production";
var prefix$1 = "Invariant failed";
var RbdInvariant = class extends Error {
};
RbdInvariant.prototype.toString = function toString() {
  return this.message;
};
function invariant2(condition, message2) {
  if (isProduction2) {
    throw new RbdInvariant(prefix$1);
  } else {
    throw new RbdInvariant(`${prefix$1}: ${message2 || ""}`);
  }
}
var ErrorBoundary = class extends import_react42.default.Component {
  constructor(...args) {
    super(...args);
    this.callbacks = null;
    this.unbind = noop$2;
    this.onWindowError = (event) => {
      const callbacks = this.getCallbacks();
      if (callbacks.isDragging()) {
        callbacks.tryAbort();
        process.env.NODE_ENV !== "production" ? warning2(`
        An error was caught by our window 'error' event listener while a drag was occurring.
        The active drag has been aborted.
      `) : void 0;
      }
      const err = event.error;
      if (err instanceof RbdInvariant) {
        event.preventDefault();
        if (process.env.NODE_ENV !== "production") {
          error(err.message);
        }
      }
    };
    this.getCallbacks = () => {
      if (!this.callbacks) {
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      }
      return this.callbacks;
    };
    this.setCallbacks = (callbacks) => {
      this.callbacks = callbacks;
    };
  }
  componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  }
  componentDidCatch(err) {
    if (err instanceof RbdInvariant) {
      if (process.env.NODE_ENV !== "production") {
        error(err.message);
      }
      this.setState({});
      return;
    }
    throw err;
  }
  componentWillUnmount() {
    this.unbind();
  }
  render() {
    return this.props.children(this.setCallbacks);
  }
};
var dragHandleUsageInstructions = `
  Press space bar to start a drag.
  When dragging you can use the arrow keys to move the item around and escape to cancel.
  Some screen readers may require you to be in focus mode or to use your pass through key
`;
var position = (index2) => index2 + 1;
var onDragStart = (start2) => `
  You have lifted an item in position ${position(start2.source.index)}
`;
var withLocation = (source, destination) => {
  const isInHomeList = source.droppableId === destination.droppableId;
  const startPosition = position(source.index);
  const endPosition = position(destination.index);
  if (isInHomeList) {
    return `
      You have moved the item from position ${startPosition}
      to position ${endPosition}
    `;
  }
  return `
    You have moved the item from position ${startPosition}
    in list ${source.droppableId}
    to list ${destination.droppableId}
    in position ${endPosition}
  `;
};
var withCombine = (id, source, combine2) => {
  const inHomeList = source.droppableId === combine2.droppableId;
  if (inHomeList) {
    return `
      The item ${id}
      has been combined with ${combine2.draggableId}`;
  }
  return `
      The item ${id}
      in list ${source.droppableId}
      has been combined with ${combine2.draggableId}
      in list ${combine2.droppableId}
    `;
};
var onDragUpdate = (update2) => {
  const location = update2.destination;
  if (location) {
    return withLocation(update2.source, location);
  }
  const combine2 = update2.combine;
  if (combine2) {
    return withCombine(update2.draggableId, update2.source, combine2);
  }
  return "You are over an area that cannot be dropped on";
};
var returnedToStart = (source) => `
  The item has returned to its starting position
  of ${position(source.index)}
`;
var onDragEnd = (result) => {
  if (result.reason === "CANCEL") {
    return `
      Movement cancelled.
      ${returnedToStart(result.source)}
    `;
  }
  const location = result.destination;
  const combine2 = result.combine;
  if (location) {
    return `
      You have dropped the item.
      ${withLocation(result.source, location)}
    `;
  }
  if (combine2) {
    return `
      You have dropped the item.
      ${withCombine(result.draggableId, result.source, combine2)}
    `;
  }
  return `
    The item has been dropped while not over a drop area.
    ${returnedToStart(result.source)}
  `;
};
var preset = {
  dragHandleUsageInstructions,
  onDragStart,
  onDragUpdate,
  onDragEnd
};
function isEqual$2(first, second) {
  if (first === second) {
    return true;
  }
  if (Number.isNaN(first) && Number.isNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (let i = 0; i < newInputs.length; i++) {
    if (!isEqual$2(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function useMemo17(getResult, inputs) {
  const initial = (0, import_react42.useState)(() => ({
    inputs,
    result: getResult()
  }))[0];
  const isFirstRun = (0, import_react42.useRef)(true);
  const committed = (0, import_react42.useRef)(initial);
  const useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
  const cache2 = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  (0, import_react42.useEffect)(() => {
    isFirstRun.current = false;
    committed.current = cache2;
  }, [cache2]);
  return cache2.result;
}
function useCallback29(callback, inputs) {
  return useMemo17(() => callback, inputs);
}
var origin = {
  x: 0,
  y: 0
};
var add = (point1, point2) => ({
  x: point1.x + point2.x,
  y: point1.y + point2.y
});
var subtract = (point1, point2) => ({
  x: point1.x - point2.x,
  y: point1.y - point2.y
});
var isEqual$1 = (point1, point2) => point1.x === point2.x && point1.y === point2.y;
var negate = (point) => ({
  x: point.x !== 0 ? -point.x : 0,
  y: point.y !== 0 ? -point.y : 0
});
var patch = (line, value, otherValue = 0) => {
  if (line === "x") {
    return {
      x: value,
      y: otherValue
    };
  }
  return {
    x: otherValue,
    y: value
  };
};
var distance = (point1, point2) => Math.sqrt(__pow(point2.x - point1.x, 2) + __pow(point2.y - point1.y, 2));
var closest$1 = (target, points) => Math.min(...points.map((point) => distance(target, point)));
var apply = (fn) => (point) => ({
  x: fn(point.x),
  y: fn(point.y)
});
var executeClip = (frame, subject) => {
  const result = getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });
  if (result.width <= 0 || result.height <= 0) {
    return null;
  }
  return result;
};
var offsetByPosition = (spacing, point) => ({
  top: spacing.top + point.y,
  left: spacing.left + point.x,
  bottom: spacing.bottom + point.y,
  right: spacing.right + point.x
});
var getCorners = (spacing) => [{
  x: spacing.left,
  y: spacing.top
}, {
  x: spacing.right,
  y: spacing.top
}, {
  x: spacing.left,
  y: spacing.bottom
}, {
  x: spacing.right,
  y: spacing.bottom
}];
var noSpacing2 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var scroll$1 = (target, frame) => {
  if (!frame) {
    return target;
  }
  return offsetByPosition(target, frame.scroll.diff.displacement);
};
var increase = (target, axis, withPlaceholder) => {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    return __spreadProps(__spreadValues({}, target), {
      [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]
    });
  }
  return target;
};
var clip = (target, frame) => {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }
  return getRect(target);
};
var getSubject = ({
  page,
  withPlaceholder,
  axis,
  frame
}) => {
  const scrolled = scroll$1(page.marginBox, frame);
  const increased = increase(scrolled, axis, withPlaceholder);
  const clipped = clip(increased, frame);
  return {
    page,
    withPlaceholder,
    active: clipped
  };
};
var scrollDroppable = (droppable2, newScroll) => {
  !droppable2.frame ? process.env.NODE_ENV !== "production" ? invariant2() : invariant2() : void 0;
  const scrollable = droppable2.frame;
  const scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  const scrollDisplacement = negate(scrollDiff);
  const frame = __spreadProps(__spreadValues({}, scrollable), {
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  });
  const subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: droppable2.subject.withPlaceholder,
    axis: droppable2.axis,
    frame
  });
  const result = __spreadProps(__spreadValues({}, droppable2), {
    frame,
    subject
  });
  return result;
};
function memoizeOne(resultFn, isEqual2 = areInputsEqual) {
  let cache2 = null;
  function memoized(...newArgs) {
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    const lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}
var toDroppableMap = memoizeOne((droppables) => droppables.reduce((previous, current) => {
  previous[current.descriptor.id] = current;
  return previous;
}, {}));
var toDraggableMap = memoizeOne((draggables) => draggables.reduce((previous, current) => {
  previous[current.descriptor.id] = current;
  return previous;
}, {}));
var toDroppableList = memoizeOne((droppables) => Object.values(droppables));
var toDraggableList = memoizeOne((draggables) => Object.values(draggables));
var getDraggablesInsideDroppable = memoizeOne((droppableId, draggables) => {
  const result = toDraggableList(draggables).filter((draggable2) => droppableId === draggable2.descriptor.droppableId).sort((a, b) => a.descriptor.index - b.descriptor.index);
  return result;
});
function tryGetDestination(impact) {
  if (impact.at && impact.at.type === "REORDER") {
    return impact.at.destination;
  }
  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === "COMBINE") {
    return impact.at.combine;
  }
  return null;
}
var removeDraggableFromList = memoizeOne((remove, list) => list.filter((item) => item.descriptor.id !== remove.descriptor.id));
var moveToNextCombine = ({
  isMovingForward,
  draggable: draggable2,
  destination,
  insideDestination,
  previousImpact
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const location = tryGetDestination(previousImpact);
  if (!location) {
    return null;
  }
  function getImpact(target) {
    const at = {
      type: "COMBINE",
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return __spreadProps(__spreadValues({}, previousImpact), {
      at
    });
  }
  const all = previousImpact.displaced.all;
  const closestId = all.length ? all[0] : null;
  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }
  const withoutDraggable = removeDraggableFromList(draggable2, insideDestination);
  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }
    const last = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last.descriptor.id);
  }
  const indexOfClosest = withoutDraggable.findIndex((d) => d.descriptor.id === closestId);
  !(indexOfClosest !== -1) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Could not find displaced item in set") : invariant2() : void 0;
  const proposedIndex = indexOfClosest - 1;
  if (proposedIndex < 0) {
    return null;
  }
  const before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
};
var isHomeOf = (draggable2, destination) => draggable2.descriptor.droppableId === destination.descriptor.id;
var noDisplacedBy = {
  point: origin,
  value: 0
};
var emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
var noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};
var isWithin = (lowerBound, upperBound) => (value) => lowerBound <= value && value <= upperBound;
var isPartiallyVisibleThroughFrame = (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    if (isContained) {
      return true;
    }
    const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
    if (isPartiallyContained) {
      return true;
    }
    const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
    if (isTargetBiggerThanFrame) {
      return true;
    }
    const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
};
var isTotallyVisibleThroughFrame = (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
};
var vertical = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
};
var horizontal = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var isTotallyVisibleThroughFrameOnAxis = (axis) => (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    if (axis === vertical) {
      return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
    }
    return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
  };
};
var getDroppableDisplaced = (target, destination) => {
  const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};
var isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn) => {
  if (!destination.subject.active) {
    return false;
  }
  return isVisibleThroughFrameFn(destination.subject.active)(target);
};
var isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport)(target);
var isVisible$1 = ({
  target: toBeDisplaced,
  destination,
  viewport,
  withDroppableDisplacement: withDroppableDisplacement2,
  isVisibleThroughFrameFn
}) => {
  const displacedTarget = withDroppableDisplacement2 ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);
};
var isPartiallyVisible = (args) => isVisible$1(__spreadProps(__spreadValues({}, args), {
  isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
}));
var isTotallyVisible = (args) => isVisible$1(__spreadProps(__spreadValues({}, args), {
  isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
}));
var isTotallyVisibleOnAxis = (args) => isVisible$1(__spreadProps(__spreadValues({}, args), {
  isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
}));
var getShouldAnimate = (id, last, forceShouldAnimate) => {
  if (typeof forceShouldAnimate === "boolean") {
    return forceShouldAnimate;
  }
  if (!last) {
    return true;
  }
  const {
    invisible,
    visible
  } = last;
  if (invisible[id]) {
    return false;
  }
  const previous = visible[id];
  return previous ? previous.shouldAnimate : true;
};
function getTarget(draggable2, displacedBy) {
  const marginBox = draggable2.page.marginBox;
  const expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return getRect(expand(marginBox, expandBy));
}
function getDisplacementGroups({
  afterDragging,
  destination,
  displacedBy,
  viewport,
  forceShouldAnimate,
  last
}) {
  return afterDragging.reduce(function process2(groups, draggable2) {
    const target = getTarget(draggable2, displacedBy);
    const id = draggable2.descriptor.id;
    groups.all.push(id);
    const isVisible2 = isPartiallyVisible({
      target,
      destination,
      viewport,
      withDroppableDisplacement: true
    });
    if (!isVisible2) {
      groups.invisible[draggable2.descriptor.id] = true;
      return groups;
    }
    const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
    const displacement = {
      draggableId: id,
      shouldAnimate
    };
    groups.visible[id] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function getIndexOfLastItem(draggables, options) {
  if (!draggables.length) {
    return 0;
  }
  const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}
function goAtEnd({
  insideDestination,
  inHomeList,
  displacedBy,
  destination
}) {
  const newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}
function calculateReorderImpact({
  draggable: draggable2,
  insideDestination,
  destination,
  viewport,
  displacedBy,
  last,
  index: index2,
  forceShouldAnimate
}) {
  const inHomeList = isHomeOf(draggable2, destination);
  if (index2 == null) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  const match2 = insideDestination.find((item) => item.descriptor.index === index2);
  if (!match2) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const sliceFrom = insideDestination.indexOf(match2);
  const impacted = withoutDragging.slice(sliceFrom);
  const displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination,
    displacedBy,
    last,
    viewport: viewport.frame,
    forceShouldAnimate
  });
  return {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: index2
      }
    }
  };
}
function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}
var fromCombine = ({
  isMovingForward,
  destination,
  draggables,
  combine: combine2,
  afterCritical
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const combineId = combine2.draggableId;
  const combineWith = draggables[combineId];
  const combineWithIndex = combineWith.descriptor.index;
  const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }
    return combineWithIndex - 1;
  }
  if (isMovingForward) {
    return combineWithIndex + 1;
  }
  return combineWithIndex;
};
var fromReorder = ({
  isMovingForward,
  isInHomeList,
  insideDestination,
  location
}) => {
  if (!insideDestination.length) {
    return null;
  }
  const currentIndex = location.index;
  const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  const firstIndex = insideDestination[0].descriptor.index;
  const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  const upperBound = isInHomeList ? lastIndex : lastIndex + 1;
  if (proposedIndex < firstIndex) {
    return null;
  }
  if (proposedIndex > upperBound) {
    return null;
  }
  return proposedIndex;
};
var moveToNextIndex = ({
  isMovingForward,
  isInHomeList,
  draggable: draggable2,
  draggables,
  destination,
  insideDestination,
  previousImpact,
  viewport,
  afterCritical
}) => {
  const wasAt = previousImpact.at;
  !wasAt ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot move in direction without previous impact location") : invariant2() : void 0;
  if (wasAt.type === "REORDER") {
    const newIndex2 = fromReorder({
      isMovingForward,
      isInHomeList,
      location: wasAt.destination,
      insideDestination
    });
    if (newIndex2 == null) {
      return null;
    }
    return calculateReorderImpact({
      draggable: draggable2,
      insideDestination,
      destination,
      viewport,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: newIndex2
    });
  }
  const newIndex = fromCombine({
    isMovingForward,
    destination,
    displaced: previousImpact.displaced,
    draggables,
    combine: wasAt.combine,
    afterCritical
  });
  if (newIndex == null) {
    return null;
  }
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
};
var getCombinedItemDisplacement = ({
  displaced,
  afterCritical,
  combineWith,
  displacedBy
}) => {
  const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }
  return isDisplaced ? displacedBy.point : origin;
};
var whenCombining = ({
  afterCritical,
  impact,
  draggables
}) => {
  const combine2 = tryGetCombine(impact);
  !combine2 ? process.env.NODE_ENV !== "production" ? invariant2() : invariant2() : void 0;
  const combineWith = combine2.draggableId;
  const center = draggables[combineWith].page.borderBox.center;
  const displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical,
    combineWith,
    displacedBy: impact.displacedBy
  });
  return add(center, displaceBy);
};
var distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;
var distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;
var getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
var goAfter = ({
  axis,
  moveRelativeTo,
  isMoving
}) => patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
var goBefore = ({
  axis,
  moveRelativeTo,
  isMoving
}) => patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
var goIntoStart = ({
  axis,
  moveInto,
  isMoving
}) => patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
var whenReordering = ({
  impact,
  draggable: draggable2,
  draggables,
  droppable: droppable2,
  afterCritical
}) => {
  const insideDestination = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  const draggablePage = draggable2.page;
  const axis = droppable2.axis;
  if (!insideDestination.length) {
    return goIntoStart({
      axis,
      moveInto: droppable2.page,
      isMoving: draggablePage
    });
  }
  const {
    displaced,
    displacedBy
  } = impact;
  const closestAfter = displaced.all[0];
  if (closestAfter) {
    const closest2 = draggables[closestAfter];
    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis,
        moveRelativeTo: closest2.page,
        isMoving: draggablePage
      });
    }
    const withDisplacement = offset4(closest2.page, displacedBy.point);
    return goBefore({
      axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }
  const last = insideDestination[insideDestination.length - 1];
  if (last.descriptor.id === draggable2.descriptor.id) {
    return draggablePage.borderBox.center;
  }
  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
    const page = offset4(last.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }
  return goAfter({
    axis,
    moveRelativeTo: last.page,
    isMoving: draggablePage
  });
};
var withDroppableDisplacement = (droppable2, point) => {
  const frame = droppable2.frame;
  if (!frame) {
    return point;
  }
  return add(point, frame.scroll.diff.displacement);
};
var getResultWithoutDroppableDisplacement = ({
  impact,
  draggable: draggable2,
  droppable: droppable2,
  draggables,
  afterCritical
}) => {
  const original = draggable2.page.borderBox.center;
  const at = impact.at;
  if (!droppable2) {
    return original;
  }
  if (!at) {
    return original;
  }
  if (at.type === "REORDER") {
    return whenReordering({
      impact,
      draggable: draggable2,
      draggables,
      droppable: droppable2,
      afterCritical
    });
  }
  return whenCombining({
    impact,
    draggables,
    afterCritical
  });
};
var getPageBorderBoxCenterFromImpact = (args) => {
  const withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  const droppable2 = args.droppable;
  const withDisplacement = droppable2 ? withDroppableDisplacement(droppable2, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
};
var scrollViewport = (viewport, newScroll) => {
  const diff = subtract(newScroll, viewport.scroll.initial);
  const displacement = negate(diff);
  const frame = getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport.frame.width
  });
  const updated = {
    frame,
    scroll: {
      initial: viewport.scroll.initial,
      max: viewport.scroll.max,
      current: newScroll,
      diff: {
        value: diff,
        displacement
      }
    }
  };
  return updated;
};
function getDraggables$1(ids, draggables) {
  return ids.map((id) => draggables[id]);
}
function tryGetVisible(id, groups) {
  for (let i = 0; i < groups.length; i++) {
    const displacement = groups[i].visible[id];
    if (displacement) {
      return displacement;
    }
  }
  return null;
}
var speculativelyIncrease = ({
  impact,
  viewport,
  destination,
  draggables,
  maxScrollChange
}) => {
  const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));
  const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
  const last = impact.displaced;
  const withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables$1(last.all, draggables),
    destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last,
    forceShouldAnimate: false
  });
  const withDroppableScroll2 = getDisplacementGroups({
    afterDragging: getDraggables$1(last.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    last,
    forceShouldAnimate: false
  });
  const invisible = {};
  const visible = {};
  const groups = [last, withViewportScroll, withDroppableScroll2];
  last.all.forEach((id) => {
    const displacement = tryGetVisible(id, groups);
    if (displacement) {
      visible[id] = displacement;
      return;
    }
    invisible[id] = true;
  });
  const newImpact = __spreadProps(__spreadValues({}, impact), {
    displaced: {
      all: last.all,
      invisible,
      visible
    }
  });
  return newImpact;
};
var withViewportDisplacement = (viewport, point) => add(viewport.scroll.diff.displacement, point);
var getClientFromPageBorderBoxCenter = ({
  pageBorderBoxCenter,
  draggable: draggable2,
  viewport
}) => {
  const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);
  const offset6 = subtract(withoutPageScrollChange, draggable2.page.borderBox.center);
  return add(draggable2.client.borderBox.center, offset6);
};
var isTotallyVisibleInNewLocation = ({
  draggable: draggable2,
  destination,
  newPageBorderBoxCenter,
  viewport,
  withDroppableDisplacement: withDroppableDisplacement2,
  onlyOnMainAxis = false
}) => {
  const changeNeeded = subtract(newPageBorderBoxCenter, draggable2.page.borderBox.center);
  const shifted = offsetByPosition(draggable2.page.borderBox, changeNeeded);
  const args = {
    target: shifted,
    destination,
    withDroppableDisplacement: withDroppableDisplacement2,
    viewport
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
};
var moveToNextPlace = ({
  isMovingForward,
  draggable: draggable2,
  destination,
  draggables,
  previousImpact,
  viewport,
  previousPageBorderBoxCenter,
  previousClientSelection,
  afterCritical
}) => {
  if (!destination.isEnabled) {
    return null;
  }
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const isInHomeList = isHomeOf(draggable2, destination);
  const impact = moveToNextCombine({
    isMovingForward,
    draggable: draggable2,
    destination,
    insideDestination,
    previousImpact
  }) || moveToNextIndex({
    isMovingForward,
    isInHomeList,
    draggable: draggable2,
    draggables,
    destination,
    insideDestination,
    previousImpact,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable2,
    destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });
  if (isVisibleInNewLocation) {
    const clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter,
      draggable: draggable2,
      viewport
    });
    return {
      clientSelection,
      impact,
      scrollJumpRequest: null
    };
  }
  const distance2 = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  const cautious = speculativelyIncrease({
    impact,
    viewport,
    destination,
    draggables,
    maxScrollChange: distance2
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance2
  };
};
var getKnownActive = (droppable2) => {
  const rect = droppable2.subject.active;
  !rect ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot get clipped area from droppable") : invariant2() : void 0;
  return rect;
};
var getBestCrossAxisDroppable = ({
  isMovingForward,
  pageBorderBoxCenter,
  source,
  droppables,
  viewport
}) => {
  const active = source.subject.active;
  if (!active) {
    return null;
  }
  const axis = source.axis;
  const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  const candidates = toDroppableList(droppables).filter((droppable2) => droppable2 !== source).filter((droppable2) => droppable2.isEnabled).filter((droppable2) => Boolean(droppable2.subject.active)).filter((droppable2) => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable2))).filter((droppable2) => {
    const activeOfTarget = getKnownActive(droppable2);
    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }
    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter((droppable2) => {
    const activeOfTarget = getKnownActive(droppable2);
    const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort((a, b) => {
    const first = getKnownActive(a)[axis.crossAxisStart];
    const second = getKnownActive(b)[axis.crossAxisStart];
    if (isMovingForward) {
      return first - second;
    }
    return second - first;
  }).filter((droppable2, index2, array) => getKnownActive(droppable2)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  const contains = candidates.filter((droppable2) => {
    const isWithinDroppable = isWithin(getKnownActive(droppable2)[axis.start], getKnownActive(droppable2)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });
  if (contains.length === 1) {
    return contains[0];
  }
  if (contains.length > 1) {
    return contains.sort((a, b) => getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];
  }
  return candidates.sort((a, b) => {
    const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));
    const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));
    if (first !== second) {
      return first - second;
    }
    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
  })[0];
};
var getCurrentPageBorderBoxCenter = (draggable2, afterCritical) => {
  const original = draggable2.page.borderBox.center;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
var getCurrentPageBorderBox = (draggable2, afterCritical) => {
  const original = draggable2.page.borderBox;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};
var getClosestDraggable = ({
  pageBorderBoxCenter,
  viewport,
  destination,
  insideDestination,
  afterCritical
}) => {
  const sorted = insideDestination.filter((draggable2) => isTotallyVisible({
    target: getCurrentPageBorderBox(draggable2, afterCritical),
    destination,
    viewport: viewport.frame,
    withDroppableDisplacement: true
  })).sort((a, b) => {
    const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));
    const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));
    if (distanceToA < distanceToB) {
      return -1;
    }
    if (distanceToB < distanceToA) {
      return 1;
    }
    return a.descriptor.index - b.descriptor.index;
  });
  return sorted[0] || null;
};
var getDisplacedBy = memoizeOne(function getDisplacedBy2(axis, displaceBy) {
  const displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch(axis.line, displacement)
  };
});
var getRequiredGrowthForPlaceholder = (droppable2, placeholderSize, draggables) => {
  const axis = droppable2.axis;
  if (droppable2.descriptor.mode === "virtual") {
    return patch(axis.line, placeholderSize[axis.line]);
  }
  const availableSpace = droppable2.subject.page.contentBox[axis.size];
  const insideDroppable = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);
  const requiredSpace = spaceUsed + placeholderSize[axis.line];
  const needsToGrowBy = requiredSpace - availableSpace;
  if (needsToGrowBy <= 0) {
    return null;
  }
  return patch(axis.line, needsToGrowBy);
};
var withMaxScroll = (frame, max3) => __spreadProps(__spreadValues({}, frame), {
  scroll: __spreadProps(__spreadValues({}, frame.scroll), {
    max: max3
  })
});
var addPlaceholder = (droppable2, draggable2, draggables) => {
  const frame = droppable2.frame;
  !!isHomeOf(draggable2, droppable2) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Should not add placeholder space to home list") : invariant2() : void 0;
  !!droppable2.subject.withPlaceholder ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot add placeholder size to a subject when it already has one") : invariant2() : void 0;
  const placeholderSize = getDisplacedBy(droppable2.axis, draggable2.displaceBy).point;
  const requiredGrowth = getRequiredGrowthForPlaceholder(droppable2, placeholderSize, draggables);
  const added = {
    placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable2.frame ? droppable2.frame.scroll.max : null
  };
  if (!frame) {
    const subject2 = getSubject({
      page: droppable2.subject.page,
      withPlaceholder: added,
      axis: droppable2.axis,
      frame: droppable2.frame
    });
    return __spreadProps(__spreadValues({}, droppable2), {
      subject: subject2
    });
  }
  const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  const newFrame = withMaxScroll(frame, maxScroll);
  const subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: added,
    axis: droppable2.axis,
    frame: newFrame
  });
  return __spreadProps(__spreadValues({}, droppable2), {
    subject,
    frame: newFrame
  });
};
var removePlaceholder = (droppable2) => {
  const added = droppable2.subject.withPlaceholder;
  !added ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot remove placeholder form subject when there was none") : invariant2() : void 0;
  const frame = droppable2.frame;
  if (!frame) {
    const subject2 = getSubject({
      page: droppable2.subject.page,
      axis: droppable2.axis,
      frame: null,
      withPlaceholder: null
    });
    return __spreadProps(__spreadValues({}, droppable2), {
      subject: subject2
    });
  }
  const oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ? process.env.NODE_ENV !== "production" ? invariant2(false, "Expected droppable with frame to have old max frame scroll when removing placeholder") : invariant2() : void 0;
  const newFrame = withMaxScroll(frame, oldMaxScroll);
  const subject = getSubject({
    page: droppable2.subject.page,
    axis: droppable2.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return __spreadProps(__spreadValues({}, droppable2), {
    subject,
    frame: newFrame
  });
};
var moveToNewDroppable = ({
  previousPageBorderBoxCenter,
  moveRelativeTo,
  insideDestination,
  draggable: draggable2,
  draggables,
  destination,
  viewport,
  afterCritical
}) => {
  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }
    const proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: "REORDER",
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable2,
      droppable: destination,
      draggables,
      afterCritical
    });
    const withPlaceholder = isHomeOf(draggable2, destination) ? destination : addPlaceholder(destination, draggable2, draggables);
    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable2,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }
  const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
  const proposedIndex = (() => {
    const relativeTo = moveRelativeTo.descriptor.index;
    if (moveRelativeTo.descriptor.id === draggable2.descriptor.id) {
      return relativeTo;
    }
    if (isGoingBeforeTarget) {
      return relativeTo;
    }
    return relativeTo + 1;
  })();
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
};
var moveCrossAxis = ({
  isMovingForward,
  previousPageBorderBoxCenter,
  draggable: draggable2,
  isOver,
  draggables,
  droppables,
  viewport,
  afterCritical
}) => {
  const destination = getBestCrossAxisDroppable({
    isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables,
    viewport
  });
  if (!destination) {
    return null;
  }
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport,
    destination,
    insideDestination,
    afterCritical
  });
  const impact = moveToNewDroppable({
    previousPageBorderBoxCenter,
    destination,
    draggable: draggable2,
    draggables,
    moveRelativeTo,
    insideDestination,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  const clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
  return {
    clientSelection,
    impact,
    scrollJumpRequest: null
  };
};
var whatIsDraggedOver = (impact) => {
  const at = impact.at;
  if (!at) {
    return null;
  }
  if (at.type === "REORDER") {
    return at.destination.droppableId;
  }
  return at.combine.droppableId;
};
var getDroppableOver$1 = (impact, droppables) => {
  const id = whatIsDraggedOver(impact);
  return id ? droppables[id] : null;
};
var moveInDirection = ({
  state,
  type
}) => {
  const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);
  const isMainAxisMovementAllowed = Boolean(isActuallyOver);
  const home2 = state.dimensions.droppables[state.critical.droppable.id];
  const isOver = isActuallyOver || home2;
  const direction = isOver.axis.direction;
  const isMovingOnMainAxis = direction === "vertical" && (type === "MOVE_UP" || type === "MOVE_DOWN") || direction === "horizontal" && (type === "MOVE_LEFT" || type === "MOVE_RIGHT");
  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }
  const isMovingForward = type === "MOVE_DOWN" || type === "MOVE_RIGHT";
  const draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  const {
    draggables,
    droppables
  } = state.dimensions;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    destination: isOver,
    draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    isOver,
    draggables,
    droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
};
function isMovementAllowed(state) {
  return state.phase === "DRAGGING" || state.phase === "COLLECTING";
}
function isPositionInFrame(frame) {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run(point) {
    return isWithinVertical(point.y) && isWithinHorizontal(point.x);
  };
}
function getHasOverlap(first, second) {
  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
}
function getFurthestAway({
  pageBorderBox,
  draggable: draggable2,
  candidates
}) {
  const startCenter = draggable2.page.borderBox.center;
  const sorted = candidates.map((candidate) => {
    const axis = candidate.axis;
    const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort((a, b) => b.distance - a.distance);
  return sorted[0] ? sorted[0].id : null;
}
function getDroppableOver({
  pageBorderBox,
  draggable: draggable2,
  droppables
}) {
  const candidates = toDroppableList(droppables).filter((item) => {
    if (!item.isEnabled) {
      return false;
    }
    const active = item.subject.active;
    if (!active) {
      return false;
    }
    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }
    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }
    const axis = item.axis;
    const childCenter = active.center[axis.crossAxisLine];
    const crossAxisStart = pageBorderBox[axis.crossAxisStart];
    const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    const isStartContained = isContained(crossAxisStart);
    const isEndContained = isContained(crossAxisEnd);
    if (!isStartContained && !isEndContained) {
      return true;
    }
    if (isStartContained) {
      return crossAxisStart < childCenter;
    }
    return crossAxisEnd > childCenter;
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }
  return getFurthestAway({
    pageBorderBox,
    draggable: draggable2,
    candidates
  });
}
var offsetRectByPosition = (rect, point) => getRect(offsetByPosition(rect, point));
var withDroppableScroll = (droppable2, area) => {
  const frame = droppable2.frame;
  if (!frame) {
    return area;
  }
  return offsetRectByPosition(area, frame.scroll.diff.value);
};
function getIsDisplaced({
  displaced,
  id
}) {
  return Boolean(displaced.visible[id] || displaced.invisible[id]);
}
function atIndex({
  draggable: draggable2,
  closest: closest2,
  inHomeList
}) {
  if (!closest2) {
    return null;
  }
  if (!inHomeList) {
    return closest2.descriptor.index;
  }
  if (closest2.descriptor.index > draggable2.descriptor.index) {
    return closest2.descriptor.index - 1;
  }
  return closest2.descriptor.index;
}
var getReorderImpact = ({
  pageBorderBoxWithDroppableScroll: targetRect,
  draggable: draggable2,
  destination,
  insideDestination,
  last,
  viewport,
  afterCritical
}) => {
  const axis = destination.axis;
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  const displacement = displacedBy.value;
  const targetStart = targetRect[axis.start];
  const targetEnd = targetRect[axis.end];
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const closest2 = withoutDragging.find((child) => {
    const id = child.descriptor.id;
    const childCenter = child.page.borderBox.center[axis.line];
    const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    const isDisplaced = getIsDisplaced({
      displaced: last,
      id
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }
      return targetStart < childCenter - displacement;
    }
    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }
    return targetStart < childCenter;
  }) || null;
  const newIndex = atIndex({
    draggable: draggable2,
    closest: closest2,
    inHomeList: isHomeOf(draggable2, destination)
  });
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last,
    displacedBy,
    index: newIndex
  });
};
var combineThresholdDivisor = 4;
var getCombineImpact = ({
  draggable: draggable2,
  pageBorderBoxWithDroppableScroll: targetRect,
  previousImpact,
  destination,
  insideDestination,
  afterCritical
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const axis = destination.axis;
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  const displacement = displacedBy.value;
  const targetStart = targetRect[axis.start];
  const targetEnd = targetRect[axis.end];
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const combineWith = withoutDragging.find((child) => {
    const id = child.descriptor.id;
    const childRect = child.page.borderBox;
    const childSize = childRect[axis.size];
    const threshold = childSize / combineThresholdDivisor;
    const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    const isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }
      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }
    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }
    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });
  if (!combineWith) {
    return null;
  }
  const impact = {
    displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
};
var getDragImpact = ({
  pageOffset,
  draggable: draggable2,
  draggables,
  droppables,
  previousImpact,
  viewport,
  afterCritical
}) => {
  const pageBorderBox = offsetRectByPosition(draggable2.page.borderBox, pageOffset);
  const destinationId = getDroppableOver({
    pageBorderBox,
    draggable: draggable2,
    droppables
  });
  if (!destinationId) {
    return noImpact;
  }
  const destination = droppables[destinationId];
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    previousImpact,
    destination,
    insideDestination,
    afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    destination,
    insideDestination,
    last: previousImpact.displaced,
    viewport,
    afterCritical
  });
};
var patchDroppableMap = (droppables, updated) => __spreadProps(__spreadValues({}, droppables), {
  [updated.descriptor.id]: updated
});
var clearUnusedPlaceholder = ({
  previousImpact,
  impact,
  droppables
}) => {
  const last = whatIsDraggedOver(previousImpact);
  const now = whatIsDraggedOver(impact);
  if (!last) {
    return droppables;
  }
  if (last === now) {
    return droppables;
  }
  const lastDroppable = droppables[last];
  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }
  const updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};
var recomputePlaceholders = ({
  draggable: draggable2,
  draggables,
  droppables,
  previousImpact,
  impact
}) => {
  const cleaned = clearUnusedPlaceholder({
    previousImpact,
    impact,
    droppables
  });
  const isOver = whatIsDraggedOver(impact);
  if (!isOver) {
    return cleaned;
  }
  const droppable2 = droppables[isOver];
  if (isHomeOf(draggable2, droppable2)) {
    return cleaned;
  }
  if (droppable2.subject.withPlaceholder) {
    return cleaned;
  }
  const patched = addPlaceholder(droppable2, draggable2, draggables);
  return patchDroppableMap(cleaned, patched);
};
var update = ({
  state,
  clientSelection: forcedClientSelection,
  dimensions: forcedDimensions,
  viewport: forcedViewport,
  impact: forcedImpact,
  scrollJumpRequest
}) => {
  const viewport = forcedViewport || state.viewport;
  const dimensions = forcedDimensions || state.dimensions;
  const clientSelection = forcedClientSelection || state.current.client.selection;
  const offset6 = subtract(clientSelection, state.initial.client.selection);
  const client = {
    offset: offset6,
    selection: clientSelection,
    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset6)
  };
  const page = {
    selection: add(client.selection, viewport.scroll.current),
    borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),
    offset: add(client.offset, viewport.scroll.diff.value)
  };
  const current = {
    client,
    page
  };
  if (state.phase === "COLLECTING") {
    return __spreadProps(__spreadValues({}, state), {
      dimensions,
      viewport,
      current
    });
  }
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable2,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport,
    afterCritical: state.afterCritical
  });
  const withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable2,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });
  const result = __spreadProps(__spreadValues({}, state), {
    current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  });
  return result;
};
function getDraggables(ids, draggables) {
  return ids.map((id) => draggables[id]);
}
var recompute = ({
  impact,
  viewport,
  draggables,
  destination,
  forceShouldAnimate
}) => {
  const last = impact.displaced;
  const afterDragging = getDraggables(last.all, draggables);
  const displaced = getDisplacementGroups({
    afterDragging,
    destination,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    forceShouldAnimate,
    last
  });
  return __spreadProps(__spreadValues({}, impact), {
    displaced
  });
};
var getClientBorderBoxCenter = ({
  impact,
  draggable: draggable2,
  droppable: droppable2,
  draggables,
  viewport,
  afterCritical
}) => {
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    draggables,
    droppable: droppable2,
    afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
};
var refreshSnap = ({
  state,
  dimensions: forcedDimensions,
  viewport: forcedViewport
}) => {
  !(state.movementMode === "SNAP") ? process.env.NODE_ENV !== "production" ? invariant2() : invariant2() : void 0;
  const needsVisibilityCheck = state.impact;
  const viewport = forcedViewport || state.viewport;
  const dimensions = forcedDimensions || state.dimensions;
  const {
    draggables,
    droppables
  } = dimensions;
  const draggable2 = draggables[state.critical.draggable.id];
  const isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ? process.env.NODE_ENV !== "production" ? invariant2(false, "Must be over a destination in SNAP movement mode") : invariant2() : void 0;
  const destination = droppables[isOver];
  const impact = recompute({
    impact: needsVisibilityCheck,
    viewport,
    destination,
    draggables
  });
  const clientSelection = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    viewport,
    afterCritical: state.afterCritical
  });
  return update({
    impact,
    clientSelection,
    state,
    dimensions,
    viewport
  });
};
var getHomeLocation = (descriptor) => ({
  index: descriptor.index,
  droppableId: descriptor.droppableId
});
var getLiftEffect = ({
  draggable: draggable2,
  home: home2,
  draggables,
  viewport
}) => {
  const displacedBy = getDisplacedBy(home2.axis, draggable2.displaceBy);
  const insideHome = getDraggablesInsideDroppable(home2.descriptor.id, draggables);
  const rawIndex = insideHome.indexOf(draggable2);
  !(rawIndex !== -1) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Expected draggable to be inside home list") : invariant2() : void 0;
  const afterDragging = insideHome.slice(rawIndex + 1);
  const effected = afterDragging.reduce((previous, item) => {
    previous[item.descriptor.id] = true;
    return previous;
  }, {});
  const afterCritical = {
    inVirtualList: home2.descriptor.mode === "virtual",
    displacedBy,
    effected
  };
  const displaced = getDisplacementGroups({
    afterDragging,
    destination: home2,
    displacedBy,
    last: null,
    viewport: viewport.frame,
    forceShouldAnimate: false
  });
  const impact = {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: getHomeLocation(draggable2.descriptor)
    }
  };
  return {
    impact,
    afterCritical
  };
};
var patchDimensionMap = (dimensions, updated) => ({
  draggables: dimensions.draggables,
  droppables: patchDroppableMap(dimensions.droppables, updated)
});
var start = (key) => {
  if (process.env.NODE_ENV !== "production") {
    {
      return;
    }
  }
};
var finish = (key) => {
  if (process.env.NODE_ENV !== "production") {
    {
      return;
    }
  }
};
var offsetDraggable = ({
  draggable: draggable2,
  offset: offset$1,
  initialWindowScroll
}) => {
  const client = offset4(draggable2.client, offset$1);
  const page = withScroll(client, initialWindowScroll);
  const moved = __spreadProps(__spreadValues({}, draggable2), {
    placeholder: __spreadProps(__spreadValues({}, draggable2.placeholder), {
      client
    }),
    client,
    page
  });
  return moved;
};
var getFrame = (droppable2) => {
  const frame = droppable2.frame;
  !frame ? process.env.NODE_ENV !== "production" ? invariant2(false, "Expected Droppable to have a frame") : invariant2() : void 0;
  return frame;
};
var adjustAdditionsForScrollChanges = ({
  additions,
  updatedDroppables,
  viewport
}) => {
  const windowScrollChange = viewport.scroll.diff.value;
  return additions.map((draggable2) => {
    const droppableId = draggable2.descriptor.droppableId;
    const modified = updatedDroppables[droppableId];
    const frame = getFrame(modified);
    const droppableScrollChange = frame.scroll.diff.value;
    const totalChange = add(windowScrollChange, droppableScrollChange);
    const moved = offsetDraggable({
      draggable: draggable2,
      offset: totalChange,
      initialWindowScroll: viewport.scroll.initial
    });
    return moved;
  });
};
var publishWhileDraggingInVirtual = ({
  state,
  published
}) => {
  start();
  const withScrollChange = published.modified.map((update2) => {
    const existing = state.dimensions.droppables[update2.droppableId];
    const scrolled = scrollDroppable(existing, update2.scroll);
    return scrolled;
  });
  const droppables = __spreadValues(__spreadValues({}, state.dimensions.droppables), toDroppableMap(withScrollChange));
  const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));
  const draggables = __spreadValues(__spreadValues({}, state.dimensions.draggables), updatedAdditions);
  published.removals.forEach((id) => {
    delete draggables[id];
  });
  const dimensions = {
    droppables,
    draggables
  };
  const wasOverId = whatIsDraggedOver(state.impact);
  const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const home2 = dimensions.droppables[state.critical.droppable.id];
  const {
    impact: onLiftImpact,
    afterCritical
  } = getLiftEffect({
    draggable: draggable2,
    home: home2,
    draggables,
    viewport: state.viewport
  });
  const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  const impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact,
    viewport: state.viewport,
    afterCritical
  });
  finish();
  const draggingState = __spreadProps(__spreadValues({}, state), {
    phase: "DRAGGING",
    impact,
    onLiftImpact,
    dimensions,
    afterCritical,
    forceShouldAnimate: false
  });
  if (state.phase === "COLLECTING") {
    return draggingState;
  }
  const dropPending2 = __spreadProps(__spreadValues({}, draggingState), {
    phase: "DROP_PENDING",
    reason: state.reason,
    isWaiting: false
  });
  return dropPending2;
};
var isSnapping = (state) => state.movementMode === "SNAP";
var postDroppableChange = (state, updated, isEnabledChanging) => {
  const dimensions = patchDimensionMap(state.dimensions, updated);
  if (!isSnapping(state) || isEnabledChanging) {
    return update({
      state,
      dimensions
    });
  }
  return refreshSnap({
    state,
    dimensions
  });
};
function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === "SNAP") {
    return __spreadProps(__spreadValues({}, state), {
      scrollJumpRequest: null
    });
  }
  return state;
}
var idle$2 = {
  phase: "IDLE",
  completed: null,
  shouldFlush: false
};
var reducer = (state = idle$2, action) => {
  if (action.type === "FLUSH") {
    return __spreadProps(__spreadValues({}, idle$2), {
      shouldFlush: true
    });
  }
  if (action.type === "INITIAL_PUBLISH") {
    !(state.phase === "IDLE") ? process.env.NODE_ENV !== "production" ? invariant2(false, "INITIAL_PUBLISH must come after a IDLE phase") : invariant2() : void 0;
    const {
      critical,
      clientSelection,
      viewport,
      dimensions,
      movementMode
    } = action.payload;
    const draggable2 = dimensions.draggables[critical.draggable.id];
    const home2 = dimensions.droppables[critical.droppable.id];
    const client = {
      selection: clientSelection,
      borderBoxCenter: draggable2.client.borderBox.center,
      offset: origin
    };
    const initial = {
      client,
      page: {
        selection: add(client.selection, viewport.scroll.initial),
        borderBoxCenter: add(client.selection, viewport.scroll.initial),
        offset: add(client.selection, viewport.scroll.diff.value)
      }
    };
    const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item) => !item.isFixedOnPage);
    const {
      impact,
      afterCritical
    } = getLiftEffect({
      draggable: draggable2,
      home: home2,
      draggables: dimensions.draggables,
      viewport
    });
    const result = {
      phase: "DRAGGING",
      isDragging: true,
      critical,
      movementMode,
      dimensions,
      initial,
      current: initial,
      isWindowScrollAllowed,
      impact,
      afterCritical,
      onLiftImpact: impact,
      viewport,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }
  if (action.type === "COLLECTION_STARTING") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? process.env.NODE_ENV !== "production" ? invariant2(false, `Collection cannot start from phase ${state.phase}`) : invariant2() : void 0;
    const result = __spreadProps(__spreadValues({}, state), {
      phase: "COLLECTING"
    });
    return result;
  }
  if (action.type === "PUBLISH_WHILE_DRAGGING") {
    !(state.phase === "COLLECTING" || state.phase === "DROP_PENDING") ? process.env.NODE_ENV !== "production" ? invariant2(false, `Unexpected ${action.type} received in phase ${state.phase}`) : invariant2() : void 0;
    return publishWhileDraggingInVirtual({
      state,
      published: action.payload
    });
  }
  if (action.type === "MOVE") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant2(false, `${action.type} not permitted in phase ${state.phase}`) : invariant2() : void 0;
    const {
      client: clientSelection
    } = action.payload;
    if (isEqual$1(clientSelection, state.current.client.selection)) {
      return state;
    }
    return update({
      state,
      clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }
  if (action.type === "UPDATE_DROPPABLE_SCROLL") {
    if (state.phase === "DROP_PENDING") {
      return removeScrollJumpRequest(state);
    }
    if (state.phase === "COLLECTING") {
      return removeScrollJumpRequest(state);
    }
    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant2(false, `${action.type} not permitted in phase ${state.phase}`) : invariant2() : void 0;
    const {
      id,
      newScroll
    } = action.payload;
    const target = state.dimensions.droppables[id];
    if (!target) {
      return state;
    }
    const scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Attempting to move in an unsupported phase ${state.phase}`) : invariant2() : void 0;
    const {
      id,
      isEnabled
    } = action.payload;
    const target = state.dimensions.droppables[id];
    !target ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : invariant2() : void 0;
    !(target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Trying to set droppable isEnabled to ${String(isEnabled)}
      but it is already ${String(target.isEnabled)}`) : invariant2() : void 0;
    const updated = __spreadProps(__spreadValues({}, target), {
      isEnabled
    });
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Attempting to move in an unsupported phase ${state.phase}`) : invariant2() : void 0;
    const {
      id,
      isCombineEnabled
    } = action.payload;
    const target = state.dimensions.droppables[id];
    !target ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : invariant2() : void 0;
    !(target.isCombineEnabled !== isCombineEnabled) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}
      but it is already ${String(target.isCombineEnabled)}`) : invariant2() : void 0;
    const updated = __spreadProps(__spreadValues({}, target), {
      isCombineEnabled
    });
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "MOVE_BY_WINDOW_SCROLL") {
    if (state.phase === "DROP_PENDING" || state.phase === "DROP_ANIMATING") {
      return state;
    }
    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot move by window in phase ${state.phase}`) : invariant2() : void 0;
    !state.isWindowScrollAllowed ? process.env.NODE_ENV !== "production" ? invariant2(false, "Window scrolling is currently not supported for fixed lists") : invariant2() : void 0;
    const newScroll = action.payload.newScroll;
    if (isEqual$1(state.viewport.scroll.current, newScroll)) {
      return removeScrollJumpRequest(state);
    }
    const viewport = scrollViewport(state.viewport, newScroll);
    if (isSnapping(state)) {
      return refreshSnap({
        state,
        viewport
      });
    }
    return update({
      state,
      viewport
    });
  }
  if (action.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!isMovementAllowed(state)) {
      return state;
    }
    const maxScroll = action.payload.maxScroll;
    if (isEqual$1(maxScroll, state.viewport.scroll.max)) {
      return state;
    }
    const withMaxScroll2 = __spreadProps(__spreadValues({}, state.viewport), {
      scroll: __spreadProps(__spreadValues({}, state.viewport.scroll), {
        max: maxScroll
      })
    });
    return __spreadProps(__spreadValues({}, state), {
      viewport: withMaxScroll2
    });
  }
  if (action.type === "MOVE_UP" || action.type === "MOVE_DOWN" || action.type === "MOVE_LEFT" || action.type === "MOVE_RIGHT") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? process.env.NODE_ENV !== "production" ? invariant2(false, `${action.type} received while not in DRAGGING phase`) : invariant2() : void 0;
    const result = moveInDirection({
      state,
      type: action.type
    });
    if (!result) {
      return state;
    }
    return update({
      state,
      impact: result.impact,
      clientSelection: result.clientSelection,
      scrollJumpRequest: result.scrollJumpRequest
    });
  }
  if (action.type === "DROP_PENDING") {
    const reason = action.payload.reason;
    !(state.phase === "COLLECTING") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Can only move into the DROP_PENDING phase from the COLLECTING phase") : invariant2() : void 0;
    const newState = __spreadProps(__spreadValues({}, state), {
      phase: "DROP_PENDING",
      isWaiting: true,
      reason
    });
    return newState;
  }
  if (action.type === "DROP_ANIMATE") {
    const {
      completed,
      dropDuration,
      newHomeClientOffset
    } = action.payload;
    !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot animate drop from phase ${state.phase}`) : invariant2() : void 0;
    const result = {
      phase: "DROP_ANIMATING",
      completed,
      dropDuration,
      newHomeClientOffset,
      dimensions: state.dimensions
    };
    return result;
  }
  if (action.type === "DROP_COMPLETE") {
    const {
      completed
    } = action.payload;
    return {
      phase: "IDLE",
      completed,
      shouldFlush: false
    };
  }
  return state;
};
function guard(action, predicate) {
  return action instanceof Object && "type" in action && action.type === predicate;
}
var beforeInitialCapture = (args) => ({
  type: "BEFORE_INITIAL_CAPTURE",
  payload: args
});
var lift$1 = (args) => ({
  type: "LIFT",
  payload: args
});
var initialPublish = (args) => ({
  type: "INITIAL_PUBLISH",
  payload: args
});
var publishWhileDragging = (args) => ({
  type: "PUBLISH_WHILE_DRAGGING",
  payload: args
});
var collectionStarting = () => ({
  type: "COLLECTION_STARTING",
  payload: null
});
var updateDroppableScroll = (args) => ({
  type: "UPDATE_DROPPABLE_SCROLL",
  payload: args
});
var updateDroppableIsEnabled = (args) => ({
  type: "UPDATE_DROPPABLE_IS_ENABLED",
  payload: args
});
var updateDroppableIsCombineEnabled = (args) => ({
  type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
  payload: args
});
var move = (args) => ({
  type: "MOVE",
  payload: args
});
var moveByWindowScroll = (args) => ({
  type: "MOVE_BY_WINDOW_SCROLL",
  payload: args
});
var updateViewportMaxScroll = (args) => ({
  type: "UPDATE_VIEWPORT_MAX_SCROLL",
  payload: args
});
var moveUp = () => ({
  type: "MOVE_UP",
  payload: null
});
var moveDown = () => ({
  type: "MOVE_DOWN",
  payload: null
});
var moveRight = () => ({
  type: "MOVE_RIGHT",
  payload: null
});
var moveLeft = () => ({
  type: "MOVE_LEFT",
  payload: null
});
var flush = () => ({
  type: "FLUSH",
  payload: null
});
var animateDrop = (args) => ({
  type: "DROP_ANIMATE",
  payload: args
});
var completeDrop = (args) => ({
  type: "DROP_COMPLETE",
  payload: args
});
var drop = (args) => ({
  type: "DROP",
  payload: args
});
var dropPending = (args) => ({
  type: "DROP_PENDING",
  payload: args
});
var dropAnimationFinished = () => ({
  type: "DROP_ANIMATION_FINISHED",
  payload: null
});
function checkIndexes(insideDestination) {
  if (insideDestination.length <= 1) {
    return;
  }
  const indexes = insideDestination.map((d) => d.descriptor.index);
  const errors = {};
  for (let i = 1; i < indexes.length; i++) {
    const current = indexes[i];
    const previous = indexes[i - 1];
    if (current !== previous + 1) {
      errors[current] = true;
    }
  }
  if (!Object.keys(errors).length) {
    return;
  }
  const formatted = indexes.map((index2) => {
    const hasError = Boolean(errors[index2]);
    return hasError ? `[\u{1F525}${index2}]` : `${index2}`;
  }).join(", ");
  process.env.NODE_ENV !== "production" ? warning2(`
    Detected non-consecutive <Draggable /> indexes.

    (This can cause unexpected bugs)

    ${formatted}
  `) : void 0;
}
function validateDimensions(critical, dimensions) {
  if (process.env.NODE_ENV !== "production") {
    const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);
    checkIndexes(insideDestination);
  }
}
var lift = (marshal) => ({
  getState: getState9,
  dispatch: dispatch3
}) => (next) => (action) => {
  if (!guard(action, "LIFT")) {
    next(action);
    return;
  }
  const {
    id,
    clientSelection,
    movementMode
  } = action.payload;
  const initial = getState9();
  if (initial.phase === "DROP_ANIMATING") {
    dispatch3(completeDrop({
      completed: initial.completed
    }));
  }
  !(getState9().phase === "IDLE") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Unexpected phase to start a drag") : invariant2() : void 0;
  dispatch3(flush());
  dispatch3(beforeInitialCapture({
    draggableId: id,
    movementMode
  }));
  const scrollOptions = {
    shouldPublishImmediately: movementMode === "SNAP"
  };
  const request = {
    draggableId: id,
    scrollOptions
  };
  const {
    critical,
    dimensions,
    viewport
  } = marshal.startPublishing(request);
  validateDimensions(critical, dimensions);
  dispatch3(initialPublish({
    critical,
    dimensions,
    clientSelection,
    movementMode,
    viewport
  }));
};
var style = (marshal) => () => (next) => (action) => {
  if (guard(action, "INITIAL_PUBLISH")) {
    marshal.dragging();
  }
  if (guard(action, "DROP_ANIMATE")) {
    marshal.dropping(action.payload.completed.result.reason);
  }
  if (guard(action, "FLUSH") || guard(action, "DROP_COMPLETE")) {
    marshal.resting();
  }
  next(action);
};
var curves = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
};
var combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
var timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
var outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;
var transitions = {
  fluid: `opacity ${outOfTheWayTiming}`,
  snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,
  drop: (duration) => {
    const timing = `${duration}s ${curves.drop}`;
    return `transform ${timing}, opacity ${timing}`;
  },
  outOfTheWay: `transform ${outOfTheWayTiming}`,
  placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`
};
var moveTo = (offset6) => isEqual$1(offset6, origin) ? void 0 : `translate(${offset6.x}px, ${offset6.y}px)`;
var transforms = {
  moveTo,
  drop: (offset6, isCombining) => {
    const translate = moveTo(offset6);
    if (!translate) {
      return void 0;
    }
    if (!isCombining) {
      return translate;
    }
    return `${translate} scale(${combine.scale.drop})`;
  }
};
var {
  minDropTime,
  maxDropTime
} = timings;
var dropTimeRange = maxDropTime - minDropTime;
var maxDropTimeAtDistance = 1500;
var cancelDropModifier = 0.6;
var getDropDuration = ({
  current,
  destination,
  reason
}) => {
  const distance$1 = distance(current, destination);
  if (distance$1 <= 0) {
    return minDropTime;
  }
  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }
  const percentage = distance$1 / maxDropTimeAtDistance;
  const duration = minDropTime + dropTimeRange * percentage;
  const withDuration = reason === "CANCEL" ? duration * cancelDropModifier : duration;
  return Number(withDuration.toFixed(2));
};
var getNewHomeClientOffset = ({
  impact,
  draggable: draggable2,
  dimensions,
  viewport,
  afterCritical
}) => {
  const {
    draggables,
    droppables
  } = dimensions;
  const droppableId = whatIsDraggedOver(impact);
  const destination = droppableId ? droppables[droppableId] : null;
  const home2 = droppables[draggable2.descriptor.droppableId];
  const newClientCenter = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    draggables,
    afterCritical,
    droppable: destination || home2,
    viewport
  });
  const offset6 = subtract(newClientCenter, draggable2.client.borderBox.center);
  return offset6;
};
var getDropImpact = ({
  draggables,
  reason,
  lastImpact,
  home: home2,
  viewport,
  onLiftImpact
}) => {
  if (!lastImpact.at || reason !== "DROP") {
    const recomputedHomeImpact = recompute({
      draggables,
      impact: onLiftImpact,
      destination: home2,
      viewport,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }
  if (lastImpact.at.type === "REORDER") {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }
  const withoutMovement = __spreadProps(__spreadValues({}, lastImpact), {
    displaced: emptyGroups
  });
  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
};
var dropMiddleware = ({
  getState: getState9,
  dispatch: dispatch3
}) => (next) => (action) => {
  if (!guard(action, "DROP")) {
    next(action);
    return;
  }
  const state = getState9();
  const reason = action.payload.reason;
  if (state.phase === "COLLECTING") {
    dispatch3(dropPending({
      reason
    }));
    return;
  }
  if (state.phase === "IDLE") {
    return;
  }
  const isWaitingForDrop = state.phase === "DROP_PENDING" && state.isWaiting;
  !!isWaitingForDrop ? process.env.NODE_ENV !== "production" ? invariant2(false, "A DROP action occurred while DROP_PENDING and still waiting") : invariant2() : void 0;
  !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot drop in phase: ${state.phase}`) : invariant2() : void 0;
  const critical = state.critical;
  const dimensions = state.dimensions;
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const {
    impact,
    didDropInsideDroppable
  } = getDropImpact({
    reason,
    lastImpact: state.impact,
    afterCritical: state.afterCritical,
    onLiftImpact: state.onLiftImpact,
    home: state.dimensions.droppables[state.critical.droppable.id],
    viewport: state.viewport,
    draggables: state.dimensions.draggables
  });
  const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
  const combine2 = didDropInsideDroppable ? tryGetCombine(impact) : null;
  const source = {
    index: critical.draggable.index,
    droppableId: critical.droppable.id
  };
  const result = {
    draggableId: draggable2.descriptor.id,
    type: draggable2.descriptor.type,
    source,
    reason,
    mode: state.movementMode,
    destination,
    combine: combine2
  };
  const newHomeClientOffset = getNewHomeClientOffset({
    impact,
    draggable: draggable2,
    dimensions,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
  const completed = {
    critical: state.critical,
    afterCritical: state.afterCritical,
    result,
    impact
  };
  const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
  if (!isAnimationRequired) {
    dispatch3(completeDrop({
      completed
    }));
    return;
  }
  const dropDuration = getDropDuration({
    current: state.current.client.offset,
    destination: newHomeClientOffset,
    reason
  });
  const args = {
    newHomeClientOffset,
    dropDuration,
    completed
  };
  dispatch3(animateDrop(args));
};
var getWindowScroll3 = () => ({
  x: window.pageXOffset,
  y: window.pageYOffset
});
function getWindowScrollBinding(update2) {
  return {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: (event) => {
      if (event.target !== window && event.target !== window.document) {
        return;
      }
      update2();
    }
  };
}
function getScrollListener({
  onWindowScroll
}) {
  function updateScroll() {
    onWindowScroll(getWindowScroll3());
  }
  const scheduled = raf_schd_esm_default(updateScroll);
  const binding = getWindowScrollBinding(scheduled);
  let unbind = noop$2;
  function isActive2() {
    return unbind !== noop$2;
  }
  function start2() {
    !!isActive2() ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot start scroll listener when already active") : invariant2() : void 0;
    unbind = bindEvents(window, [binding]);
  }
  function stop() {
    !isActive2() ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot stop scroll listener when not active") : invariant2() : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop$2;
  }
  return {
    start: start2,
    stop,
    isActive: isActive2
  };
}
var shouldStop$1 = (action) => guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATE") || guard(action, "FLUSH");
var scrollListener = (store) => {
  const listener = getScrollListener({
    onWindowScroll: (newScroll) => {
      store.dispatch(moveByWindowScroll({
        newScroll
      }));
    }
  });
  return (next) => (action) => {
    if (!listener.isActive() && guard(action, "INITIAL_PUBLISH")) {
      listener.start();
    }
    if (listener.isActive() && shouldStop$1(action)) {
      listener.stop();
    }
    next(action);
  };
};
var getExpiringAnnounce = (announce) => {
  let wasCalled = false;
  let isExpired = false;
  const timeoutId = setTimeout(() => {
    isExpired = true;
  });
  const result = (message2) => {
    if (wasCalled) {
      process.env.NODE_ENV !== "production" ? warning2("Announcement already made. Not making a second announcement") : void 0;
      return;
    }
    if (isExpired) {
      process.env.NODE_ENV !== "production" ? warning2(`
        Announcements cannot be made asynchronously.
        Default message has already been announced.
      `) : void 0;
      return;
    }
    wasCalled = true;
    announce(message2);
    clearTimeout(timeoutId);
  };
  result.wasCalled = () => wasCalled;
  return result;
};
var getAsyncMarshal = () => {
  const entries = [];
  const execute2 = (timerId) => {
    const index2 = entries.findIndex((item) => item.timerId === timerId);
    !(index2 !== -1) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Could not find timer") : invariant2() : void 0;
    const [entry] = entries.splice(index2, 1);
    entry.callback();
  };
  const add2 = (fn) => {
    const timerId = setTimeout(() => execute2(timerId));
    const entry = {
      timerId,
      callback: fn
    };
    entries.push(entry);
  };
  const flush2 = () => {
    if (!entries.length) {
      return;
    }
    const shallow = [...entries];
    entries.length = 0;
    shallow.forEach((entry) => {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };
  return {
    add: add2,
    flush: flush2
  };
};
var areLocationsEqual = (first, second) => {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.droppableId === second.droppableId && first.index === second.index;
};
var isCombineEqual = (first, second) => {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
};
var isCriticalEqual = (first, second) => {
  if (first === second) {
    return true;
  }
  const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
  const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};
var withTimings = (key, fn) => {
  start();
  fn();
  finish();
};
var getDragStart = (critical, mode) => ({
  draggableId: critical.draggable.id,
  type: critical.droppable.type,
  source: {
    droppableId: critical.droppable.id,
    index: critical.draggable.index
  },
  mode
});
function execute(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }
  const willExpire = getExpiringAnnounce(announce);
  const provided = {
    announce: willExpire
  };
  responder(data, provided);
  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
}
var getPublisher = (getResponders, announce) => {
  const asyncMarshal = getAsyncMarshal();
  let dragging = null;
  const beforeCapture = (draggableId, mode) => {
    !!dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot fire onBeforeCapture as a drag start has already been published") : invariant2() : void 0;
    withTimings("onBeforeCapture", () => {
      const fn = getResponders().onBeforeCapture;
      if (fn) {
        const before = {
          draggableId,
          mode
        };
        fn(before);
      }
    });
  };
  const beforeStart = (critical, mode) => {
    !!dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant2() : void 0;
    withTimings("onBeforeDragStart", () => {
      const fn = getResponders().onBeforeDragStart;
      if (fn) {
        fn(getDragStart(critical, mode));
      }
    });
  };
  const start2 = (critical, mode) => {
    !!dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant2() : void 0;
    const data = getDragStart(critical, mode);
    dragging = {
      mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(() => {
      withTimings("onDragStart", () => execute(getResponders().onDragStart, data, announce, preset.onDragStart));
    });
  };
  const update2 = (critical, impact) => {
    const location = tryGetDestination(impact);
    const combine2 = tryGetCombine(impact);
    !dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot fire onDragMove when onDragStart has not been called") : invariant2() : void 0;
    const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }
    const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
    if (hasLocationChanged) {
      dragging.lastLocation = location;
    }
    const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine2);
    if (hasGroupingChanged) {
      dragging.lastCombine = combine2;
    }
    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }
    const data = __spreadProps(__spreadValues({}, getDragStart(critical, dragging.mode)), {
      combine: combine2,
      destination: location
    });
    asyncMarshal.add(() => {
      withTimings("onDragUpdate", () => execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));
    });
  };
  const flush2 = () => {
    !dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Can only flush responders while dragging") : invariant2() : void 0;
    asyncMarshal.flush();
  };
  const drop2 = (result) => {
    !dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot fire onDragEnd when there is no matching onDragStart") : invariant2() : void 0;
    dragging = null;
    withTimings("onDragEnd", () => execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));
  };
  const abort = () => {
    if (!dragging) {
      return;
    }
    const result = __spreadProps(__spreadValues({}, getDragStart(dragging.lastCritical, dragging.mode)), {
      combine: null,
      destination: null,
      reason: "CANCEL"
    });
    drop2(result);
  };
  return {
    beforeCapture,
    beforeStart,
    start: start2,
    update: update2,
    flush: flush2,
    drop: drop2,
    abort
  };
};
var responders = (getResponders, announce) => {
  const publisher = getPublisher(getResponders, announce);
  return (store) => (next) => (action) => {
    if (guard(action, "BEFORE_INITIAL_CAPTURE")) {
      publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
      return;
    }
    if (guard(action, "INITIAL_PUBLISH")) {
      const critical = action.payload.critical;
      publisher.beforeStart(critical, action.payload.movementMode);
      next(action);
      publisher.start(critical, action.payload.movementMode);
      return;
    }
    if (guard(action, "DROP_COMPLETE")) {
      const result = action.payload.completed.result;
      publisher.flush();
      next(action);
      publisher.drop(result);
      return;
    }
    next(action);
    if (guard(action, "FLUSH")) {
      publisher.abort();
      return;
    }
    const state = store.getState();
    if (state.phase === "DRAGGING") {
      publisher.update(state.critical, state.impact);
    }
  };
};
var dropAnimationFinishMiddleware = (store) => (next) => (action) => {
  if (!guard(action, "DROP_ANIMATION_FINISHED")) {
    next(action);
    return;
  }
  const state = store.getState();
  !(state.phase === "DROP_ANIMATING") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot finish a drop animating when no drop is occurring") : invariant2() : void 0;
  store.dispatch(completeDrop({
    completed: state.completed
  }));
};
var dropAnimationFlushOnScrollMiddleware = (store) => {
  let unbind = null;
  let frameId = null;
  function clear() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }
    if (unbind) {
      unbind();
      unbind = null;
    }
  }
  return (next) => (action) => {
    if (guard(action, "FLUSH") || guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATION_FINISHED")) {
      clear();
    }
    next(action);
    if (!guard(action, "DROP_ANIMATE")) {
      return;
    }
    const binding = {
      eventName: "scroll",
      options: {
        capture: true,
        passive: false,
        once: true
      },
      fn: function flushDropAnimation() {
        const state = store.getState();
        if (state.phase === "DROP_ANIMATING") {
          store.dispatch(dropAnimationFinished());
        }
      }
    };
    frameId = requestAnimationFrame(() => {
      frameId = null;
      unbind = bindEvents(window, [binding]);
    });
  };
};
var dimensionMarshalStopper = (marshal) => () => (next) => (action) => {
  if (guard(action, "DROP_COMPLETE") || guard(action, "FLUSH") || guard(action, "DROP_ANIMATE")) {
    marshal.stopPublishing();
  }
  next(action);
};
var focus3 = (marshal) => {
  let isWatching = false;
  return () => (next) => (action) => {
    if (guard(action, "INITIAL_PUBLISH")) {
      isWatching = true;
      marshal.tryRecordFocus(action.payload.critical.draggable.id);
      next(action);
      marshal.tryRestoreFocusRecorded();
      return;
    }
    next(action);
    if (!isWatching) {
      return;
    }
    if (guard(action, "FLUSH")) {
      isWatching = false;
      marshal.tryRestoreFocusRecorded();
      return;
    }
    if (guard(action, "DROP_COMPLETE")) {
      isWatching = false;
      const result = action.payload.completed.result;
      if (result.combine) {
        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
      }
      marshal.tryRestoreFocusRecorded();
    }
  };
};
var shouldStop = (action) => guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATE") || guard(action, "FLUSH");
var autoScroll = (autoScroller) => (store) => (next) => (action) => {
  if (shouldStop(action)) {
    autoScroller.stop();
    next(action);
    return;
  }
  if (guard(action, "INITIAL_PUBLISH")) {
    next(action);
    const state = store.getState();
    !(state.phase === "DRAGGING") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Expected phase to be DRAGGING after INITIAL_PUBLISH") : invariant2() : void 0;
    autoScroller.start(state);
    return;
  }
  next(action);
  autoScroller.scroll(store.getState());
};
var pendingDrop = (store) => (next) => (action) => {
  next(action);
  if (!guard(action, "PUBLISH_WHILE_DRAGGING")) {
    return;
  }
  const postActionState = store.getState();
  if (postActionState.phase !== "DROP_PENDING") {
    return;
  }
  if (postActionState.isWaiting) {
    return;
  }
  store.dispatch(drop({
    reason: postActionState.reason
  }));
};
var composeEnhancers = process.env.NODE_ENV !== "production" && typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
  name: "@hello-pangea/dnd"
}) : compose;
var createStore2 = ({
  dimensionMarshal,
  focusMarshal,
  styleMarshal,
  getResponders,
  announce,
  autoScroller
}) => createStore(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus3(focusMarshal), responders(getResponders, announce))));
var clean$1 = () => ({
  additions: {},
  removals: {},
  modified: {}
});
function createPublisher({
  registry,
  callbacks
}) {
  let staging = clean$1();
  let frameId = null;
  const collect = () => {
    if (frameId) {
      return;
    }
    callbacks.collectionStarting();
    frameId = requestAnimationFrame(() => {
      frameId = null;
      start();
      const {
        additions,
        removals,
        modified
      } = staging;
      const added = Object.keys(additions).map((id) => registry.draggable.getById(id).getDimension(origin)).sort((a, b) => a.descriptor.index - b.descriptor.index);
      const updated = Object.keys(modified).map((id) => {
        const entry = registry.droppable.getById(id);
        const scroll2 = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id,
          scroll: scroll2
        };
      });
      const result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging = clean$1();
      finish();
      callbacks.publish(result);
    });
  };
  const add2 = (entry) => {
    const id = entry.descriptor.id;
    staging.additions[id] = entry;
    staging.modified[entry.descriptor.droppableId] = true;
    if (staging.removals[id]) {
      delete staging.removals[id];
    }
    collect();
  };
  const remove = (entry) => {
    const descriptor = entry.descriptor;
    staging.removals[descriptor.id] = true;
    staging.modified[descriptor.droppableId] = true;
    if (staging.additions[descriptor.id]) {
      delete staging.additions[descriptor.id];
    }
    collect();
  };
  const stop = () => {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
    staging = clean$1();
  };
  return {
    add: add2,
    remove,
    stop
  };
}
var getMaxScroll = ({
  scrollHeight,
  scrollWidth,
  height,
  width
}) => {
  const maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width,
    y: height
  });
  const adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};
var getDocumentElement2 = () => {
  const doc = document.documentElement;
  !doc ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot find document.documentElement") : invariant2() : void 0;
  return doc;
};
var getMaxWindowScroll = () => {
  const doc = getDocumentElement2();
  const maxScroll = getMaxScroll({
    scrollHeight: doc.scrollHeight,
    scrollWidth: doc.scrollWidth,
    width: doc.clientWidth,
    height: doc.clientHeight
  });
  return maxScroll;
};
var getViewport = () => {
  const scroll2 = getWindowScroll3();
  const maxScroll = getMaxWindowScroll();
  const top = scroll2.y;
  const left = scroll2.x;
  const doc = getDocumentElement2();
  const width = doc.clientWidth;
  const height = doc.clientHeight;
  const right = left + width;
  const bottom = top + height;
  const frame = getRect({
    top,
    left,
    right,
    bottom
  });
  const viewport = {
    frame,
    scroll: {
      initial: scroll2,
      current: scroll2,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport;
};
var getInitialPublish = ({
  critical,
  scrollOptions,
  registry
}) => {
  start();
  const viewport = getViewport();
  const windowScroll = viewport.scroll.current;
  const home2 = critical.droppable;
  const droppables = registry.droppable.getAllByType(home2.type).map((entry) => entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));
  const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry) => entry.getDimension(windowScroll));
  const dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  finish();
  const result = {
    dimensions,
    critical,
    viewport
  };
  return result;
};
function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }
  if (entry.descriptor.type !== dragging.type) {
    return false;
  }
  const home2 = registry.droppable.getById(entry.descriptor.droppableId);
  if (home2.descriptor.mode !== "virtual") {
    process.env.NODE_ENV !== "production" ? warning2(`
      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]
      while a drag is occurring. This is only supported for virtual lists.

      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md
    `) : void 0;
    return false;
  }
  return true;
}
var createDimensionMarshal = (registry, callbacks) => {
  let collection = null;
  const publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry
  });
  const updateDroppableIsEnabled2 = (id, isEnabled) => {
    !registry.droppable.exists(id) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : invariant2() : void 0;
    if (!collection) {
      return;
    }
    callbacks.updateDroppableIsEnabled({
      id,
      isEnabled
    });
  };
  const updateDroppableIsCombineEnabled2 = (id, isCombineEnabled) => {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : invariant2() : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id,
      isCombineEnabled
    });
  };
  const updateDroppableScroll2 = (id, newScroll) => {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : invariant2() : void 0;
    callbacks.updateDroppableScroll({
      id,
      newScroll
    });
  };
  const scrollDroppable2 = (id, change) => {
    if (!collection) {
      return;
    }
    registry.droppable.getById(id).callbacks.scroll(change);
  };
  const stopPublishing = () => {
    if (!collection) {
      return;
    }
    publisher.stop();
    const home2 = collection.critical.droppable;
    registry.droppable.getAllByType(home2.type).forEach((entry) => entry.callbacks.dragStopped());
    collection.unsubscribe();
    collection = null;
  };
  const subscriber = (event) => {
    !collection ? process.env.NODE_ENV !== "production" ? invariant2(false, "Should only be subscribed when a collection is occurring") : invariant2() : void 0;
    const dragging = collection.critical.draggable;
    if (event.type === "ADDITION") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }
    if (event.type === "REMOVAL") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };
  const startPublishing = (request) => {
    !!collection ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot start capturing critical dimensions as there is already a collection") : invariant2() : void 0;
    const entry = registry.draggable.getById(request.draggableId);
    const home2 = registry.droppable.getById(entry.descriptor.droppableId);
    const critical = {
      draggable: entry.descriptor,
      droppable: home2.descriptor
    };
    const unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical,
      unsubscribe
    };
    return getInitialPublish({
      critical,
      registry,
      scrollOptions: request.scrollOptions
    });
  };
  const marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled2,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled2,
    scrollDroppable: scrollDroppable2,
    updateDroppableScroll: updateDroppableScroll2,
    startPublishing,
    stopPublishing
  };
  return marshal;
};
var canStartDrag = (state, id) => {
  if (state.phase === "IDLE") {
    return true;
  }
  if (state.phase !== "DROP_ANIMATING") {
    return false;
  }
  if (state.completed.result.draggableId === id) {
    return false;
  }
  return state.completed.result.reason === "DROP";
};
var scrollWindow = (change) => {
  window.scrollBy(change.x, change.y);
};
var getScrollableDroppables = memoizeOne((droppables) => toDroppableList(droppables).filter((droppable2) => {
  if (!droppable2.isEnabled) {
    return false;
  }
  if (!droppable2.frame) {
    return false;
  }
  return true;
}));
var getScrollableDroppableOver = (target, droppables) => {
  const maybe = getScrollableDroppables(droppables).find((droppable2) => {
    !droppable2.frame ? process.env.NODE_ENV !== "production" ? invariant2(false, "Invalid result") : invariant2() : void 0;
    return isPositionInFrame(droppable2.frame.pageMarginBox)(target);
  }) || null;
  return maybe;
};
var getBestScrollableDroppable = ({
  center,
  destination,
  droppables
}) => {
  if (destination) {
    const dimension2 = droppables[destination];
    if (!dimension2.frame) {
      return null;
    }
    return dimension2;
  }
  const dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
};
var defaultAutoScrollerOptions = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: (percentage) => __pow(percentage, 2),
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  },
  disabled: false
};
var getDistanceThresholds = (container, axis, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;
  const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;
  const thresholds = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds;
};
var getPercentage = ({
  startOfRange,
  endOfRange,
  current
}) => {
  const range = endOfRange - startOfRange;
  if (range === 0) {
    process.env.NODE_ENV !== "production" ? warning2(`
      Detected distance range of 0 in the fluid auto scroller
      This is unexpected and would cause a divide by 0 issue.
      Not allowing an auto scroll
    `) : void 0;
    return 0;
  }
  const currentInRange = current - startOfRange;
  const percentage = currentInRange / range;
  return percentage;
};
var minScroll = 1;
var getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return autoScrollerOptions.maxPixelScroll;
  }
  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }
  const percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  const scroll2 = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll2);
};
var dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;
  const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;
  const startOfRange = dragStartTime;
  const endOfRange = stopAt;
  const now = Date.now();
  const runTime = now - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  const betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  const scroll2 = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll2);
};
var getValue = ({
  distanceToEdge,
  thresholds,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const scroll2 = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);
  if (scroll2 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll2;
  }
  return Math.max(dampenValueByTime(scroll2, dragStartTime, getAutoScrollerOptions), minScroll);
};
var getScrollOnAxis = ({
  container,
  distanceToEdges,
  dragStartTime,
  axis,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);
  const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return getValue({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds,
      dragStartTime,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
  }
  return -1 * getValue({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds,
    dragStartTime,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
};
var adjustForSizeLimits = ({
  container,
  subject,
  proposedScroll
}) => {
  const isTooBigVertically = subject.height > container.height;
  const isTooBigHorizontally = subject.width > container.width;
  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }
  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }
  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
};
var clean = apply((value) => value === 0 ? 0 : value);
var getScroll$1 = ({
  dragStartTime,
  container,
  subject,
  center,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  const y = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  const x2 = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  const required2 = clean({
    x: x2,
    y
  });
  if (isEqual$1(required2, origin)) {
    return null;
  }
  const limited = adjustForSizeLimits({
    container,
    subject,
    proposedScroll: required2
  });
  if (!limited) {
    return null;
  }
  return isEqual$1(limited, origin) ? null : limited;
};
var smallestSigned = apply((value) => {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
var getOverlap = /* @__PURE__ */ (() => {
  const getRemainder = (target, max3) => {
    if (target < 0) {
      return target;
    }
    if (target > max3) {
      return target - max3;
    }
    return 0;
  };
  return ({
    current,
    max: max3,
    change
  }) => {
    const targetScroll = add(current, change);
    const overlap = {
      x: getRemainder(targetScroll.x, max3.x),
      y: getRemainder(targetScroll.y, max3.y)
    };
    if (isEqual$1(overlap, origin)) {
      return null;
    }
    return overlap;
  };
})();
var canPartiallyScroll = ({
  max: rawMax,
  current,
  change
}) => {
  const max3 = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  const smallestChange = smallestSigned(change);
  const overlap = getOverlap({
    max: max3,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
var canScrollWindow = (viewport, change) => canPartiallyScroll({
  current: viewport.scroll.current,
  max: viewport.scroll.max,
  change
});
var getWindowOverlap = (viewport, change) => {
  if (!canScrollWindow(viewport, change)) {
    return null;
  }
  const max3 = viewport.scroll.max;
  const current = viewport.scroll.current;
  return getOverlap({
    current,
    max: max3,
    change
  });
};
var canScrollDroppable = (droppable2, change) => {
  const frame = droppable2.frame;
  if (!frame) {
    return false;
  }
  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getDroppableOverlap = (droppable2, change) => {
  const frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  if (!canScrollDroppable(droppable2, change)) {
    return null;
  }
  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getWindowScrollChange = ({
  viewport,
  subject,
  center,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const scroll2 = getScroll$1({
    dragStartTime,
    container: viewport.frame,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  return scroll2 && canScrollWindow(viewport, scroll2) ? scroll2 : null;
};
var getDroppableScrollChange = ({
  droppable: droppable2,
  subject,
  center,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  const scroll2 = getScroll$1({
    dragStartTime,
    container: frame.pageMarginBox,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  return scroll2 && canScrollDroppable(droppable2, scroll2) ? scroll2 : null;
};
var scroll = ({
  state,
  dragStartTime,
  shouldUseTimeDampening,
  scrollWindow: scrollWindow2,
  scrollDroppable: scrollDroppable2,
  getAutoScrollerOptions
}) => {
  const center = state.current.page.borderBoxCenter;
  const draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  const subject = draggable2.page.marginBox;
  if (state.isWindowScrollAllowed) {
    const viewport = state.viewport;
    const change2 = getWindowScrollChange({
      dragStartTime,
      viewport,
      subject,
      center,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
    if (change2) {
      scrollWindow2(change2);
      return;
    }
  }
  const droppable2 = getBestScrollableDroppable({
    center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });
  if (!droppable2) {
    return;
  }
  const change = getDroppableScrollChange({
    dragStartTime,
    droppable: droppable2,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  if (change) {
    scrollDroppable2(droppable2.descriptor.id, change);
  }
};
var createFluidScroller = ({
  scrollWindow: scrollWindow2,
  scrollDroppable: scrollDroppable2,
  getAutoScrollerOptions = () => defaultAutoScrollerOptions
}) => {
  const scheduleWindowScroll = raf_schd_esm_default(scrollWindow2);
  const scheduleDroppableScroll = raf_schd_esm_default(scrollDroppable2);
  let dragging = null;
  const tryScroll = (state) => {
    !dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot fluid scroll if not dragging") : invariant2() : void 0;
    const {
      shouldUseTimeDampening,
      dragStartTime
    } = dragging;
    scroll({
      state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
  };
  const start$1 = (state) => {
    start();
    !!dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot start auto scrolling when already started") : invariant2() : void 0;
    const dragStartTime = Date.now();
    let wasScrollNeeded = false;
    const fakeScrollCallback = () => {
      wasScrollNeeded = true;
    };
    scroll({
      state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback,
      getAutoScrollerOptions
    });
    dragging = {
      dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    finish();
    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };
  const stop = () => {
    if (!dragging) {
      return;
    }
    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };
  return {
    start: start$1,
    stop,
    scroll: tryScroll
  };
};
var createJumpScroller = ({
  move: move2,
  scrollDroppable: scrollDroppable2,
  scrollWindow: scrollWindow2
}) => {
  const moveByOffset = (state, offset6) => {
    const client = add(state.current.client.selection, offset6);
    move2({
      client
    });
  };
  const scrollDroppableAsMuchAsItCan = (droppable2, change) => {
    if (!canScrollDroppable(droppable2, change)) {
      return change;
    }
    const overlap = getDroppableOverlap(droppable2, change);
    if (!overlap) {
      scrollDroppable2(droppable2.descriptor.id, change);
      return null;
    }
    const whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable2(droppable2.descriptor.id, whatTheDroppableCanScroll);
    const remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };
  const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change) => {
    if (!isWindowScrollAllowed) {
      return change;
    }
    if (!canScrollWindow(viewport, change)) {
      return change;
    }
    const overlap = getWindowOverlap(viewport, change);
    if (!overlap) {
      scrollWindow2(change);
      return null;
    }
    const whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow2(whatTheWindowCanScroll);
    const remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };
  const jumpScroller = (state) => {
    const request = state.scrollJumpRequest;
    if (!request) {
      return;
    }
    const destination = whatIsDraggedOver(state.impact);
    !destination ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot perform a jump scroll when there is no destination") : invariant2() : void 0;
    const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
    if (!droppableRemainder) {
      return;
    }
    const viewport = state.viewport;
    const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
    if (!windowRemainder) {
      return;
    }
    moveByOffset(state, windowRemainder);
  };
  return jumpScroller;
};
var createAutoScroller = ({
  scrollDroppable: scrollDroppable2,
  scrollWindow: scrollWindow2,
  move: move2,
  getAutoScrollerOptions
}) => {
  const fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2,
    getAutoScrollerOptions
  });
  const jumpScroll = createJumpScroller({
    move: move2,
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  const scroll2 = (state) => {
    const autoScrollerOptions = getAutoScrollerOptions();
    if (autoScrollerOptions.disabled || state.phase !== "DRAGGING") {
      return;
    }
    if (state.movementMode === "FLUID") {
      fluidScroller.scroll(state);
      return;
    }
    if (!state.scrollJumpRequest) {
      return;
    }
    jumpScroll(state);
  };
  const scroller = {
    scroll: scroll2,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
};
var prefix2 = "data-rfd";
var dragHandle = (() => {
  const base = `${prefix2}-drag-handle`;
  return {
    base,
    draggableId: `${base}-draggable-id`,
    contextId: `${base}-context-id`
  };
})();
var draggable = (() => {
  const base = `${prefix2}-draggable`;
  return {
    base,
    contextId: `${base}-context-id`,
    id: `${base}-id`
  };
})();
var droppable = (() => {
  const base = `${prefix2}-droppable`;
  return {
    base,
    contextId: `${base}-context-id`,
    id: `${base}-id`
  };
})();
var scrollContainer = {
  contextId: `${prefix2}-scroll-container-context-id`
};
var makeGetSelector = (context) => (attribute) => `[${attribute}="${context}"]`;
var getStyles2 = (rules, property) => rules.map((rule) => {
  const value = rule.styles[property];
  if (!value) {
    return "";
  }
  return `${rule.selector} { ${value} }`;
}).join(" ");
var noPointerEvents = "pointer-events: none;";
var getStyles$1 = (contextId) => {
  const getSelector2 = makeGetSelector(contextId);
  const dragHandle$1 = (() => {
    const grabCursor = `
      cursor: -webkit-grab;
      cursor: grab;
    `;
    return {
      selector: getSelector2(dragHandle.contextId),
      styles: {
        always: `
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: rgba(0,0,0,0);
          touch-action: manipulation;
        `,
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  })();
  const draggable$1 = (() => {
    const transition = `
      transition: ${transitions.outOfTheWay};
    `;
    return {
      selector: getSelector2(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  })();
  const droppable$1 = {
    selector: getSelector2(droppable.contextId),
    styles: {
      always: `overflow-anchor: none;`
    }
  };
  const body = {
    selector: "body",
    styles: {
      dragging: `
        cursor: grabbing;
        cursor: -webkit-grabbing;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        overflow-anchor: none;
      `
    }
  };
  const rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles2(rules, "always"),
    resting: getStyles2(rules, "resting"),
    dragging: getStyles2(rules, "dragging"),
    dropAnimating: getStyles2(rules, "dropAnimating"),
    userCancel: getStyles2(rules, "userCancel")
  };
};
var useIsomorphicLayoutEffect5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react42.useLayoutEffect : import_react42.useEffect;
var getHead = () => {
  const head = document.querySelector("head");
  !head ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot find the head to append a style to") : invariant2() : void 0;
  return head;
};
var createStyleEl = (nonce2) => {
  const el = document.createElement("style");
  if (nonce2) {
    el.setAttribute("nonce", nonce2);
  }
  el.type = "text/css";
  return el;
};
function useStyleMarshal(contextId, nonce2) {
  const styles = useMemo17(() => getStyles$1(contextId), [contextId]);
  const alwaysRef = (0, import_react42.useRef)(null);
  const dynamicRef = (0, import_react42.useRef)(null);
  const setDynamicStyle = useCallback29(memoizeOne((proposed) => {
    const el = dynamicRef.current;
    !el ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot set dynamic style element if it is not set") : invariant2() : void 0;
    el.textContent = proposed;
  }), []);
  const setAlwaysStyle = useCallback29((proposed) => {
    const el = alwaysRef.current;
    !el ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot set dynamic style element if it is not set") : invariant2() : void 0;
    el.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect5(() => {
    !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== "production" ? invariant2(false, "style elements already mounted") : invariant2() : void 0;
    const always = createStyleEl(nonce2);
    const dynamic = createStyleEl(nonce2);
    alwaysRef.current = always;
    dynamicRef.current = dynamic;
    always.setAttribute(`${prefix2}-always`, contextId);
    dynamic.setAttribute(`${prefix2}-dynamic`, contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic);
    setAlwaysStyle(styles.always);
    setDynamicStyle(styles.resting);
    return () => {
      const remove = (ref2) => {
        const current = ref2.current;
        !current ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot unmount ref as it is not set") : invariant2() : void 0;
        getHead().removeChild(current);
        ref2.current = null;
      };
      remove(alwaysRef);
      remove(dynamicRef);
    };
  }, [nonce2, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);
  const dragging = useCallback29(() => setDynamicStyle(styles.dragging), [setDynamicStyle, styles.dragging]);
  const dropping = useCallback29((reason) => {
    if (reason === "DROP") {
      setDynamicStyle(styles.dropAnimating);
      return;
    }
    setDynamicStyle(styles.userCancel);
  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);
  const resting = useCallback29(() => {
    if (!dynamicRef.current) {
      return;
    }
    setDynamicStyle(styles.resting);
  }, [setDynamicStyle, styles.resting]);
  const marshal = useMemo17(() => ({
    dragging,
    dropping,
    resting
  }), [dragging, dropping, resting]);
  return marshal;
}
function querySelectorAll(parentNode, selector) {
  return Array.from(parentNode.querySelectorAll(selector));
}
var getWindowFromEl = (el) => {
  if (el && el.ownerDocument && el.ownerDocument.defaultView) {
    return el.ownerDocument.defaultView;
  }
  return window;
};
function isHtmlElement(el) {
  return el instanceof getWindowFromEl(el).HTMLElement;
}
function findDragHandle(contextId, draggableId) {
  const selector = `[${dragHandle.contextId}="${contextId}"]`;
  const possible = querySelectorAll(document, selector);
  if (!possible.length) {
    process.env.NODE_ENV !== "production" ? warning2(`Unable to find any drag handles in the context "${contextId}"`) : void 0;
    return null;
  }
  const handle = possible.find((el) => {
    return el.getAttribute(dragHandle.draggableId) === draggableId;
  });
  if (!handle) {
    process.env.NODE_ENV !== "production" ? warning2(`Unable to find drag handle with id "${draggableId}" as no handle with a matching id was found`) : void 0;
    return null;
  }
  if (!isHtmlElement(handle)) {
    process.env.NODE_ENV !== "production" ? warning2("drag handle needs to be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function useFocusMarshal(contextId) {
  const entriesRef = (0, import_react42.useRef)({});
  const recordRef = (0, import_react42.useRef)(null);
  const restoreFocusFrameRef = (0, import_react42.useRef)(null);
  const isMountedRef = (0, import_react42.useRef)(false);
  const register = useCallback29(function register2(id, focus4) {
    const entry = {
      id,
      focus: focus4
    };
    entriesRef.current[id] = entry;
    return function unregister() {
      const entries = entriesRef.current;
      const current = entries[id];
      if (current !== entry) {
        delete entries[id];
      }
    };
  }, []);
  const tryGiveFocus = useCallback29(function tryGiveFocus2(tryGiveFocusTo) {
    const handle = findDragHandle(contextId, tryGiveFocusTo);
    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  const tryShiftRecord = useCallback29(function tryShiftRecord2(previous, redirectTo) {
    if (recordRef.current === previous) {
      recordRef.current = redirectTo;
    }
  }, []);
  const tryRestoreFocusRecorded = useCallback29(function tryRestoreFocusRecorded2() {
    if (restoreFocusFrameRef.current) {
      return;
    }
    if (!isMountedRef.current) {
      return;
    }
    restoreFocusFrameRef.current = requestAnimationFrame(() => {
      restoreFocusFrameRef.current = null;
      const record = recordRef.current;
      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  const tryRecordFocus = useCallback29(function tryRecordFocus2(id) {
    recordRef.current = null;
    const focused = document.activeElement;
    if (!focused) {
      return;
    }
    if (focused.getAttribute(dragHandle.draggableId) !== id) {
      return;
    }
    recordRef.current = id;
  }, []);
  useIsomorphicLayoutEffect5(() => {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      const frameId = restoreFocusFrameRef.current;
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  const marshal = useMemo17(() => ({
    register,
    tryRecordFocus,
    tryRestoreFocusRecorded,
    tryShiftRecord
  }), [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}
function createRegistry() {
  const entries = {
    draggables: {},
    droppables: {}
  };
  const subscribers = [];
  function subscribe2(cb) {
    subscribers.push(cb);
    return function unsubscribe() {
      const index2 = subscribers.indexOf(cb);
      if (index2 === -1) {
        return;
      }
      subscribers.splice(index2, 1);
    };
  }
  function notify(event) {
    if (subscribers.length) {
      subscribers.forEach((cb) => cb(event));
    }
  }
  function findDraggableById(id) {
    return entries.draggables[id] || null;
  }
  function getDraggableById(id) {
    const entry = findDraggableById(id);
    !entry ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot find draggable entry with id [${id}]`) : invariant2() : void 0;
    return entry;
  }
  const draggableAPI = {
    register: (entry) => {
      entries.draggables[entry.descriptor.id] = entry;
      notify({
        type: "ADDITION",
        value: entry
      });
    },
    update: (entry, last) => {
      const current = entries.draggables[last.descriptor.id];
      if (!current) {
        return;
      }
      if (current.uniqueId !== entry.uniqueId) {
        return;
      }
      delete entries.draggables[last.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: (entry) => {
      const draggableId = entry.descriptor.id;
      const current = findDraggableById(draggableId);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.draggables[draggableId];
      if (entries.droppables[entry.descriptor.droppableId]) {
        notify({
          type: "REMOVAL",
          value: entry
        });
      }
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: (id) => Boolean(findDraggableById(id)),
    getAllByType: (type) => Object.values(entries.draggables).filter((entry) => entry.descriptor.type === type)
  };
  function findDroppableById(id) {
    return entries.droppables[id] || null;
  }
  function getDroppableById(id) {
    const entry = findDroppableById(id);
    !entry ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot find droppable entry with id [${id}]`) : invariant2() : void 0;
    return entry;
  }
  const droppableAPI = {
    register: (entry) => {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: (entry) => {
      const current = findDroppableById(entry.descriptor.id);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: (id) => Boolean(findDroppableById(id)),
    getAllByType: (type) => Object.values(entries.droppables).filter((entry) => entry.descriptor.type === type)
  };
  function clean2() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }
  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe: subscribe2,
    clean: clean2
  };
}
function useRegistry() {
  const registry = useMemo17(createRegistry, []);
  (0, import_react42.useEffect)(() => {
    return function unmount() {
      registry.clean();
    };
  }, [registry]);
  return registry;
}
var StoreContext = import_react42.default.createContext(null);
var getBodyElement = () => {
  const body = document.body;
  !body ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot find document.body") : invariant2() : void 0;
  return body;
};
var visuallyHidden = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
var getId = (contextId) => `rfd-announcement-${contextId}`;
function useAnnouncer(contextId) {
  const id = useMemo17(() => getId(contextId), [contextId]);
  const ref2 = (0, import_react42.useRef)(null);
  (0, import_react42.useEffect)(function setup() {
    const el = document.createElement("div");
    ref2.current = el;
    el.id = id;
    el.setAttribute("aria-live", "assertive");
    el.setAttribute("aria-atomic", "true");
    _extends(el.style, visuallyHidden);
    getBodyElement().appendChild(el);
    return function cleanup() {
      setTimeout(function remove() {
        const body = getBodyElement();
        if (body.contains(el)) {
          body.removeChild(el);
        }
        if (el === ref2.current) {
          ref2.current = null;
        }
      });
    };
  }, [id]);
  const announce = useCallback29((message2) => {
    const el = ref2.current;
    if (el) {
      el.textContent = message2;
      return;
    }
    process.env.NODE_ENV !== "production" ? warning2(`
      A screen reader message was trying to be announced but it was unable to do so.
      This can occur if you unmount your <DragDropContext /> in your onDragEnd.
      Consider calling provided.announce() before the unmount so that the instruction will
      not be lost for users relying on a screen reader.

      Message not passed to screen reader:

      "${message2}"
    `) : void 0;
  }, []);
  return announce;
}
var defaults = {
  separator: "::"
};
function useUniqueId(prefix3, options = defaults) {
  const id = import_react42.default.useId();
  return useMemo17(() => `${prefix3}${options.separator}${id}`, [options.separator, prefix3, id]);
}
function getElementId({
  contextId,
  uniqueId
}) {
  return `rfd-hidden-text-${contextId}-${uniqueId}`;
}
function useHiddenTextElement({
  contextId,
  text
}) {
  const uniqueId = useUniqueId("hidden-text", {
    separator: "-"
  });
  const id = useMemo17(() => getElementId({
    contextId,
    uniqueId
  }), [uniqueId, contextId]);
  (0, import_react42.useEffect)(function mount() {
    const el = document.createElement("div");
    el.id = id;
    el.textContent = text;
    el.style.display = "none";
    getBodyElement().appendChild(el);
    return function unmount() {
      const body = getBodyElement();
      if (body.contains(el)) {
        body.removeChild(el);
      }
    };
  }, [id, text]);
  return id;
}
var AppContext = import_react42.default.createContext(null);
var peerDependencies = {
  react: "^18.0.0 || ^19.0.0"
};
var semver = /(\d+)\.(\d+)\.(\d+)/;
var getVersion = (value) => {
  const result = semver.exec(value);
  !(result != null) ? process.env.NODE_ENV !== "production" ? invariant2(false, `Unable to parse React version ${value}`) : invariant2() : void 0;
  const major = Number(result[1]);
  const minor = Number(result[2]);
  const patch2 = Number(result[3]);
  return {
    major,
    minor,
    patch: patch2,
    raw: value
  };
};
var isSatisfied = (expected, actual) => {
  if (actual.major > expected.major) {
    return true;
  }
  if (actual.major < expected.major) {
    return false;
  }
  if (actual.minor > expected.minor) {
    return true;
  }
  if (actual.minor < expected.minor) {
    return false;
  }
  return actual.patch >= expected.patch;
};
var checkReactVersion = (peerDepValue, actualValue) => {
  const peerDep = getVersion(peerDepValue);
  const actual = getVersion(actualValue);
  if (isSatisfied(peerDep, actual)) {
    return;
  }
  process.env.NODE_ENV !== "production" ? warning2(`
    React version: [${actual.raw}]
    does not satisfy expected peer dependency version: [${peerDep.raw}]

    This can result in run time bugs, and even fatal crashes
  `) : void 0;
};
var suffix = `
  We expect a html5 doctype: <!doctype html>
  This is to ensure consistent browser layout and measurement

  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md
`;
var checkDoctype = (doc) => {
  const doctype = doc.doctype;
  if (!doctype) {
    process.env.NODE_ENV !== "production" ? warning2(`
      No <!doctype html> found.

      ${suffix}
    `) : void 0;
    return;
  }
  if (doctype.name.toLowerCase() !== "html") {
    process.env.NODE_ENV !== "production" ? warning2(`
      Unexpected <!doctype> found: (${doctype.name})

      ${suffix}
    `) : void 0;
  }
  if (doctype.publicId !== "") {
    process.env.NODE_ENV !== "production" ? warning2(`
      Unexpected <!doctype> publicId found: (${doctype.publicId})
      A html5 doctype does not have a publicId

      ${suffix}
    `) : void 0;
  }
};
function useDev(useHook) {
  if (process.env.NODE_ENV !== "production") {
    useHook();
  }
}
function useDevSetupWarning(fn, inputs) {
  useDev(() => {
    (0, import_react42.useEffect)(() => {
      try {
        fn();
      } catch (e) {
        error(`
          A setup problem was encountered.

          > ${e.message}
        `);
      }
    }, inputs);
  });
}
function useStartupValidation() {
  useDevSetupWarning(() => {
    checkReactVersion(peerDependencies.react, import_react42.default.version);
    checkDoctype(document);
  }, []);
}
function usePrevious2(current) {
  const ref2 = (0, import_react42.useRef)(current);
  (0, import_react42.useEffect)(() => {
    ref2.current = current;
  });
  return ref2;
}
function create() {
  let lock = null;
  function isClaimed() {
    return Boolean(lock);
  }
  function isActive2(value) {
    return value === lock;
  }
  function claim(abandon) {
    !!lock ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot claim lock as it is already claimed") : invariant2() : void 0;
    const newLock = {
      abandon
    };
    lock = newLock;
    return newLock;
  }
  function release() {
    !lock ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot release lock when there is no lock") : invariant2() : void 0;
    lock = null;
  }
  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }
  return {
    isClaimed,
    isActive: isActive2,
    claim,
    release,
    tryAbandon
  };
}
function isDragging(state) {
  if (state.phase === "IDLE" || state.phase === "DROP_ANIMATING") {
    return false;
  }
  return state.isDragging;
}
var tab = 9;
var enter = 13;
var escape = 27;
var space = 32;
var pageUp = 33;
var pageDown = 34;
var end = 35;
var home = 36;
var arrowLeft = 37;
var arrowUp = 38;
var arrowRight = 39;
var arrowDown = 40;
var preventedKeys = {
  [enter]: true,
  [tab]: true
};
var preventStandardKeyEvents = (event) => {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
};
var supportedEventName = (() => {
  const base = "visibilitychange";
  if (typeof document === "undefined") {
    return base;
  }
  const candidates = [base, `ms${base}`, `webkit${base}`, `moz${base}`, `o${base}`];
  const supported = candidates.find((eventName) => `on${eventName}` in document);
  return supported || base;
})();
var primaryButton = 0;
var sloppyClickThreshold = 5;
function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}
var idle$1 = {
  type: "IDLE"
};
function getCaptureBindings({
  cancel,
  completed,
  getPhase,
  setPhase
}) {
  return [{
    eventName: "mousemove",
    fn: (event) => {
      const {
        button,
        clientX,
        clientY
      } = event;
      if (button !== primaryButton) {
        return;
      }
      const point = {
        x: clientX,
        y: clientY
      };
      const phase = getPhase();
      if (phase.type === "DRAGGING") {
        event.preventDefault();
        phase.actions.move(point);
        return;
      }
      !(phase.type === "PENDING") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot be IDLE") : invariant2() : void 0;
      const pending = phase.point;
      if (!isSloppyClickThresholdExceeded(pending, point)) {
        return;
      }
      event.preventDefault();
      const actions = phase.actions.fluidLift(point);
      setPhase({
        type: "DRAGGING",
        actions
      });
    }
  }, {
    eventName: "mouseup",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "mousedown",
    fn: (event) => {
      if (getPhase().type === "DRAGGING") {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: "keydown",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type === "PENDING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: () => {
      if (getPhase().type === "PENDING") {
        cancel();
      }
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: (event) => {
      const phase = getPhase();
      !(phase.type !== "IDLE") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Unexpected phase") : invariant2() : void 0;
      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useMouseSensor(api) {
  const phaseRef = (0, import_react42.useRef)(idle$1);
  const unbindEventsRef = (0, import_react42.useRef)(noop$2);
  const startCaptureBinding = useMemo17(() => ({
    eventName: "mousedown",
    fn: function onMouseDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.button !== primaryButton) {
        return;
      }
      if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const actions = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!actions) {
        return;
      }
      event.preventDefault();
      const point = {
        x: event.clientX,
        y: event.clientY
      };
      unbindEventsRef.current();
      startPendingDrag(actions, point);
    }
  }), [api]);
  const preventForcePressBinding = useMemo17(() => ({
    eventName: "webkitmouseforcewillbegin",
    fn: (event) => {
      if (event.defaultPrevented) {
        return;
      }
      const id = api.findClosestDraggableId(event);
      if (!id) {
        return;
      }
      const options = api.findOptionsForDraggable(id);
      if (!options) {
        return;
      }
      if (options.shouldRespectForcePress) {
        return;
      }
      if (!api.canGetLock(id)) {
        return;
      }
      event.preventDefault();
    }
  }), [api]);
  const listenForCapture = useCallback29(function listenForCapture2() {
    const options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
  }, [preventForcePressBinding, startCaptureBinding]);
  const stop = useCallback29(() => {
    const current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  const cancel = useCallback29(() => {
    const phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  const bindCapturingEvents = useCallback29(function bindCapturingEvents2() {
    const options = {
      capture: true,
      passive: false
    };
    const bindings = getCaptureBindings({
      cancel,
      completed: stop,
      getPhase: () => phaseRef.current,
      setPhase: (phase) => {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options);
  }, [cancel, stop]);
  const startPendingDrag = useCallback29(function startPendingDrag2(actions, point) {
    !(phaseRef.current.type === "IDLE") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Expected to move from IDLE to PENDING drag") : invariant2() : void 0;
    phaseRef.current = {
      type: "PENDING",
      point,
      actions
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect5(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
function noop$1() {
}
var scrollJumpKeys = {
  [pageDown]: true,
  [pageUp]: true,
  [home]: true,
  [end]: true
};
function getDraggingBindings(actions, stop) {
  function cancel() {
    stop();
    actions.cancel();
  }
  function drop2() {
    stop();
    actions.drop();
  }
  return [{
    eventName: "keydown",
    fn: (event) => {
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      if (event.keyCode === space) {
        event.preventDefault();
        drop2();
        return;
      }
      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions.moveDown();
        return;
      }
      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions.moveUp();
        return;
      }
      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions.moveRight();
        return;
      }
      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions.moveLeft();
        return;
      }
      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "mousedown",
    fn: cancel
  }, {
    eventName: "mouseup",
    fn: cancel
  }, {
    eventName: "click",
    fn: cancel
  }, {
    eventName: "touchstart",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "wheel",
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useKeyboardSensor(api) {
  const unbindEventsRef = (0, import_react42.useRef)(noop$1);
  const startCaptureBinding = useMemo17(() => ({
    eventName: "keydown",
    fn: function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.keyCode !== space) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const preDrag = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!preDrag) {
        return;
      }
      event.preventDefault();
      let isCapturing = true;
      const actions = preDrag.snapLift();
      unbindEventsRef.current();
      function stop() {
        !isCapturing ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot stop capturing a keyboard drag when not capturing") : invariant2() : void 0;
        isCapturing = false;
        unbindEventsRef.current();
        listenForCapture();
      }
      unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
        capture: true,
        passive: false
      });
    }
  }), [api]);
  const listenForCapture = useCallback29(function tryStartCapture() {
    const options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect5(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var idle = {
  type: "IDLE"
};
var timeForLongPress = 120;
var forcePressThreshold = 0.15;
function getWindowBindings({
  cancel,
  getPhase
}) {
  return [{
    eventName: "orientationchange",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "contextmenu",
    fn: (event) => {
      event.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: (event) => {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function getHandleBindings({
  cancel,
  completed,
  getPhase
}) {
  return [{
    eventName: "touchmove",
    options: {
      capture: false
    },
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      phase.hasMoved = true;
      const {
        clientX,
        clientY
      } = event.touches[0];
      const point = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point);
    }
  }, {
    eventName: "touchend",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "touchcancel",
    fn: (event) => {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      cancel();
    }
  }, {
    eventName: "touchforcechange",
    fn: (event) => {
      const phase = getPhase();
      !(phase.type !== "IDLE") ? process.env.NODE_ENV !== "production" ? invariant2() : invariant2() : void 0;
      const touch = event.touches[0];
      if (!touch) {
        return;
      }
      const isForcePress = touch.force >= forcePressThreshold;
      if (!isForcePress) {
        return;
      }
      const shouldRespect = phase.actions.shouldRespectForcePress();
      if (phase.type === "PENDING") {
        if (shouldRespect) {
          cancel();
        }
        return;
      }
      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useTouchSensor(api) {
  const phaseRef = (0, import_react42.useRef)(idle);
  const unbindEventsRef = (0, import_react42.useRef)(noop$2);
  const getPhase = useCallback29(function getPhase2() {
    return phaseRef.current;
  }, []);
  const setPhase = useCallback29(function setPhase2(phase) {
    phaseRef.current = phase;
  }, []);
  const startCaptureBinding = useMemo17(() => ({
    eventName: "touchstart",
    fn: function onTouchStart(event) {
      if (event.defaultPrevented) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const actions = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!actions) {
        return;
      }
      const touch = event.touches[0];
      const {
        clientX,
        clientY
      } = touch;
      const point = {
        x: clientX,
        y: clientY
      };
      unbindEventsRef.current();
      startPendingDrag(actions, point);
    }
  }), [api]);
  const listenForCapture = useCallback29(function listenForCapture2() {
    const options = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  const stop = useCallback29(() => {
    const current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    if (current.type === "PENDING") {
      clearTimeout(current.longPressTimerId);
    }
    setPhase(idle);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  const cancel = useCallback29(() => {
    const phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  const bindCapturingEvents = useCallback29(function bindCapturingEvents2() {
    const options = {
      capture: true,
      passive: false
    };
    const args = {
      cancel,
      completed: stop,
      getPhase
    };
    const unbindTarget = bindEvents(window, getHandleBindings(args), options);
    const unbindWindow = bindEvents(window, getWindowBindings(args), options);
    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  const startDragging = useCallback29(function startDragging2() {
    const phase = getPhase();
    !(phase.type === "PENDING") ? process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot start dragging from phase ${phase.type}`) : invariant2() : void 0;
    const actions = phase.actions.fluidLift(phase.point);
    setPhase({
      type: "DRAGGING",
      actions,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  const startPendingDrag = useCallback29(function startPendingDrag2(actions, point) {
    !(getPhase().type === "IDLE") ? process.env.NODE_ENV !== "production" ? invariant2(false, "Expected to move from IDLE to PENDING drag") : invariant2() : void 0;
    const longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: "PENDING",
      point,
      actions,
      longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect5(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      const phase = getPhase();
      if (phase.type === "PENDING") {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect5(function webkitHack() {
    const unbind = bindEvents(window, [{
      eventName: "touchmove",
      fn: () => {
      },
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}
function useValidateSensorHooks(sensorHooks) {
  useDev(() => {
    const previousRef = usePrevious2(sensorHooks);
    useDevSetupWarning(() => {
      !(previousRef.current.length === sensorHooks.length) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot change the amount of sensor hooks after mounting") : invariant2(false) : void 0;
    });
  });
}
var interactiveTagNames = ["input", "button", "textarea", "select", "option", "optgroup", "video", "audio"];
function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }
  const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());
  if (hasAnInteractiveTag) {
    return true;
  }
  const attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent) {
    return false;
  }
  return isAnInteractiveElement(parent, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  const target = event.target;
  if (!isHtmlElement(target)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}
var getBorderBoxCenterPosition = (el) => getRect(el.getBoundingClientRect()).center;
function isElement2(el) {
  return el instanceof getWindowFromEl(el).Element;
}
var supportedMatchesName = (() => {
  const base = "matches";
  if (typeof document === "undefined") {
    return base;
  }
  const candidates = [base, "msMatchesSelector", "webkitMatchesSelector"];
  const value = candidates.find((name) => name in Element.prototype);
  return value || base;
})();
function closestPonyfill(el, selector) {
  if (el == null) {
    return null;
  }
  if (el[supportedMatchesName](selector)) {
    return el;
  }
  return closestPonyfill(el.parentElement, selector);
}
function closest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  return closestPonyfill(el, selector);
}
function getSelector(contextId) {
  return `[${dragHandle.contextId}="${contextId}"]`;
}
function findClosestDragHandleFromEvent(contextId, event) {
  const target = event.target;
  if (!isElement2(target)) {
    process.env.NODE_ENV !== "production" ? warning2("event.target must be a Element") : void 0;
    return null;
  }
  const selector = getSelector(contextId);
  const handle = closest(target, selector);
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    process.env.NODE_ENV !== "production" ? warning2("drag handle must be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function tryGetClosestDraggableIdFromEvent(contextId, event) {
  const handle = findClosestDragHandleFromEvent(contextId, event);
  if (!handle) {
    return null;
  }
  return handle.getAttribute(dragHandle.draggableId);
}
function findDraggable(contextId, draggableId) {
  const selector = `[${draggable.contextId}="${contextId}"]`;
  const possible = querySelectorAll(document, selector);
  const draggable$1 = possible.find((el) => {
    return el.getAttribute(draggable.id) === draggableId;
  });
  if (!draggable$1) {
    return null;
  }
  if (!isHtmlElement(draggable$1)) {
    process.env.NODE_ENV !== "production" ? warning2("Draggable element is not a HTMLElement") : void 0;
    return null;
  }
  return draggable$1;
}
function preventDefault(event) {
  event.preventDefault();
}
function isActive({
  expected,
  phase,
  isLockActive,
  shouldWarn
}) {
  if (!isLockActive()) {
    if (shouldWarn) {
      process.env.NODE_ENV !== "production" ? warning2(`
        Cannot perform action.
        The sensor no longer has an action lock.

        Tips:

        - Throw away your action handlers when forceStop() is called
        - Check actions.isActive() if you really need to
      `) : void 0;
    }
    return false;
  }
  if (expected !== phase) {
    if (shouldWarn) {
      process.env.NODE_ENV !== "production" ? warning2(`
        Cannot perform action.
        The actions you used belong to an outdated phase

        Current phase: ${expected}
        You called an action from outdated phase: ${phase}

        Tips:

        - Do not use preDragActions actions after calling preDragActions.lift()
      `) : void 0;
    }
    return false;
  }
  return true;
}
function canStart({
  lockAPI,
  store,
  registry,
  draggableId
}) {
  if (lockAPI.isClaimed()) {
    return false;
  }
  const entry = registry.draggable.findById(draggableId);
  if (!entry) {
    process.env.NODE_ENV !== "production" ? warning2(`Unable to find draggable with id: ${draggableId}`) : void 0;
    return false;
  }
  if (!entry.options.isEnabled) {
    return false;
  }
  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }
  return true;
}
function tryStart({
  lockAPI,
  contextId,
  store,
  registry,
  draggableId,
  forceSensorStop,
  sourceEvent
}) {
  const shouldStart = canStart({
    lockAPI,
    store,
    registry,
    draggableId
  });
  if (!shouldStart) {
    return null;
  }
  const entry = registry.draggable.getById(draggableId);
  const el = findDraggable(contextId, entry.descriptor.id);
  if (!el) {
    process.env.NODE_ENV !== "production" ? warning2(`Unable to find draggable element with id: ${draggableId}`) : void 0;
    return null;
  }
  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
    return null;
  }
  const lock = lockAPI.claim(forceSensorStop || noop$2);
  let phase = "PRE_DRAG";
  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }
  function isLockActive() {
    return lockAPI.isActive(lock);
  }
  function tryDispatch(expected, getAction) {
    if (isActive({
      expected,
      phase,
      isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }
  const tryDispatchWhenDragging = tryDispatch.bind(null, "DRAGGING");
  function lift2(args) {
    function completed() {
      lockAPI.release();
      phase = "COMPLETED";
    }
    if (phase !== "PRE_DRAG") {
      completed();
      process.env.NODE_ENV !== "production" ? invariant2(false, `Cannot lift in phase ${phase}`) : invariant2();
    }
    store.dispatch(lift$1(args.liftActionArgs));
    phase = "DRAGGING";
    function finish2(reason, options = {
      shouldBlockNextClick: false
    }) {
      args.cleanup();
      if (options.shouldBlockNextClick) {
        const unbind = bindEvents(window, [{
          eventName: "click",
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }
      completed();
      store.dispatch(drop({
        reason
      }));
    }
    return __spreadValues({
      isActive: () => isActive({
        expected: "DRAGGING",
        phase,
        isLockActive,
        shouldWarn: false
      }),
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: (options) => finish2("DROP", options),
      cancel: (options) => finish2("CANCEL", options)
    }, args.actions);
  }
  function fluidLift(clientSelection) {
    const move$1 = raf_schd_esm_default((client) => {
      tryDispatchWhenDragging(() => move({
        client
      }));
    });
    const api = lift2({
      liftActionArgs: {
        id: draggableId,
        clientSelection,
        movementMode: "FLUID"
      },
      cleanup: () => move$1.cancel(),
      actions: {
        move: move$1
      }
    });
    return __spreadProps(__spreadValues({}, api), {
      move: move$1
    });
  }
  function snapLift() {
    const actions = {
      moveUp: () => tryDispatchWhenDragging(moveUp),
      moveRight: () => tryDispatchWhenDragging(moveRight),
      moveDown: () => tryDispatchWhenDragging(moveDown),
      moveLeft: () => tryDispatchWhenDragging(moveLeft)
    };
    return lift2({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el),
        movementMode: "SNAP"
      },
      cleanup: noop$2,
      actions
    });
  }
  function abortPreDrag() {
    const shouldRelease = isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: true
    });
    if (shouldRelease) {
      lockAPI.release();
    }
  }
  const preDrag = {
    isActive: () => isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: false
    }),
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift,
    snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}
var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal({
  contextId,
  store,
  registry,
  customSensors,
  enableDefaultSensors
}) {
  const useSensors = [...enableDefaultSensors ? defaultSensors : [], ...customSensors || []];
  const lockAPI = (0, import_react42.useState)(() => create())[0];
  const tryAbandonLock = useCallback29(function tryAbandonLock2(previous, current) {
    if (isDragging(previous) && !isDragging(current)) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect5(function listenToStore() {
    let previous = store.getState();
    const unsubscribe = store.subscribe(() => {
      const current = store.getState();
      tryAbandonLock(previous, current);
      previous = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect5(() => {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  const canGetLock = useCallback29((draggableId) => {
    return canStart({
      lockAPI,
      registry,
      store,
      draggableId
    });
  }, [lockAPI, registry, store]);
  const tryGetLock = useCallback29((draggableId, forceStop, options) => tryStart({
    lockAPI,
    registry,
    contextId,
    store,
    draggableId,
    forceSensorStop: forceStop || null,
    sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
  }), [contextId, lockAPI, registry, store]);
  const findClosestDraggableId = useCallback29((event) => tryGetClosestDraggableIdFromEvent(contextId, event), [contextId]);
  const findOptionsForDraggable = useCallback29((id) => {
    const entry = registry.draggable.findById(id);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  const tryReleaseLock = useCallback29(function tryReleaseLock2() {
    if (!lockAPI.isClaimed()) {
      return;
    }
    lockAPI.tryAbandon();
    if (store.getState().phase !== "IDLE") {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  const isLockClaimed = useCallback29(() => lockAPI.isClaimed(), [lockAPI]);
  const api = useMemo17(() => ({
    canGetLock,
    tryGetLock,
    findClosestDraggableId,
    findOptionsForDraggable,
    tryReleaseLock,
    isLockClaimed
  }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  useValidateSensorHooks(useSensors);
  for (let i = 0; i < useSensors.length; i++) {
    useSensors[i](api);
  }
}
var createResponders = (props2) => ({
  onBeforeCapture: (t2) => {
    const onBeforeCapureCallback = () => {
      if (props2.onBeforeCapture) {
        props2.onBeforeCapture(t2);
      }
    };
    (0, import_react_dom4.flushSync)(onBeforeCapureCallback);
  },
  onBeforeDragStart: props2.onBeforeDragStart,
  onDragStart: props2.onDragStart,
  onDragEnd: props2.onDragEnd,
  onDragUpdate: props2.onDragUpdate
});
var createAutoScrollerOptions = (props2) => __spreadProps(__spreadValues(__spreadValues({}, defaultAutoScrollerOptions), props2.autoScrollerOptions), {
  durationDampening: __spreadValues(__spreadValues({}, defaultAutoScrollerOptions.durationDampening), props2.autoScrollerOptions)
});
function getStore(lazyRef) {
  !lazyRef.current ? process.env.NODE_ENV !== "production" ? invariant2(false, "Could not find store from lazy ref") : invariant2() : void 0;
  return lazyRef.current;
}
function App(props2) {
  const {
    contextId,
    setCallbacks,
    sensors,
    nonce: nonce2,
    dragHandleUsageInstructions: dragHandleUsageInstructions2
  } = props2;
  const lazyStoreRef = (0, import_react42.useRef)(null);
  useStartupValidation();
  const lastPropsRef = usePrevious2(props2);
  const getResponders = useCallback29(() => {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  const getAutoScrollerOptions = useCallback29(() => {
    return createAutoScrollerOptions(lastPropsRef.current);
  }, [lastPropsRef]);
  const announce = useAnnouncer(contextId);
  const dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions2
  });
  const styleMarshal = useStyleMarshal(contextId, nonce2);
  const lazyDispatch = useCallback29((action) => {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  const marshalCallbacks = useMemo17(() => bindActionCreators({
    publishWhileDragging,
    updateDroppableScroll,
    updateDroppableIsEnabled,
    updateDroppableIsCombineEnabled,
    collectionStarting
  }, lazyDispatch), [lazyDispatch]);
  const registry = useRegistry();
  const dimensionMarshal = useMemo17(() => {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  const autoScroller = useMemo17(() => createAutoScroller(__spreadValues({
    scrollWindow,
    scrollDroppable: dimensionMarshal.scrollDroppable,
    getAutoScrollerOptions
  }, bindActionCreators({
    move
  }, lazyDispatch))), [dimensionMarshal.scrollDroppable, lazyDispatch, getAutoScrollerOptions]);
  const focusMarshal = useFocusMarshal(contextId);
  const store = useMemo17(() => createStore2({
    announce,
    autoScroller,
    dimensionMarshal,
    focusMarshal,
    getResponders,
    styleMarshal
  }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
  if (process.env.NODE_ENV !== "production") {
    if (lazyStoreRef.current && lazyStoreRef.current !== store) {
      process.env.NODE_ENV !== "production" ? warning2("unexpected store change") : void 0;
    }
  }
  lazyStoreRef.current = store;
  const tryResetStore = useCallback29(() => {
    const current = getStore(lazyStoreRef);
    const state = current.getState();
    if (state.phase !== "IDLE") {
      current.dispatch(flush());
    }
  }, []);
  const isDragging2 = useCallback29(() => {
    const state = getStore(lazyStoreRef).getState();
    if (state.phase === "DROP_ANIMATING") {
      return true;
    }
    if (state.phase === "IDLE") {
      return false;
    }
    return state.isDragging;
  }, []);
  const appCallbacks = useMemo17(() => ({
    isDragging: isDragging2,
    tryAbort: tryResetStore
  }), [isDragging2, tryResetStore]);
  setCallbacks(appCallbacks);
  const getCanLift = useCallback29((id) => canStartDrag(getStore(lazyStoreRef).getState(), id), []);
  const getIsMovementAllowed = useCallback29(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);
  const appContext = useMemo17(() => ({
    marshal: dimensionMarshal,
    focus: focusMarshal,
    contextId,
    canLift: getCanLift,
    isMovementAllowed: getIsMovementAllowed,
    dragHandleUsageInstructionsId,
    registry
  }), [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors || null,
    enableDefaultSensors: props2.enableDefaultSensors !== false
  });
  (0, import_react42.useEffect)(() => {
    return tryResetStore;
  }, [tryResetStore]);
  return import_react42.default.createElement(AppContext.Provider, {
    value: appContext
  }, import_react42.default.createElement(Provider_default, {
    context: StoreContext,
    store
  }, props2.children));
}
function useUniqueContextId() {
  return import_react42.default.useId();
}
function DragDropContext(props2) {
  const contextId = useUniqueContextId();
  const dragHandleUsageInstructions2 = props2.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return import_react42.default.createElement(ErrorBoundary, null, (setCallbacks) => import_react42.default.createElement(App, {
    nonce: props2.nonce,
    contextId,
    setCallbacks,
    dragHandleUsageInstructions: dragHandleUsageInstructions2,
    enableDefaultSensors: props2.enableDefaultSensors,
    sensors: props2.sensors,
    onBeforeCapture: props2.onBeforeCapture,
    onBeforeDragStart: props2.onBeforeDragStart,
    onDragStart: props2.onDragStart,
    onDragUpdate: props2.onDragUpdate,
    onDragEnd: props2.onDragEnd,
    autoScrollerOptions: props2.autoScrollerOptions
  }, props2.children));
}
var zIndexOptions = {
  dragging: 5e3,
  dropAnimating: 4500
};
var getDraggingTransition = (shouldAnimateDragMovement, dropping) => {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }
  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }
  return transitions.fluid;
};
var getDraggingOpacity = (isCombining, isDropAnimating) => {
  if (!isCombining) {
    return void 0;
  }
  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};
var getShouldDraggingAnimate = (dragging) => {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }
  return dragging.mode === "SNAP";
};
function getDraggingStyle(dragging) {
  const dimension = dragging.dimension;
  const box = dimension.client;
  const {
    offset: offset6,
    combineWith,
    dropping
  } = dragging;
  const isCombining = Boolean(combineWith);
  const shouldAnimate = getShouldDraggingAnimate(dragging);
  const isDropAnimating = Boolean(dropping);
  const transform = isDropAnimating ? transforms.drop(offset6, isCombining) : transforms.moveTo(offset6);
  const style2 = {
    position: "fixed",
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: "border-box",
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: "none"
  };
  return style2;
}
function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? void 0 : "none"
  };
}
function getStyle$1(mapped) {
  return mapped.type === "DRAGGING" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}
function getDimension$1(descriptor, el, windowScroll = origin) {
  const computedStyles = window.getComputedStyle(el);
  const borderBox = el.getBoundingClientRect();
  const client = calculateBox(borderBox, computedStyles);
  const page = withScroll(client, windowScroll);
  const placeholder2 = {
    client,
    tagName: el.tagName.toLowerCase(),
    display: computedStyles.display
  };
  const displaceBy = {
    x: client.marginBox.width,
    y: client.marginBox.height
  };
  const dimension = {
    descriptor,
    placeholder: placeholder2,
    displaceBy,
    client,
    page
  };
  return dimension;
}
function useDraggablePublisher(args) {
  const uniqueId = useUniqueId("draggable");
  const {
    descriptor,
    registry,
    getDraggableRef,
    canDragInteractiveElements,
    shouldRespectForcePress,
    isEnabled
  } = args;
  const options = useMemo17(() => ({
    canDragInteractiveElements,
    shouldRespectForcePress,
    isEnabled
  }), [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
  const getDimension2 = useCallback29((windowScroll) => {
    const el = getDraggableRef();
    !el ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot get dimension when no ref is set") : invariant2() : void 0;
    return getDimension$1(descriptor, el, windowScroll);
  }, [descriptor, getDraggableRef]);
  const entry = useMemo17(() => ({
    uniqueId,
    descriptor,
    options,
    getDimension: getDimension2
  }), [descriptor, getDimension2, options, uniqueId]);
  const publishedRef = (0, import_react42.useRef)(entry);
  const isFirstPublishRef = (0, import_react42.useRef)(true);
  useIsomorphicLayoutEffect5(() => {
    registry.draggable.register(publishedRef.current);
    return () => registry.draggable.unregister(publishedRef.current);
  }, [registry.draggable]);
  useIsomorphicLayoutEffect5(() => {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }
    const last = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last);
  }, [entry, registry.draggable]);
}
var DroppableContext = import_react42.default.createContext(null);
function checkIsValidInnerRef(el) {
  !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== "production" ? invariant2(false, `
    provided.innerRef has not been provided with a HTMLElement.

    You can find a guide on using the innerRef callback functions at:
    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md
  `) : invariant2() : void 0;
}
function useValidation$1(props2, contextId, getRef) {
  useDevSetupWarning(() => {
    function prefix3(id2) {
      return `Draggable[id: ${id2}]: `;
    }
    const id = props2.draggableId;
    !id ? process.env.NODE_ENV !== "production" ? invariant2(false, "Draggable requires a draggableId") : invariant2(false) : void 0;
    !(typeof id === "string") ? process.env.NODE_ENV !== "production" ? invariant2(false, `Draggable requires a [string] draggableId.
      Provided: [type: ${typeof id}] (value: ${id})`) : invariant2(false) : void 0;
    !Number.isInteger(props2.index) ? process.env.NODE_ENV !== "production" ? invariant2(false, `${prefix3(id)} requires an integer index prop`) : invariant2(false) : void 0;
    if (props2.mapped.type === "DRAGGING") {
      return;
    }
    checkIsValidInnerRef(getRef());
    if (props2.isEnabled) {
      !findDragHandle(contextId, id) ? process.env.NODE_ENV !== "production" ? invariant2(false, `${prefix3(id)} Unable to find drag handle`) : invariant2(false) : void 0;
    }
  });
}
function useClonePropValidation(isClone) {
  useDev(() => {
    const initialRef = (0, import_react42.useRef)(isClone);
    useDevSetupWarning(() => {
      !(isClone === initialRef.current) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Draggable isClone prop value changed during component life") : invariant2(false) : void 0;
    }, [isClone]);
  });
}
function useRequiredContext(Context) {
  const result = (0, import_react42.useContext)(Context);
  !result ? process.env.NODE_ENV !== "production" ? invariant2(false, "Could not find required context") : invariant2() : void 0;
  return result;
}
function preventHtml5Dnd(event) {
  event.preventDefault();
}
var Draggable = (props2) => {
  const ref2 = (0, import_react42.useRef)(null);
  const setRef4 = useCallback29((el = null) => {
    ref2.current = el;
  }, []);
  const getRef = useCallback29(() => ref2.current, []);
  const {
    contextId,
    dragHandleUsageInstructionsId,
    registry
  } = useRequiredContext(AppContext);
  const {
    type,
    droppableId
  } = useRequiredContext(DroppableContext);
  const descriptor = useMemo17(() => ({
    id: props2.draggableId,
    index: props2.index,
    type,
    droppableId
  }), [props2.draggableId, props2.index, type, droppableId]);
  const {
    children,
    draggableId,
    isEnabled,
    shouldRespectForcePress,
    canDragInteractiveElements,
    isClone,
    mapped,
    dropAnimationFinished: dropAnimationFinishedAction
  } = props2;
  useValidation$1(props2, contextId, getRef);
  useClonePropValidation(isClone);
  if (!isClone) {
    const forPublisher = useMemo17(() => ({
      descriptor,
      registry,
      getDraggableRef: getRef,
      canDragInteractiveElements,
      shouldRespectForcePress,
      isEnabled
    }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
    useDraggablePublisher(forPublisher);
  }
  const dragHandleProps = useMemo17(() => isEnabled ? {
    tabIndex: 0,
    role: "button",
    "aria-describedby": dragHandleUsageInstructionsId,
    "data-rfd-drag-handle-draggable-id": draggableId,
    "data-rfd-drag-handle-context-id": contextId,
    draggable: false,
    onDragStart: preventHtml5Dnd
  } : null, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
  const onMoveEnd = useCallback29((event) => {
    if (mapped.type !== "DRAGGING") {
      return;
    }
    if (!mapped.dropping) {
      return;
    }
    if (event.propertyName !== "transform") {
      return;
    }
    (0, import_react_dom4.flushSync)(dropAnimationFinishedAction);
  }, [dropAnimationFinishedAction, mapped]);
  const provided = useMemo17(() => {
    const style2 = getStyle$1(mapped);
    const onTransitionEnd = mapped.type === "DRAGGING" && mapped.dropping ? onMoveEnd : void 0;
    const result = {
      innerRef: setRef4,
      draggableProps: {
        "data-rfd-draggable-context-id": contextId,
        "data-rfd-draggable-id": draggableId,
        style: style2,
        onTransitionEnd
      },
      dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef4]);
  const rubric = useMemo17(() => ({
    draggableId: descriptor.id,
    type: descriptor.type,
    source: {
      index: descriptor.index,
      droppableId: descriptor.droppableId
    }
  }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return import_react42.default.createElement(import_react42.default.Fragment, null, children(provided, mapped.snapshot, rubric));
};
var isStrictEqual = (a, b) => a === b;
var whatIsDraggedOverFromResult = (result) => {
  const {
    combine: combine2,
    destination
  } = result;
  if (destination) {
    return destination.droppableId;
  }
  if (combine2) {
    return combine2.droppableId;
  }
  return null;
};
var getCombineWithFromResult = (result) => {
  return result.combine ? result.combine.draggableId : null;
};
var getCombineWithFromImpact = (impact) => {
  return impact.at && impact.at.type === "COMBINE" ? impact.at.combine.draggableId : null;
};
function getDraggableSelector() {
  const memoizedOffset = memoizeOne((x2, y) => ({
    x: x2,
    y
  }));
  const getMemoizedSnapshot = memoizeOne((mode, isClone, draggingOver = null, combineWith = null, dropping = null) => ({
    isDragging: true,
    isClone,
    isDropAnimating: Boolean(dropping),
    dropAnimation: dropping,
    mode,
    draggingOver,
    combineWith,
    combineTargetFor: null
  }));
  const getMemoizedProps = memoizeOne((offset6, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null) => ({
    mapped: {
      type: "DRAGGING",
      dropping: null,
      draggingOver,
      combineWith,
      mode,
      offset: offset6,
      dimension,
      forceShouldAnimate,
      snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
    }
  }));
  const selector = (state, ownProps) => {
    if (isDragging(state)) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }
      const offset6 = state.current.client.offset;
      const dimension = state.dimensions.draggables[ownProps.draggableId];
      const draggingOver = whatIsDraggedOver(state.impact);
      const combineWith = getCombineWithFromImpact(state.impact);
      const forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset6.x, offset6.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }
      const isClone = ownProps.isClone;
      const dimension = state.dimensions.draggables[ownProps.draggableId];
      const result = completed.result;
      const mode = result.mode;
      const draggingOver = whatIsDraggedOverFromResult(result);
      const combineWith = getCombineWithFromResult(result);
      const duration = state.dropDuration;
      const dropping = {
        duration,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: combineWith ? combine.opacity.drop : null,
        scale: combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: state.newHomeClientOffset,
          dimension,
          dropping,
          draggingOver,
          combineWith,
          mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)
        }
      };
    }
    return null;
  };
  return selector;
}
function getSecondarySnapshot(combineTargetFor = null) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor,
    combineWith: null
  };
}
var atRest = {
  mapped: {
    type: "SECONDARY",
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};
function getSecondarySelector() {
  const memoizedOffset = memoizeOne((x2, y) => ({
    x: x2,
    y
  }));
  const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
  const getMemoizedProps = memoizeOne((offset6, combineTargetFor = null, shouldAnimateDisplacement) => ({
    mapped: {
      type: "SECONDARY",
      offset: offset6,
      combineTargetFor,
      shouldAnimateDisplacement,
      snapshot: getMemoizedSnapshot(combineTargetFor)
    }
  }));
  const getFallback = (combineTargetFor) => {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };
  const getProps = (ownId, draggingId, impact, afterCritical) => {
    const visualDisplacement = impact.displaced.visible[ownId];
    const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    const combine2 = tryGetCombine(impact);
    const combineTargetFor = combine2 && combine2.draggableId === ownId ? draggingId : null;
    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }
      if (impact.displaced.invisible[ownId]) {
        return null;
      }
      const change = negate(afterCritical.displacedBy.point);
      const offset7 = memoizedOffset(change.x, change.y);
      return getMemoizedProps(offset7, combineTargetFor, true);
    }
    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }
    const displaceBy = impact.displacedBy.point;
    const offset6 = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset6, combineTargetFor, visualDisplacement.shouldAnimate);
  };
  const selector = (state, ownProps) => {
    if (isDragging(state)) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }
    return null;
  };
  return selector;
}
var makeMapStateToProps$1 = () => {
  const draggingSelector = getDraggableSelector();
  const secondarySelector = getSecondarySelector();
  const selector = (state, ownProps) => draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  return selector;
};
var mapDispatchToProps$1 = {
  dropAnimationFinished
};
var ConnectedDraggable = connect_default(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  areStatePropsEqual: isStrictEqual
})(Draggable);
function PrivateDraggable(props2) {
  const droppableContext = useRequiredContext(DroppableContext);
  const isUsingCloneFor = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props2.draggableId && !props2.isClone) {
    return null;
  }
  return import_react42.default.createElement(ConnectedDraggable, props2);
}
function PublicDraggable(props2) {
  const isEnabled = typeof props2.isDragDisabled === "boolean" ? !props2.isDragDisabled : true;
  const canDragInteractiveElements = Boolean(props2.disableInteractiveElementBlocking);
  const shouldRespectForcePress = Boolean(props2.shouldRespectForcePress);
  return import_react42.default.createElement(PrivateDraggable, _extends({}, props2, {
    isClone: false,
    isEnabled,
    canDragInteractiveElements,
    shouldRespectForcePress
  }));
}
var isEqual = (base) => (value) => base === value;
var isScroll = isEqual("scroll");
var isAuto = isEqual("auto");
var isVisible = isEqual("visible");
var isEither = (overflow, fn) => fn(overflow.overflowX) || fn(overflow.overflowY);
var isBoth = (overflow, fn) => fn(overflow.overflowX) && fn(overflow.overflowY);
var isElementScrollable = (el) => {
  const style2 = window.getComputedStyle(el);
  const overflow = {
    overflowX: style2.overflowX,
    overflowY: style2.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};
var isBodyScrollable = () => {
  if (process.env.NODE_ENV === "production") {
    return false;
  }
  const body = getBodyElement();
  const html = document.documentElement;
  !html ? process.env.NODE_ENV !== "production" ? invariant2() : invariant2() : void 0;
  if (!isElementScrollable(body)) {
    return false;
  }
  const htmlStyle = window.getComputedStyle(html);
  const htmlOverflow = {
    overflowX: htmlStyle.overflowX,
    overflowY: htmlStyle.overflowY
  };
  if (isBoth(htmlOverflow, isVisible)) {
    return false;
  }
  process.env.NODE_ENV !== "production" ? warning2(`
    We have detected that your <body> element might be a scroll container.
    We have found no reliable way of detecting whether the <body> element is a scroll container.
    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)

    Because we cannot determine if the <body> is a scroll container, and generally it is not one,
    we will be treating the <body> as *not* a scroll container

    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md
  `) : void 0;
  return false;
};
var getClosestScrollable = (el) => {
  if (el == null) {
    return null;
  }
  if (el === document.body) {
    return isBodyScrollable() ? el : null;
  }
  if (el === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el)) {
    return getClosestScrollable(el.parentElement);
  }
  return el;
};
var checkForNestedScrollContainers = (scrollable) => {
  if (!scrollable) {
    return;
  }
  const anotherScrollParent = getClosestScrollable(scrollable.parentElement);
  if (!anotherScrollParent) {
    return;
  }
  process.env.NODE_ENV !== "production" ? warning2(`
    Droppable: unsupported nested scroll container detected.
    A Droppable can only have one scroll parent (which can be itself)
    Nested scroll containers are currently not supported.

    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131
  `) : void 0;
};
var getScroll = (el) => ({
  x: el.scrollLeft,
  y: el.scrollTop
});
var getIsFixed = (el) => {
  if (!el) {
    return false;
  }
  const style2 = window.getComputedStyle(el);
  if (style2.position === "fixed") {
    return true;
  }
  return getIsFixed(el.parentElement);
};
var getEnv = (start2) => {
  const closestScrollable = getClosestScrollable(start2);
  const isFixedOnPage = getIsFixed(start2);
  return {
    closestScrollable,
    isFixedOnPage
  };
};
var getDroppableDimension = ({
  descriptor,
  isEnabled,
  isCombineEnabled,
  isFixedOnPage,
  direction,
  client,
  page,
  closest: closest2
}) => {
  const frame = (() => {
    if (!closest2) {
      return null;
    }
    const {
      scrollSize,
      client: frameClient
    } = closest2;
    const maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest2.page.marginBox,
      frameClient,
      scrollSize,
      shouldClipSubject: closest2.shouldClipSubject,
      scroll: {
        initial: closest2.scroll,
        current: closest2.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  })();
  const axis = direction === "vertical" ? vertical : horizontal;
  const subject = getSubject({
    page,
    withPlaceholder: null,
    axis,
    frame
  });
  const dimension = {
    descriptor,
    isCombineEnabled,
    isFixedOnPage,
    axis,
    isEnabled,
    client,
    page,
    frame,
    subject
  };
  return dimension;
};
var getClient = (targetRef, closestScrollable) => {
  const base = getBox(targetRef);
  if (!closestScrollable) {
    return base;
  }
  if (targetRef !== closestScrollable) {
    return base;
  }
  const top = base.paddingBox.top - closestScrollable.scrollTop;
  const left = base.paddingBox.left - closestScrollable.scrollLeft;
  const bottom = top + closestScrollable.scrollHeight;
  const right = left + closestScrollable.scrollWidth;
  const paddingBox = {
    top,
    right,
    bottom,
    left
  };
  const borderBox = expand(paddingBox, base.border);
  const client = createBox({
    borderBox,
    margin: base.margin,
    border: base.border,
    padding: base.padding
  });
  return client;
};
var getDimension = ({
  ref: ref2,
  descriptor,
  env,
  windowScroll,
  direction,
  isDropDisabled,
  isCombineEnabled,
  shouldClipSubject
}) => {
  const closestScrollable = env.closestScrollable;
  const client = getClient(ref2, closestScrollable);
  const page = withScroll(client, windowScroll);
  const closest2 = (() => {
    if (!closestScrollable) {
      return null;
    }
    const frameClient = getBox(closestScrollable);
    const scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: withScroll(frameClient, windowScroll),
      scroll: getScroll(closestScrollable),
      scrollSize,
      shouldClipSubject
    };
  })();
  const dimension = getDroppableDimension({
    descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled,
    isFixedOnPage: env.isFixedOnPage,
    direction,
    client,
    page,
    closest: closest2
  });
  return dimension;
};
var immediate = {
  passive: false
};
var delayed = {
  passive: true
};
var getListenerOptions = (options) => options.shouldPublishImmediately ? immediate : delayed;
var getClosestScrollableFromDrag = (dragging) => dragging && dragging.env.closestScrollable || null;
function useDroppablePublisher(args) {
  const whileDraggingRef = (0, import_react42.useRef)(null);
  const appContext = useRequiredContext(AppContext);
  const uniqueId = useUniqueId("droppable");
  const {
    registry,
    marshal
  } = appContext;
  const previousRef = usePrevious2(args);
  const descriptor = useMemo17(() => ({
    id: args.droppableId,
    type: args.type,
    mode: args.mode
  }), [args.droppableId, args.mode, args.type]);
  const publishedDescriptorRef = (0, import_react42.useRef)(descriptor);
  const memoizedUpdateScroll = useMemo17(() => memoizeOne((x2, y) => {
    !whileDraggingRef.current ? process.env.NODE_ENV !== "production" ? invariant2(false, "Can only update scroll when dragging") : invariant2() : void 0;
    const scroll3 = {
      x: x2,
      y
    };
    marshal.updateDroppableScroll(descriptor.id, scroll3);
  }), [descriptor.id, marshal]);
  const getClosestScroll = useCallback29(() => {
    const dragging = whileDraggingRef.current;
    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }
    return getScroll(dragging.env.closestScrollable);
  }, []);
  const updateScroll = useCallback29(() => {
    const scroll3 = getClosestScroll();
    memoizedUpdateScroll(scroll3.x, scroll3.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  const scheduleScrollUpdate = useMemo17(() => raf_schd_esm_default(updateScroll), [updateScroll]);
  const onClosestScroll = useCallback29(() => {
    const dragging = whileDraggingRef.current;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest2) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Could not find scroll options while scrolling") : invariant2() : void 0;
    const options = dragging.scrollOptions;
    if (options.shouldPublishImmediately) {
      updateScroll();
      return;
    }
    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  const getDimensionAndWatchScroll = useCallback29((windowScroll, options) => {
    !!whileDraggingRef.current ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot collect a droppable while a drag is occurring") : invariant2() : void 0;
    const previous = previousRef.current;
    const ref2 = previous.getDroppableRef();
    !ref2 ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot collect without a droppable ref") : invariant2() : void 0;
    const env = getEnv(ref2);
    const dragging = {
      ref: ref2,
      descriptor,
      env,
      scrollOptions: options
    };
    whileDraggingRef.current = dragging;
    const dimension = getDimension({
      ref: ref2,
      descriptor,
      env,
      windowScroll,
      direction: previous.direction,
      isDropDisabled: previous.isDropDisabled,
      isCombineEnabled: previous.isCombineEnabled,
      shouldClipSubject: !previous.ignoreContainerClipping
    });
    const scrollable = env.closestScrollable;
    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
      if (process.env.NODE_ENV !== "production") {
        checkForNestedScrollContainers(scrollable);
      }
    }
    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  const getScrollWhileDragging = useCallback29(() => {
    const dragging = whileDraggingRef.current;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest2) ? process.env.NODE_ENV !== "production" ? invariant2(false, "Can only recollect Droppable client for Droppables that have a scroll container") : invariant2() : void 0;
    return getScroll(closest2);
  }, []);
  const dragStopped = useCallback29(() => {
    const dragging = whileDraggingRef.current;
    !dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot stop drag when no active drag") : invariant2() : void 0;
    const closest2 = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;
    if (!closest2) {
      return;
    }
    scheduleScrollUpdate.cancel();
    closest2.removeAttribute(scrollContainer.contextId);
    closest2.removeEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  const scroll2 = useCallback29((change) => {
    const dragging = whileDraggingRef.current;
    !dragging ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot scroll when there is no drag") : invariant2() : void 0;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !closest2 ? process.env.NODE_ENV !== "production" ? invariant2(false, "Cannot scroll a droppable with no closest scrollable") : invariant2() : void 0;
    closest2.scrollTop += change.y;
    closest2.scrollLeft += change.x;
  }, []);
  const callbacks = useMemo17(() => {
    return {
      getDimensionAndWatchScroll,
      getScrollWhileDragging,
      dragStopped,
      scroll: scroll2
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll2]);
  const entry = useMemo17(() => ({
    uniqueId,
    descriptor,
    callbacks
  }), [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect5(() => {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return () => {
      if (whileDraggingRef.current) {
        process.env.NODE_ENV !== "production" ? warning2("Unsupported: changing the droppableId or type of a Droppable during a drag") : void 0;
        dragStopped();
      }
      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect5(() => {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect5(() => {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}
function noop2() {
}
var empty = {
  width: 0,
  height: 0,
  margin: noSpacing2
};
var getSize = ({
  isAnimatingOpenOnMount,
  placeholder: placeholder2,
  animate
}) => {
  if (isAnimatingOpenOnMount) {
    return empty;
  }
  if (animate === "close") {
    return empty;
  }
  return {
    height: placeholder2.client.borderBox.height,
    width: placeholder2.client.borderBox.width,
    margin: placeholder2.client.margin
  };
};
var getStyle = ({
  isAnimatingOpenOnMount,
  placeholder: placeholder2,
  animate
}) => {
  const size4 = getSize({
    isAnimatingOpenOnMount,
    placeholder: placeholder2,
    animate
  });
  return {
    display: placeholder2.display,
    boxSizing: "border-box",
    width: size4.width,
    height: size4.height,
    marginTop: size4.margin.top,
    marginRight: size4.margin.right,
    marginBottom: size4.margin.bottom,
    marginLeft: size4.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: animate !== "none" ? transitions.placeholder : null
  };
};
var Placeholder = (props2) => {
  const animateOpenTimerRef = (0, import_react42.useRef)(null);
  const tryClearAnimateOpenTimer = useCallback29(() => {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  const {
    animate,
    onTransitionEnd,
    onClose,
    contextId
  } = props2;
  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0, import_react42.useState)(props2.animate === "open");
  (0, import_react42.useEffect)(() => {
    if (!isAnimatingOpenOnMount) {
      return noop2;
    }
    if (animate !== "open") {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop2;
    }
    if (animateOpenTimerRef.current) {
      return noop2;
    }
    animateOpenTimerRef.current = setTimeout(() => {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  const onSizeChangeEnd = useCallback29((event) => {
    if (event.propertyName !== "height") {
      return;
    }
    onTransitionEnd();
    if (animate === "close") {
      onClose();
    }
  }, [animate, onClose, onTransitionEnd]);
  const style2 = getStyle({
    isAnimatingOpenOnMount,
    animate: props2.animate,
    placeholder: props2.placeholder
  });
  return import_react42.default.createElement(props2.placeholder.tagName, {
    style: style2,
    "data-rfd-placeholder-context-id": contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props2.innerRef
  });
};
var Placeholder$1 = import_react42.default.memo(Placeholder);
function isBoolean3(value) {
  return typeof value === "boolean";
}
function runChecks(args, checks) {
  checks.forEach((check) => check(args));
}
var shared = [function required({
  props: props2
}) {
  !props2.droppableId ? process.env.NODE_ENV !== "production" ? invariant2(false, "A Droppable requires a droppableId prop") : invariant2() : void 0;
  !(typeof props2.droppableId === "string") ? process.env.NODE_ENV !== "production" ? invariant2(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props2.droppableId}]`) : invariant2() : void 0;
}, function boolean({
  props: props2
}) {
  !isBoolean3(props2.isDropDisabled) ? process.env.NODE_ENV !== "production" ? invariant2(false, "isDropDisabled must be a boolean") : invariant2() : void 0;
  !isBoolean3(props2.isCombineEnabled) ? process.env.NODE_ENV !== "production" ? invariant2(false, "isCombineEnabled must be a boolean") : invariant2() : void 0;
  !isBoolean3(props2.ignoreContainerClipping) ? process.env.NODE_ENV !== "production" ? invariant2(false, "ignoreContainerClipping must be a boolean") : invariant2() : void 0;
}, function ref({
  getDroppableRef
}) {
  checkIsValidInnerRef(getDroppableRef());
}];
var standard = [function placeholder({
  props: props2,
  getPlaceholderRef
}) {
  if (!props2.placeholder) {
    return;
  }
  const ref2 = getPlaceholderRef();
  if (ref2) {
    return;
  }
  process.env.NODE_ENV !== "production" ? warning2(`
      Droppable setup issue [droppableId: "${props2.droppableId}"]:
      DroppableProvided > placeholder could not be found.

      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.
      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md
    `) : void 0;
}];
var virtual = [function hasClone({
  props: props2
}) {
  !props2.renderClone ? process.env.NODE_ENV !== "production" ? invariant2(false, "Must provide a clone render function (renderClone) for virtual lists") : invariant2() : void 0;
}, function hasNoPlaceholder({
  getPlaceholderRef
}) {
  !!getPlaceholderRef() ? process.env.NODE_ENV !== "production" ? invariant2(false, "Expected virtual list to not have a placeholder") : invariant2() : void 0;
}];
function useValidation(args) {
  useDevSetupWarning(() => {
    runChecks(args, shared);
    if (args.props.mode === "standard") {
      runChecks(args, standard);
    }
    if (args.props.mode === "virtual") {
      runChecks(args, virtual);
    }
  });
}
var AnimateInOut = class extends import_react42.default.PureComponent {
  constructor(...args) {
    super(...args);
    this.state = {
      isVisible: Boolean(this.props.on),
      data: this.props.on,
      animate: this.props.shouldAnimate && this.props.on ? "open" : "none"
    };
    this.onClose = () => {
      if (this.state.animate !== "close") {
        return;
      }
      this.setState({
        isVisible: false
      });
    };
  }
  static getDerivedStateFromProps(props2, state) {
    if (!props2.shouldAnimate) {
      return {
        isVisible: Boolean(props2.on),
        data: props2.on,
        animate: "none"
      };
    }
    if (props2.on) {
      return {
        isVisible: true,
        data: props2.on,
        animate: "open"
      };
    }
    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: "close"
      };
    }
    return {
      isVisible: false,
      animate: "close",
      data: null
    };
  }
  render() {
    if (!this.state.isVisible) {
      return null;
    }
    const provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  }
};
var Droppable = (props2) => {
  const appContext = (0, import_react42.useContext)(AppContext);
  !appContext ? process.env.NODE_ENV !== "production" ? invariant2(false, "Could not find app context") : invariant2() : void 0;
  const {
    contextId,
    isMovementAllowed: isMovementAllowed2
  } = appContext;
  const droppableRef = (0, import_react42.useRef)(null);
  const placeholderRef = (0, import_react42.useRef)(null);
  const {
    children,
    droppableId,
    type,
    mode,
    direction,
    ignoreContainerClipping,
    isDropDisabled,
    isCombineEnabled,
    snapshot,
    useClone,
    updateViewportMaxScroll: updateViewportMaxScroll2,
    getContainerForClone
  } = props2;
  const getDroppableRef = useCallback29(() => droppableRef.current, []);
  const setDroppableRef = useCallback29((value = null) => {
    droppableRef.current = value;
  }, []);
  const getPlaceholderRef = useCallback29(() => placeholderRef.current, []);
  const setPlaceholderRef = useCallback29((value = null) => {
    placeholderRef.current = value;
  }, []);
  useValidation({
    props: props2,
    getDroppableRef,
    getPlaceholderRef
  });
  const onPlaceholderTransitionEnd = useCallback29(() => {
    if (isMovementAllowed2()) {
      updateViewportMaxScroll2({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed2, updateViewportMaxScroll2]);
  useDroppablePublisher({
    droppableId,
    type,
    mode,
    direction,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef
  });
  const placeholder2 = useMemo17(() => import_react42.default.createElement(AnimateInOut, {
    on: props2.placeholder,
    shouldAnimate: props2.shouldAnimatePlaceholder
  }, ({
    onClose,
    data,
    animate
  }) => import_react42.default.createElement(Placeholder$1, {
    placeholder: data,
    onClose,
    innerRef: setPlaceholderRef,
    animate,
    contextId,
    onTransitionEnd: onPlaceholderTransitionEnd
  })), [contextId, onPlaceholderTransitionEnd, props2.placeholder, props2.shouldAnimatePlaceholder, setPlaceholderRef]);
  const provided = useMemo17(() => ({
    innerRef: setDroppableRef,
    placeholder: placeholder2,
    droppableProps: {
      "data-rfd-droppable-id": droppableId,
      "data-rfd-droppable-context-id": contextId
    }
  }), [contextId, droppableId, placeholder2, setDroppableRef]);
  const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  const droppableContext = useMemo17(() => ({
    droppableId,
    type,
    isUsingCloneFor
  }), [droppableId, isUsingCloneFor, type]);
  function getClone() {
    if (!useClone) {
      return null;
    }
    const {
      dragging,
      render
    } = useClone;
    const node = import_react42.default.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, (draggableProvided, draggableSnapshot) => render(draggableProvided, draggableSnapshot, dragging));
    return import_react_dom4.default.createPortal(node, getContainerForClone());
  }
  return import_react42.default.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
};
function getBody() {
  !document.body ? process.env.NODE_ENV !== "production" ? invariant2(false, "document.body is not ready") : invariant2() : void 0;
  return document.body;
}
var defaultProps = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
var attachDefaultPropsToOwnProps = (ownProps) => {
  let mergedProps = __spreadValues({}, ownProps);
  let defaultPropKey;
  for (defaultPropKey in defaultProps) {
    if (ownProps[defaultPropKey] === void 0) {
      mergedProps = __spreadProps(__spreadValues({}, mergedProps), {
        [defaultPropKey]: defaultProps[defaultPropKey]
      });
    }
  }
  return mergedProps;
};
var isMatchingType = (type, critical) => type === critical.droppable.type;
var getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];
var makeMapStateToProps = () => {
  const idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };
  const idleWithoutAnimation = __spreadProps(__spreadValues({}, idleWithAnimation), {
    shouldAnimatePlaceholder: false
  });
  const getDraggableRubric = memoizeOne((descriptor) => ({
    draggableId: descriptor.id,
    type: descriptor.type,
    source: {
      index: descriptor.index,
      droppableId: descriptor.droppableId
    }
  }));
  const getMapProps = memoizeOne((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {
    const draggableId = dragging.descriptor.id;
    const isHome = dragging.descriptor.droppableId === id;
    if (isHome) {
      const useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      const snapshot2 = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: snapshot2,
        useClone
      };
    }
    if (!isEnabled) {
      return idleWithoutAnimation;
    }
    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }
    const snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot,
      useClone: null
    };
  });
  const selector = (state, ownProps) => {
    const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);
    const id = ownPropsWithDefaultProps.droppableId;
    const type = ownPropsWithDefaultProps.type;
    const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;
    const renderClone = ownPropsWithDefaultProps.renderClone;
    if (isDragging(state)) {
      const critical = state.critical;
      if (!isMatchingType(type, critical)) {
        return idleWithoutAnimation;
      }
      const dragging = getDraggable(critical, state.dimensions);
      const isDraggingOver = whatIsDraggedOver(state.impact) === id;
      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      const dragging = getDraggable(completed.critical, state.dimensions);
      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);
    }
    if (state.phase === "IDLE" && state.completed && !state.shouldFlush) {
      const completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      const wasOver = whatIsDraggedOver(completed.impact) === id;
      const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === "COMBINE");
      const isHome = completed.critical.droppable.id === id;
      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }
      if (isHome) {
        return idleWithAnimation;
      }
      return idleWithoutAnimation;
    }
    return idleWithoutAnimation;
  };
  return selector;
};
var mapDispatchToProps = {
  updateViewportMaxScroll
};
var ConnectedDroppable = connect_default(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps) => {
  return __spreadValues(__spreadValues(__spreadValues({}, attachDefaultPropsToOwnProps(ownProps)), stateProps), dispatchProps);
}, {
  context: StoreContext,
  areStatePropsEqual: isStrictEqual
})(Droppable);

// src/components/kanban.tsx
var import_utils33 = require("@nubras/utils");
var import_jsx_runtime59 = require("react/jsx-runtime");
function Kanban({ columns, onColumnAdd, onItemAdd, onDragEnd: onDragEnd2, onItemClick, className }) {
  return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("div", { className: (0, import_utils33.cn)("overflow-x-auto", className), children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(DragDropContext, { onDragEnd: onDragEnd2, children: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)("div", { className: "flex gap-4 p-4", children: [
    columns.map((column) => /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
      KanbanColumnComponent,
      {
        column,
        onItemAdd: onItemAdd ? () => onItemAdd(column.id) : void 0,
        onItemClick
      },
      column.id
    )),
    onColumnAdd && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("div", { className: "flex-shrink-0 w-80", children: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(
      Button,
      {
        variant: "outline",
        className: "h-auto w-full border-dashed p-6 text-muted-foreground",
        onClick: onColumnAdd,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Plus, { className: "mr-2 h-4 w-4" }),
          "Add Column"
        ]
      }
    ) })
  ] }) }) });
}
function KanbanColumnComponent({ column, onItemAdd, onItemClick }) {
  return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("div", { className: "flex-shrink-0 w-80", children: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(Card, { className: "h-full", children: [
    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(CardHeader, { className: "px-4 py-3", children: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(CardTitle, { className: "text-sm font-medium", children: column.title }),
        column.items.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(Badge, { variant: "secondary", className: "rounded-full px-2 py-0.5 text-xs", children: [
          column.items.length,
          column.limit ? `/${column.limit}` : ""
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(DropdownMenu2, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(DropdownMenuTrigger2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(Button, { variant: "ghost", size: "sm", className: "h-8 w-8 p-0", children: [
          /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Ellipsis, { className: "h-4 w-4" }),
          /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("span", { className: "sr-only", children: "Open menu" })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(DropdownMenuContent2, { align: "end", children: [
          /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(DropdownMenuItem2, { children: "Edit Column" }),
          /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(DropdownMenuItem2, { children: "Delete Column" })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(CardContent, { className: "px-4 pb-4 pt-0", children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(ConnectedDroppable, { droppableId: column.id, children: (provided) => /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)("div", __spreadProps(__spreadValues({}, provided.droppableProps), { ref: provided.innerRef, className: "space-y-3 min-h-[200px]", children: [
      column.items.map((item, index2) => /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(PublicDraggable, { draggableId: item.id, index: index2, children: (provided2) => /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
        "div",
        __spreadProps(__spreadValues(__spreadValues({
          ref: provided2.innerRef
        }, provided2.draggableProps), provided2.dragHandleProps), {
          className: "rounded-md border bg-card text-card-foreground shadow-sm",
          onClick: onItemClick ? () => onItemClick(item) : void 0,
          style: __spreadProps(__spreadValues({}, provided2.draggableProps.style), {
            cursor: onItemClick ? "pointer" : "grab"
          }),
          children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("div", { className: "p-3", children: item.content })
        })
      ) }, item.id)),
      provided.placeholder,
      onItemAdd && /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(
        Button,
        {
          variant: "ghost",
          className: "h-auto w-full justify-start p-2 text-muted-foreground",
          onClick: onItemAdd,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Plus, { className: "mr-2 h-4 w-4" }),
            "Add Item"
          ]
        }
      )
    ] })) }) })
  ] }) });
}

// src/components/menubar.tsx
var React116 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-menubar@1.1.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1._3t5df2klndiabxeqenqzp2krzq/node_modules/@radix-ui/react-menubar/dist/index.mjs
var React115 = __toESM(require("react"), 1);
var import_jsx_runtime60 = require("react/jsx-runtime");
var MENUBAR_NAME = "Menubar";
var [Collection5, useCollection5, createCollectionScope5] = createCollection(MENUBAR_NAME);
var [createMenubarContext, createMenubarScope] = createContextScope(MENUBAR_NAME, [
  createCollectionScope5,
  createRovingFocusGroupScope
]);
var useMenuScope3 = createMenuScope();
var useRovingFocusGroupScope2 = createRovingFocusGroupScope();
var [MenubarContextProvider, useMenubarContext] = createMenubarContext(MENUBAR_NAME);
var Menubar = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeMenubar,
      value: valueProp,
      onValueChange,
      defaultValue,
      loop = true,
      dir
    } = _a, menubarProps = __objRest(_a, [
      "__scopeMenubar",
      "value",
      "onValueChange",
      "defaultValue",
      "loop",
      "dir"
    ]);
    const direction = useDirection(dir);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
    const [value = "", setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    const [currentTabStopId, setCurrentTabStopId] = React115.useState(null);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
      MenubarContextProvider,
      {
        scope: __scopeMenubar,
        value,
        onMenuOpen: React115.useCallback(
          (value2) => {
            setValue(value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        onMenuClose: React115.useCallback(() => setValue(""), [setValue]),
        onMenuToggle: React115.useCallback(
          (value2) => {
            setValue((prevValue) => Boolean(prevValue) ? "" : value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        dir: direction,
        loop,
        children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Collection5.Provider, { scope: __scopeMenubar, children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Collection5.Slot, { scope: __scopeMenubar, children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
          Root12,
          __spreadProps(__spreadValues({
            asChild: true
          }, rovingFocusGroupScope), {
            orientation: "horizontal",
            loop,
            dir: direction,
            currentTabStopId,
            onCurrentTabStopIdChange: setCurrentTabStopId,
            children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Primitive.div, __spreadProps(__spreadValues({ role: "menubar" }, menubarProps), { ref: forwardedRef }))
          })
        ) }) })
      }
    );
  }
);
Menubar.displayName = MENUBAR_NAME;
var MENU_NAME2 = "MenubarMenu";
var [MenubarMenuProvider, useMenubarMenuContext] = createMenubarContext(MENU_NAME2);
var MenubarMenu = (props2) => {
  const _a = props2, { __scopeMenubar, value: valueProp } = _a, menuProps = __objRest(_a, ["__scopeMenubar", "value"]);
  const autoValue = useId();
  const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
  const context = useMenubarContext(MENU_NAME2, __scopeMenubar);
  const menuScope = useMenuScope3(__scopeMenubar);
  const triggerRef = React115.useRef(null);
  const wasKeyboardTriggerOpenRef = React115.useRef(false);
  const open = context.value === value;
  React115.useEffect(() => {
    if (!open)
      wasKeyboardTriggerOpenRef.current = false;
  }, [open]);
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
    MenubarMenuProvider,
    {
      scope: __scopeMenubar,
      value,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      wasKeyboardTriggerOpenRef,
      children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
        Root32,
        __spreadValues(__spreadProps(__spreadValues({}, menuScope), {
          open,
          onOpenChange: (open2) => {
            if (!open2)
              context.onMenuClose();
          },
          modal: false,
          dir: context.dir
        }), menuProps)
      )
    }
  );
};
MenubarMenu.displayName = MENU_NAME2;
var TRIGGER_NAME11 = "MenubarTrigger";
var MenubarTrigger = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar, disabled = false } = _a, triggerProps = __objRest(_a, ["__scopeMenubar", "disabled"]);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
    const menuScope = useMenuScope3(__scopeMenubar);
    const context = useMenubarContext(TRIGGER_NAME11, __scopeMenubar);
    const menuContext = useMenubarMenuContext(TRIGGER_NAME11, __scopeMenubar);
    const ref2 = React115.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2, menuContext.triggerRef);
    const [isFocused, setIsFocused] = React115.useState(false);
    const open = context.value === menuContext.value;
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Collection5.ItemSlot, { scope: __scopeMenubar, value: menuContext.value, disabled, children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
      Item3,
      __spreadProps(__spreadValues({
        asChild: true
      }, rovingFocusGroupScope), {
        focusable: !disabled,
        tabStopId: menuContext.value,
        children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Anchor2, __spreadProps(__spreadValues({ asChild: true }, menuScope), { children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
          Primitive.button,
          __spreadProps(__spreadValues({
            type: "button",
            role: "menuitem",
            id: menuContext.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": open,
            "aria-controls": open ? menuContext.contentId : void 0,
            "data-highlighted": isFocused ? "" : void 0,
            "data-state": open ? "open" : "closed",
            "data-disabled": disabled ? "" : void 0,
            disabled
          }, triggerProps), {
            ref: composedRefs,
            onPointerDown: composeEventHandlers(props2.onPointerDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onMenuOpen(menuContext.value);
                if (!open)
                  event.preventDefault();
              }
            }),
            onPointerEnter: composeEventHandlers(props2.onPointerEnter, () => {
              var _a2;
              const menubarOpen = Boolean(context.value);
              if (menubarOpen && !open) {
                context.onMenuOpen(menuContext.value);
                (_a2 = ref2.current) == null ? void 0 : _a2.focus();
              }
            }),
            onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
              if (disabled)
                return;
              if (["Enter", " "].includes(event.key))
                context.onMenuToggle(menuContext.value);
              if (event.key === "ArrowDown")
                context.onMenuOpen(menuContext.value);
              if (["Enter", " ", "ArrowDown"].includes(event.key)) {
                menuContext.wasKeyboardTriggerOpenRef.current = true;
                event.preventDefault();
              }
            }),
            onFocus: composeEventHandlers(props2.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props2.onBlur, () => setIsFocused(false))
          })
        ) }))
      })
    ) });
  }
);
MenubarTrigger.displayName = TRIGGER_NAME11;
var PORTAL_NAME12 = "MenubarPortal";
var MenubarPortal = (props2) => {
  const _a = props2, { __scopeMenubar } = _a, portalProps = __objRest(_a, ["__scopeMenubar"]);
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Portal6, __spreadValues(__spreadValues({}, menuScope), portalProps));
};
MenubarPortal.displayName = PORTAL_NAME12;
var CONTENT_NAME13 = "MenubarContent";
var MenubarContent = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar, align = "start" } = _a, contentProps = __objRest(_a, ["__scopeMenubar", "align"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    const context = useMenubarContext(CONTENT_NAME13, __scopeMenubar);
    const menuContext = useMenubarMenuContext(CONTENT_NAME13, __scopeMenubar);
    const getItems = useCollection5(__scopeMenubar);
    const hasInteractedOutsideRef = React115.useRef(false);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
      Content24,
      __spreadProps(__spreadValues(__spreadValues({
        id: menuContext.contentId,
        "aria-labelledby": menuContext.triggerId,
        "data-radix-menubar-content": ""
      }, menuScope), contentProps), {
        ref: forwardedRef,
        align,
        onCloseAutoFocus: composeEventHandlers(props2.onCloseAutoFocus, (event) => {
          var _a2;
          const menubarOpen = Boolean(context.value);
          if (!menubarOpen && !hasInteractedOutsideRef.current) {
            (_a2 = menuContext.triggerRef.current) == null ? void 0 : _a2.focus();
          }
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(props2.onFocusOutside, (event) => {
          const target = event.target;
          const isMenubarTrigger = getItems().some((item) => {
            var _a2;
            return (_a2 = item.ref.current) == null ? void 0 : _a2.contains(target);
          });
          if (isMenubarTrigger)
            event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props2.onInteractOutside, () => {
          hasInteractedOutsideRef.current = true;
        }),
        onEntryFocus: (event) => {
          if (!menuContext.wasKeyboardTriggerOpenRef.current)
            event.preventDefault();
        },
        onKeyDown: composeEventHandlers(
          props2.onKeyDown,
          (event) => {
            if (["ArrowRight", "ArrowLeft"].includes(event.key)) {
              const target = event.target;
              const targetIsSubTrigger = target.hasAttribute("data-radix-menubar-subtrigger");
              const isKeyDownInsideSubMenu = target.closest("[data-radix-menubar-content]") !== event.currentTarget;
              const prevMenuKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
              const isPrevKey = prevMenuKey === event.key;
              const isNextKey = !isPrevKey;
              if (isNextKey && targetIsSubTrigger)
                return;
              if (isKeyDownInsideSubMenu && isPrevKey)
                return;
              const items = getItems().filter((item) => !item.disabled);
              let candidateValues = items.map((item) => item.value);
              if (isPrevKey)
                candidateValues.reverse();
              const currentIndex = candidateValues.indexOf(menuContext.value);
              candidateValues = context.loop ? wrapArray4(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
              const [nextValue] = candidateValues;
              if (nextValue)
                context.onMenuOpen(nextValue);
            }
          },
          { checkForDefaultPrevented: false }
        ),
        style: __spreadValues(__spreadValues({}, props2.style), {
          "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
          "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
          "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
        })
      })
    );
  }
);
MenubarContent.displayName = CONTENT_NAME13;
var GROUP_NAME6 = "MenubarGroup";
var MenubarGroup = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, groupProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Group2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), groupProps), { ref: forwardedRef }));
  }
);
MenubarGroup.displayName = GROUP_NAME6;
var LABEL_NAME5 = "MenubarLabel";
var MenubarLabel = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, labelProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Label2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), labelProps), { ref: forwardedRef }));
  }
);
MenubarLabel.displayName = LABEL_NAME5;
var ITEM_NAME7 = "MenubarItem";
var MenubarItem = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, itemProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Item22, __spreadProps(__spreadValues(__spreadValues({}, menuScope), itemProps), { ref: forwardedRef }));
  }
);
MenubarItem.displayName = ITEM_NAME7;
var CHECKBOX_ITEM_NAME4 = "MenubarCheckboxItem";
var MenubarCheckboxItem = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, checkboxItemProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(CheckboxItem, __spreadProps(__spreadValues(__spreadValues({}, menuScope), checkboxItemProps), { ref: forwardedRef }));
  }
);
MenubarCheckboxItem.displayName = CHECKBOX_ITEM_NAME4;
var RADIO_GROUP_NAME4 = "MenubarRadioGroup";
var MenubarRadioGroup = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, radioGroupProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(RadioGroup, __spreadProps(__spreadValues(__spreadValues({}, menuScope), radioGroupProps), { ref: forwardedRef }));
  }
);
MenubarRadioGroup.displayName = RADIO_GROUP_NAME4;
var RADIO_ITEM_NAME4 = "MenubarRadioItem";
var MenubarRadioItem = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, radioItemProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(RadioItem, __spreadProps(__spreadValues(__spreadValues({}, menuScope), radioItemProps), { ref: forwardedRef }));
  }
);
MenubarRadioItem.displayName = RADIO_ITEM_NAME4;
var INDICATOR_NAME4 = "MenubarItemIndicator";
var MenubarItemIndicator = React115.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeMenubar } = _a, itemIndicatorProps = __objRest(_a, ["__scopeMenubar"]);
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(ItemIndicator2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), itemIndicatorProps), { ref: forwardedRef }));
});
MenubarItemIndicator.displayName = INDICATOR_NAME4;
var SEPARATOR_NAME5 = "MenubarSeparator";
var MenubarSeparator = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, separatorProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Separator2, __spreadProps(__spreadValues(__spreadValues({}, menuScope), separatorProps), { ref: forwardedRef }));
  }
);
MenubarSeparator.displayName = SEPARATOR_NAME5;
var ARROW_NAME8 = "MenubarArrow";
var MenubarArrow = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, arrowProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Arrow22, __spreadProps(__spreadValues(__spreadValues({}, menuScope), arrowProps), { ref: forwardedRef }));
  }
);
MenubarArrow.displayName = ARROW_NAME8;
var SUB_NAME3 = "MenubarSub";
var MenubarSub = (props2) => {
  const { __scopeMenubar, children, open: openProp, onOpenChange, defaultOpen } = props2;
  const menuScope = useMenuScope3(__scopeMenubar);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Sub, __spreadProps(__spreadValues({}, menuScope), { open, onOpenChange: setOpen, children }));
};
MenubarSub.displayName = SUB_NAME3;
var SUB_TRIGGER_NAME4 = "MenubarSubTrigger";
var MenubarSubTrigger = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, subTriggerProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
      SubTrigger,
      __spreadProps(__spreadValues(__spreadValues({
        "data-radix-menubar-subtrigger": ""
      }, menuScope), subTriggerProps), {
        ref: forwardedRef
      })
    );
  }
);
MenubarSubTrigger.displayName = SUB_TRIGGER_NAME4;
var SUB_CONTENT_NAME4 = "MenubarSubContent";
var MenubarSubContent = React115.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeMenubar } = _a, subContentProps = __objRest(_a, ["__scopeMenubar"]);
    const menuScope = useMenuScope3(__scopeMenubar);
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
      SubContent,
      __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, menuScope), {
        "data-radix-menubar-content": ""
      }), subContentProps), {
        ref: forwardedRef,
        style: __spreadValues(__spreadValues({}, props2.style), {
          "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
          "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
          "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
        })
      })
    );
  }
);
MenubarSubContent.displayName = SUB_CONTENT_NAME4;
function wrapArray4(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root33 = Menubar;
var Menu2 = MenubarMenu;
var Trigger10 = MenubarTrigger;
var Portal25 = MenubarPortal;
var Content29 = MenubarContent;
var Group24 = MenubarGroup;
var Label24 = MenubarLabel;
var Item32 = MenubarItem;
var CheckboxItem23 = MenubarCheckboxItem;
var RadioGroup23 = MenubarRadioGroup;
var RadioItem23 = MenubarRadioItem;
var ItemIndicator24 = MenubarItemIndicator;
var Separator24 = MenubarSeparator;
var Sub23 = MenubarSub;
var SubTrigger23 = MenubarSubTrigger;
var SubContent23 = MenubarSubContent;

// src/components/menubar.tsx
var import_utils34 = require("@nubras/utils");
var import_jsx_runtime61 = require("react/jsx-runtime");
var MenubarMenu2 = Menu2;
var MenubarGroup2 = Group24;
var MenubarPortal2 = Portal25;
var MenubarSub2 = Sub23;
var MenubarRadioGroup2 = RadioGroup23;
var Menubar2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
    Root33,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
        className
      )
    }, props2)
  );
});
Menubar2.displayName = Root33.displayName;
var MenubarTrigger2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
    Trigger10,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        className
      )
    }, props2)
  );
});
MenubarTrigger2.displayName = Trigger10.displayName;
var MenubarSubTrigger2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset, children } = _b, props2 = __objRest(_b, ["className", "inset", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(
    SubTrigger23,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        inset && "pl-8",
        className
      )
    }, props2), {
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(ChevronRight, { className: "ml-auto h-4 w-4" })
      ]
    })
  );
});
MenubarSubTrigger2.displayName = SubTrigger23.displayName;
var MenubarSubContent2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
    SubContent23,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  );
});
MenubarSubContent2.displayName = SubContent23.displayName;
var MenubarContent2 = React116.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className, align = "start", alignOffset = -4, sideOffset = 8 } = _b, props2 = __objRest(_b, ["className", "align", "alignOffset", "sideOffset"]);
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(Portal25, { children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
      Content29,
      __spreadValues({
        ref: ref2,
        align,
        alignOffset,
        sideOffset,
        className: (0, import_utils34.cn)(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )
      }, props2)
    ) });
  }
);
MenubarContent2.displayName = Content29.displayName;
var MenubarItem2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset } = _b, props2 = __objRest(_b, ["className", "inset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
    Item32,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        inset && "pl-8",
        className
      )
    }, props2)
  );
});
MenubarItem2.displayName = Item32.displayName;
var MenubarCheckboxItem2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className, children, checked } = _b, props2 = __objRest(_b, ["className", "children", "checked"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(
    CheckboxItem23,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      ),
      checked
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(ItemIndicator24, { children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(Check, { className: "h-4 w-4" }) }) }),
        children
      ]
    })
  );
});
MenubarCheckboxItem2.displayName = CheckboxItem23.displayName;
var MenubarRadioItem2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(
    RadioItem23,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(ItemIndicator24, { children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(Circle, { className: "h-2 w-2 fill-current" }) }) }),
        children
      ]
    })
  );
});
MenubarRadioItem2.displayName = RadioItem23.displayName;
var MenubarLabel2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className, inset } = _b, props2 = __objRest(_b, ["className", "inset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
    Label24,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)(
        "px-2 py-1.5 text-sm font-semibold",
        inset && "pl-8",
        className
      )
    }, props2)
  );
});
MenubarLabel2.displayName = Label24.displayName;
var MenubarSeparator2 = React116.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
    Separator24,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils34.cn)("-mx-1 my-1 h-px bg-muted", className)
    }, props2)
  );
});
MenubarSeparator2.displayName = Separator24.displayName;
var MenubarShortcut = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
    "span",
    __spreadValues({
      className: (0, import_utils34.cn)(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )
    }, props2)
  );
};
MenubarShortcut.displayname = "MenubarShortcut";

// src/components/navigation-menu.tsx
var React118 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-navigation-menu@1.2.3_@types+react-dom@19.1.3_@types+react@19.1.3__@types+rea_macpaq3jtumq5jejz5petkczee/node_modules/@radix-ui/react-navigation-menu/dist/index.mjs
var React117 = __toESM(require("react"), 1);
var import_react_dom5 = __toESM(require("react-dom"), 1);
var import_jsx_runtime62 = require("react/jsx-runtime");
var NAVIGATION_MENU_NAME = "NavigationMenu";
var [Collection6, useCollection6, createCollectionScope6] = createCollection(NAVIGATION_MENU_NAME);
var [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] = createCollection(NAVIGATION_MENU_NAME);
var [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(
  NAVIGATION_MENU_NAME,
  [createCollectionScope6, createFocusGroupCollectionScope]
);
var [NavigationMenuProviderImpl, useNavigationMenuContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var NavigationMenu = React117.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      delayDuration = 200,
      skipDelayDuration = 300,
      orientation = "horizontal",
      dir
    } = _a, NavigationMenuProps = __objRest(_a, [
      "__scopeNavigationMenu",
      "value",
      "onValueChange",
      "defaultValue",
      "delayDuration",
      "skipDelayDuration",
      "orientation",
      "dir"
    ]);
    const [navigationMenu, setNavigationMenu] = React117.useState(null);
    const composedRef = useComposedRefs(forwardedRef, (node) => setNavigationMenu(node));
    const direction = useDirection(dir);
    const openTimerRef = React117.useRef(0);
    const closeTimerRef = React117.useRef(0);
    const skipDelayTimerRef = React117.useRef(0);
    const [isOpenDelayed, setIsOpenDelayed] = React117.useState(true);
    const [value = "", setValue] = useControllableState({
      prop: valueProp,
      onChange: (value2) => {
        const isOpen = value2 !== "";
        const hasSkipDelayDuration = skipDelayDuration > 0;
        if (isOpen) {
          window.clearTimeout(skipDelayTimerRef.current);
          if (hasSkipDelayDuration)
            setIsOpenDelayed(false);
        } else {
          window.clearTimeout(skipDelayTimerRef.current);
          skipDelayTimerRef.current = window.setTimeout(
            () => setIsOpenDelayed(true),
            skipDelayDuration
          );
        }
        onValueChange == null ? void 0 : onValueChange(value2);
      },
      defaultProp: defaultValue
    });
    const startCloseTimer = React117.useCallback(() => {
      window.clearTimeout(closeTimerRef.current);
      closeTimerRef.current = window.setTimeout(() => setValue(""), 150);
    }, [setValue]);
    const handleOpen = React117.useCallback(
      (itemValue) => {
        window.clearTimeout(closeTimerRef.current);
        setValue(itemValue);
      },
      [setValue]
    );
    const handleDelayedOpen = React117.useCallback(
      (itemValue) => {
        const isOpenItem = value === itemValue;
        if (isOpenItem) {
          window.clearTimeout(closeTimerRef.current);
        } else {
          openTimerRef.current = window.setTimeout(() => {
            window.clearTimeout(closeTimerRef.current);
            setValue(itemValue);
          }, delayDuration);
        }
      },
      [value, setValue, delayDuration]
    );
    React117.useEffect(() => {
      return () => {
        window.clearTimeout(openTimerRef.current);
        window.clearTimeout(closeTimerRef.current);
        window.clearTimeout(skipDelayTimerRef.current);
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: true,
        value,
        dir: direction,
        orientation,
        rootNavigationMenu: navigationMenu,
        onTriggerEnter: (itemValue) => {
          window.clearTimeout(openTimerRef.current);
          if (isOpenDelayed)
            handleDelayedOpen(itemValue);
          else
            handleOpen(itemValue);
        },
        onTriggerLeave: () => {
          window.clearTimeout(openTimerRef.current);
          startCloseTimer();
        },
        onContentEnter: () => window.clearTimeout(closeTimerRef.current),
        onContentLeave: startCloseTimer,
        onItemSelect: (itemValue) => {
          setValue((prevValue) => prevValue === itemValue ? "" : itemValue);
        },
        onItemDismiss: () => setValue(""),
        children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
          Primitive.nav,
          __spreadProps(__spreadValues({
            "aria-label": "Main",
            "data-orientation": orientation,
            dir: direction
          }, NavigationMenuProps), {
            ref: composedRef
          })
        )
      }
    );
  }
);
NavigationMenu.displayName = NAVIGATION_MENU_NAME;
var SUB_NAME4 = "NavigationMenuSub";
var NavigationMenuSub = React117.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal"
    } = _a, subProps = __objRest(_a, [
      "__scopeNavigationMenu",
      "value",
      "onValueChange",
      "defaultValue",
      "orientation"
    ]);
    const context = useNavigationMenuContext(SUB_NAME4, __scopeNavigationMenu);
    const [value = "", setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: false,
        value,
        dir: context.dir,
        orientation,
        rootNavigationMenu: context.rootNavigationMenu,
        onTriggerEnter: (itemValue) => setValue(itemValue),
        onItemSelect: (itemValue) => setValue(itemValue),
        onItemDismiss: () => setValue(""),
        children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Primitive.div, __spreadProps(__spreadValues({ "data-orientation": orientation }, subProps), { ref: forwardedRef }))
      }
    );
  }
);
NavigationMenuSub.displayName = SUB_NAME4;
var NavigationMenuProvider = (props2) => {
  const {
    scope,
    isRootMenu,
    rootNavigationMenu,
    dir,
    orientation,
    children,
    value,
    onItemSelect,
    onItemDismiss,
    onTriggerEnter,
    onTriggerLeave,
    onContentEnter,
    onContentLeave
  } = props2;
  const [viewport, setViewport] = React117.useState(null);
  const [viewportContent, setViewportContent] = React117.useState(/* @__PURE__ */ new Map());
  const [indicatorTrack, setIndicatorTrack] = React117.useState(null);
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
    NavigationMenuProviderImpl,
    {
      scope,
      isRootMenu,
      rootNavigationMenu,
      value,
      previousValue: usePrevious(value),
      baseId: useId(),
      dir,
      orientation,
      viewport,
      onViewportChange: setViewport,
      indicatorTrack,
      onIndicatorTrackChange: setIndicatorTrack,
      onTriggerEnter: useCallbackRef(onTriggerEnter),
      onTriggerLeave: useCallbackRef(onTriggerLeave),
      onContentEnter: useCallbackRef(onContentEnter),
      onContentLeave: useCallbackRef(onContentLeave),
      onItemSelect: useCallbackRef(onItemSelect),
      onItemDismiss: useCallbackRef(onItemDismiss),
      onViewportContentChange: React117.useCallback((contentValue, contentData) => {
        setViewportContent((prevContent) => {
          prevContent.set(contentValue, contentData);
          return new Map(prevContent);
        });
      }, []),
      onViewportContentRemove: React117.useCallback((contentValue) => {
        setViewportContent((prevContent) => {
          if (!prevContent.has(contentValue))
            return prevContent;
          prevContent.delete(contentValue);
          return new Map(prevContent);
        });
      }, []),
      children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Collection6.Provider, { scope, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(ViewportContentProvider, { scope, items: viewportContent, children }) })
    }
  );
};
var LIST_NAME = "NavigationMenuList";
var NavigationMenuList = React117.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeNavigationMenu } = _a, listProps = __objRest(_a, ["__scopeNavigationMenu"]);
    const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);
    const list = /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Primitive.ul, __spreadProps(__spreadValues({ "data-orientation": context.orientation }, listProps), { ref: forwardedRef }));
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Primitive.div, { style: { position: "relative" }, ref: context.onIndicatorTrackChange, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Collection6.Slot, { scope: __scopeNavigationMenu, children: context.isRootMenu ? /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(FocusGroup, { asChild: true, children: list }) : list }) });
  }
);
NavigationMenuList.displayName = LIST_NAME;
var ITEM_NAME8 = "NavigationMenuItem";
var [NavigationMenuItemContextProvider, useNavigationMenuItemContext] = createNavigationMenuContext(ITEM_NAME8);
var NavigationMenuItem = React117.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeNavigationMenu, value: valueProp } = _a, itemProps = __objRest(_a, ["__scopeNavigationMenu", "value"]);
    const autoValue = useId();
    const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
    const contentRef = React117.useRef(null);
    const triggerRef = React117.useRef(null);
    const focusProxyRef = React117.useRef(null);
    const restoreContentTabOrderRef = React117.useRef(() => {
    });
    const wasEscapeCloseRef = React117.useRef(false);
    const handleContentEntry = React117.useCallback((side = "start") => {
      if (contentRef.current) {
        restoreContentTabOrderRef.current();
        const candidates = getTabbableCandidates3(contentRef.current);
        if (candidates.length)
          focusFirst5(side === "start" ? candidates : candidates.reverse());
      }
    }, []);
    const handleContentExit = React117.useCallback(() => {
      if (contentRef.current) {
        const candidates = getTabbableCandidates3(contentRef.current);
        if (candidates.length)
          restoreContentTabOrderRef.current = removeFromTabOrder(candidates);
      }
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      NavigationMenuItemContextProvider,
      {
        scope: __scopeNavigationMenu,
        value,
        triggerRef,
        contentRef,
        focusProxyRef,
        wasEscapeCloseRef,
        onEntryKeyDown: handleContentEntry,
        onFocusProxyEnter: handleContentEntry,
        onRootContentClose: handleContentExit,
        onContentFocusOutside: handleContentExit,
        children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Primitive.li, __spreadProps(__spreadValues({}, itemProps), { ref: forwardedRef }))
      }
    );
  }
);
NavigationMenuItem.displayName = ITEM_NAME8;
var TRIGGER_NAME12 = "NavigationMenuTrigger";
var NavigationMenuTrigger = React117.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeNavigationMenu, disabled } = _a, triggerProps = __objRest(_a, ["__scopeNavigationMenu", "disabled"]);
  const context = useNavigationMenuContext(TRIGGER_NAME12, props2.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME12, props2.__scopeNavigationMenu);
  const ref2 = React117.useRef(null);
  const composedRefs = useComposedRefs(ref2, itemContext.triggerRef, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, itemContext.value);
  const contentId = makeContentId(context.baseId, itemContext.value);
  const hasPointerMoveOpenedRef = React117.useRef(false);
  const wasClickCloseRef = React117.useRef(false);
  const open = itemContext.value === context.value;
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(import_jsx_runtime62.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Collection6.ItemSlot, { scope: __scopeNavigationMenu, value: itemContext.value, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(FocusGroupItem, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        id: triggerId,
        disabled,
        "data-disabled": disabled ? "" : void 0,
        "data-state": getOpenState2(open),
        "aria-expanded": open,
        "aria-controls": contentId
      }, triggerProps), {
        ref: composedRefs,
        onPointerEnter: composeEventHandlers(props2.onPointerEnter, () => {
          wasClickCloseRef.current = false;
          itemContext.wasEscapeCloseRef.current = false;
        }),
        onPointerMove: composeEventHandlers(
          props2.onPointerMove,
          whenMouse2(() => {
            if (disabled || wasClickCloseRef.current || itemContext.wasEscapeCloseRef.current || hasPointerMoveOpenedRef.current)
              return;
            context.onTriggerEnter(itemContext.value);
            hasPointerMoveOpenedRef.current = true;
          })
        ),
        onPointerLeave: composeEventHandlers(
          props2.onPointerLeave,
          whenMouse2(() => {
            if (disabled)
              return;
            context.onTriggerLeave();
            hasPointerMoveOpenedRef.current = false;
          })
        ),
        onClick: composeEventHandlers(props2.onClick, () => {
          context.onItemSelect(itemContext.value);
          wasClickCloseRef.current = open;
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          const verticalEntryKey = context.dir === "rtl" ? "ArrowLeft" : "ArrowRight";
          const entryKey = { horizontal: "ArrowDown", vertical: verticalEntryKey }[context.orientation];
          if (open && event.key === entryKey) {
            itemContext.onEntryKeyDown();
            event.preventDefault();
          }
        })
      })
    ) }) }),
    open && /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(import_jsx_runtime62.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
        Root9,
        {
          "aria-hidden": true,
          tabIndex: 0,
          ref: itemContext.focusProxyRef,
          onFocus: (event) => {
            const content = itemContext.contentRef.current;
            const prevFocusedElement = event.relatedTarget;
            const wasTriggerFocused = prevFocusedElement === ref2.current;
            const wasFocusFromContent = content == null ? void 0 : content.contains(prevFocusedElement);
            if (wasTriggerFocused || !wasFocusFromContent) {
              itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
            }
          }
        }
      ),
      context.viewport && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)("span", { "aria-owns": contentId })
    ] })
  ] });
});
NavigationMenuTrigger.displayName = TRIGGER_NAME12;
var LINK_NAME = "NavigationMenuLink";
var LINK_SELECT = "navigationMenu.linkSelect";
var NavigationMenuLink = React117.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeNavigationMenu, active, onSelect } = _a, linkProps = __objRest(_a, ["__scopeNavigationMenu", "active", "onSelect"]);
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(FocusGroupItem, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      Primitive.a,
      __spreadProps(__spreadValues({
        "data-active": active ? "" : void 0,
        "aria-current": active ? "page" : void 0
      }, linkProps), {
        ref: forwardedRef,
        onClick: composeEventHandlers(
          props2.onClick,
          (event) => {
            const target = event.target;
            const linkSelectEvent = new CustomEvent(LINK_SELECT, {
              bubbles: true,
              cancelable: true
            });
            target.addEventListener(LINK_SELECT, (event2) => onSelect == null ? void 0 : onSelect(event2), { once: true });
            dispatchDiscreteCustomEvent(target, linkSelectEvent);
            if (!linkSelectEvent.defaultPrevented && !event.metaKey) {
              const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {
                bubbles: true,
                cancelable: true
              });
              dispatchDiscreteCustomEvent(target, rootContentDismissEvent);
            }
          },
          { checkForDefaultPrevented: false }
        )
      })
    ) });
  }
);
NavigationMenuLink.displayName = LINK_NAME;
var INDICATOR_NAME5 = "NavigationMenuIndicator";
var NavigationMenuIndicator = React117.forwardRef((props2, forwardedRef) => {
  const _a = props2, { forceMount } = _a, indicatorProps = __objRest(_a, ["forceMount"]);
  const context = useNavigationMenuContext(INDICATOR_NAME5, props2.__scopeNavigationMenu);
  const isVisible2 = Boolean(context.value);
  return context.indicatorTrack ? import_react_dom5.default.createPortal(
    /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Presence, { present: forceMount || isVisible2, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(NavigationMenuIndicatorImpl, __spreadProps(__spreadValues({}, indicatorProps), { ref: forwardedRef })) }),
    context.indicatorTrack
  ) : null;
});
NavigationMenuIndicator.displayName = INDICATOR_NAME5;
var NavigationMenuIndicatorImpl = React117.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeNavigationMenu } = _a, indicatorProps = __objRest(_a, ["__scopeNavigationMenu"]);
  const context = useNavigationMenuContext(INDICATOR_NAME5, __scopeNavigationMenu);
  const getItems = useCollection6(__scopeNavigationMenu);
  const [activeTrigger, setActiveTrigger] = React117.useState(
    null
  );
  const [position2, setPosition] = React117.useState(null);
  const isHorizontal = context.orientation === "horizontal";
  const isVisible2 = Boolean(context.value);
  React117.useEffect(() => {
    var _a2;
    const items = getItems();
    const triggerNode = (_a2 = items.find((item) => item.value === context.value)) == null ? void 0 : _a2.ref.current;
    if (triggerNode)
      setActiveTrigger(triggerNode);
  }, [getItems, context.value]);
  const handlePositionChange = () => {
    if (activeTrigger) {
      setPosition({
        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,
        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop
      });
    }
  };
  useResizeObserver(activeTrigger, handlePositionChange);
  useResizeObserver(context.indicatorTrack, handlePositionChange);
  return position2 ? /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
    Primitive.div,
    __spreadProps(__spreadValues({
      "aria-hidden": true,
      "data-state": isVisible2 ? "visible" : "hidden",
      "data-orientation": context.orientation
    }, indicatorProps), {
      ref: forwardedRef,
      style: __spreadValues(__spreadValues({
        position: "absolute"
      }, isHorizontal ? {
        left: 0,
        width: position2.size + "px",
        transform: `translateX(${position2.offset}px)`
      } : {
        top: 0,
        height: position2.size + "px",
        transform: `translateY(${position2.offset}px)`
      }), indicatorProps.style)
    })
  ) : null;
});
var CONTENT_NAME14 = "NavigationMenuContent";
var NavigationMenuContent = React117.forwardRef((props2, forwardedRef) => {
  const _a = props2, { forceMount } = _a, contentProps = __objRest(_a, ["forceMount"]);
  const context = useNavigationMenuContext(CONTENT_NAME14, props2.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(CONTENT_NAME14, props2.__scopeNavigationMenu);
  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);
  const open = itemContext.value === context.value;
  const commonProps = __spreadValues({
    value: itemContext.value,
    triggerRef: itemContext.triggerRef,
    focusProxyRef: itemContext.focusProxyRef,
    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,
    onContentFocusOutside: itemContext.onContentFocusOutside,
    onRootContentClose: itemContext.onRootContentClose
  }, contentProps);
  return !context.viewport ? /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Presence, { present: forceMount || open, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
    NavigationMenuContentImpl,
    __spreadProps(__spreadValues({
      "data-state": getOpenState2(open)
    }, commonProps), {
      ref: composedRefs,
      onPointerEnter: composeEventHandlers(props2.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(
        props2.onPointerLeave,
        whenMouse2(context.onContentLeave)
      ),
      style: __spreadValues({
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0
      }, commonProps.style)
    })
  ) }) : /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(ViewportContentMounter, __spreadProps(__spreadValues({ forceMount }, commonProps), { ref: composedRefs }));
});
NavigationMenuContent.displayName = CONTENT_NAME14;
var ViewportContentMounter = React117.forwardRef((props2, forwardedRef) => {
  const context = useNavigationMenuContext(CONTENT_NAME14, props2.__scopeNavigationMenu);
  const { onViewportContentChange, onViewportContentRemove } = context;
  useLayoutEffect2(() => {
    onViewportContentChange(props2.value, __spreadValues({
      ref: forwardedRef
    }, props2));
  }, [props2, forwardedRef, onViewportContentChange]);
  useLayoutEffect2(() => {
    return () => onViewportContentRemove(props2.value);
  }, [props2.value, onViewportContentRemove]);
  return null;
});
var ROOT_CONTENT_DISMISS = "navigationMenu.rootContentDismiss";
var NavigationMenuContentImpl = React117.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    __scopeNavigationMenu,
    value,
    triggerRef,
    focusProxyRef,
    wasEscapeCloseRef,
    onRootContentClose,
    onContentFocusOutside
  } = _a, contentProps = __objRest(_a, [
    "__scopeNavigationMenu",
    "value",
    "triggerRef",
    "focusProxyRef",
    "wasEscapeCloseRef",
    "onRootContentClose",
    "onContentFocusOutside"
  ]);
  const context = useNavigationMenuContext(CONTENT_NAME14, __scopeNavigationMenu);
  const ref2 = React117.useRef(null);
  const composedRefs = useComposedRefs(ref2, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, value);
  const contentId = makeContentId(context.baseId, value);
  const getItems = useCollection6(__scopeNavigationMenu);
  const prevMotionAttributeRef = React117.useRef(null);
  const { onItemDismiss } = context;
  React117.useEffect(() => {
    const content = ref2.current;
    if (context.isRootMenu && content) {
      const handleClose = () => {
        var _a2;
        onItemDismiss();
        onRootContentClose();
        if (content.contains(document.activeElement))
          (_a2 = triggerRef.current) == null ? void 0 : _a2.focus();
      };
      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);
      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);
    }
  }, [context.isRootMenu, props2.value, triggerRef, onItemDismiss, onRootContentClose]);
  const motionAttribute = React117.useMemo(() => {
    const items = getItems();
    const values = items.map((item) => item.value);
    if (context.dir === "rtl")
      values.reverse();
    const index2 = values.indexOf(context.value);
    const prevIndex = values.indexOf(context.previousValue);
    const isSelected = value === context.value;
    const wasSelected = prevIndex === values.indexOf(value);
    if (!isSelected && !wasSelected)
      return prevMotionAttributeRef.current;
    const attribute = (() => {
      if (index2 !== prevIndex) {
        if (isSelected && prevIndex !== -1)
          return index2 > prevIndex ? "from-end" : "from-start";
        if (wasSelected && index2 !== -1)
          return index2 > prevIndex ? "to-start" : "to-end";
      }
      return null;
    })();
    prevMotionAttributeRef.current = attribute;
    return attribute;
  }, [context.previousValue, context.value, context.dir, getItems, value]);
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(FocusGroup, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
    DismissableLayer,
    __spreadProps(__spreadValues({
      id: contentId,
      "aria-labelledby": triggerId,
      "data-motion": motionAttribute,
      "data-orientation": context.orientation
    }, contentProps), {
      ref: composedRefs,
      disableOutsidePointerEvents: false,
      onDismiss: () => {
        var _a2;
        const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {
          bubbles: true,
          cancelable: true
        });
        (_a2 = ref2.current) == null ? void 0 : _a2.dispatchEvent(rootContentDismissEvent);
      },
      onFocusOutside: composeEventHandlers(props2.onFocusOutside, (event) => {
        var _a2;
        onContentFocusOutside();
        const target = event.target;
        if ((_a2 = context.rootNavigationMenu) == null ? void 0 : _a2.contains(target))
          event.preventDefault();
      }),
      onPointerDownOutside: composeEventHandlers(props2.onPointerDownOutside, (event) => {
        var _a2;
        const target = event.target;
        const isTrigger = getItems().some((item) => {
          var _a3;
          return (_a3 = item.ref.current) == null ? void 0 : _a3.contains(target);
        });
        const isRootViewport = context.isRootMenu && ((_a2 = context.viewport) == null ? void 0 : _a2.contains(target));
        if (isTrigger || isRootViewport || !context.isRootMenu)
          event.preventDefault();
      }),
      onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
        var _a2;
        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
        const isTabKey = event.key === "Tab" && !isMetaKey;
        if (isTabKey) {
          const candidates = getTabbableCandidates3(event.currentTarget);
          const focusedElement = document.activeElement;
          const index2 = candidates.findIndex((candidate) => candidate === focusedElement);
          const isMovingBackwards = event.shiftKey;
          const nextCandidates = isMovingBackwards ? candidates.slice(0, index2).reverse() : candidates.slice(index2 + 1, candidates.length);
          if (focusFirst5(nextCandidates)) {
            event.preventDefault();
          } else {
            (_a2 = focusProxyRef.current) == null ? void 0 : _a2.focus();
          }
        }
      }),
      onEscapeKeyDown: composeEventHandlers(props2.onEscapeKeyDown, (event) => {
        wasEscapeCloseRef.current = true;
      })
    })
  ) });
});
var VIEWPORT_NAME2 = "NavigationMenuViewport";
var NavigationMenuViewport = React117.forwardRef((props2, forwardedRef) => {
  const _a = props2, { forceMount } = _a, viewportProps = __objRest(_a, ["forceMount"]);
  const context = useNavigationMenuContext(VIEWPORT_NAME2, props2.__scopeNavigationMenu);
  const open = Boolean(context.value);
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Presence, { present: forceMount || open, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(NavigationMenuViewportImpl, __spreadProps(__spreadValues({}, viewportProps), { ref: forwardedRef })) });
});
NavigationMenuViewport.displayName = VIEWPORT_NAME2;
var NavigationMenuViewportImpl = React117.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeNavigationMenu, children } = _a, viewportImplProps = __objRest(_a, ["__scopeNavigationMenu", "children"]);
  const context = useNavigationMenuContext(VIEWPORT_NAME2, __scopeNavigationMenu);
  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);
  const viewportContentContext = useViewportContentContext(
    CONTENT_NAME14,
    props2.__scopeNavigationMenu
  );
  const [size4, setSize] = React117.useState(null);
  const [content, setContent] = React117.useState(null);
  const viewportWidth = size4 ? (size4 == null ? void 0 : size4.width) + "px" : void 0;
  const viewportHeight = size4 ? (size4 == null ? void 0 : size4.height) + "px" : void 0;
  const open = Boolean(context.value);
  const activeContentValue = open ? context.value : context.previousValue;
  const handleSizeChange = () => {
    if (content)
      setSize({ width: content.offsetWidth, height: content.offsetHeight });
  };
  useResizeObserver(content, handleSizeChange);
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
    Primitive.div,
    __spreadProps(__spreadValues({
      "data-state": getOpenState2(open),
      "data-orientation": context.orientation
    }, viewportImplProps), {
      ref: composedRefs,
      style: __spreadValues({
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0,
        ["--radix-navigation-menu-viewport-width"]: viewportWidth,
        ["--radix-navigation-menu-viewport-height"]: viewportHeight
      }, viewportImplProps.style),
      onPointerEnter: composeEventHandlers(props2.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(props2.onPointerLeave, whenMouse2(context.onContentLeave)),
      children: Array.from(viewportContentContext.items).map((_b) => {
        var [value, _c] = _b, _d = _c, { ref: ref2, forceMount } = _d, props22 = __objRest(_d, ["ref", "forceMount"]);
        const isActive2 = activeContentValue === value;
        return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Presence, { present: forceMount || isActive2, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
          NavigationMenuContentImpl,
          __spreadProps(__spreadValues({}, props22), {
            ref: composeRefs(ref2, (node) => {
              if (isActive2 && node)
                setContent(node);
            })
          })
        ) }, value);
      })
    })
  );
});
var FOCUS_GROUP_NAME = "FocusGroup";
var FocusGroup = React117.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeNavigationMenu } = _a, groupProps = __objRest(_a, ["__scopeNavigationMenu"]);
    const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(FocusGroupCollection.Provider, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(FocusGroupCollection.Slot, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Primitive.div, __spreadProps(__spreadValues({ dir: context.dir }, groupProps), { ref: forwardedRef })) }) });
  }
);
var ARROW_KEYS = ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"];
var FOCUS_GROUP_ITEM_NAME = "FocusGroupItem";
var FocusGroupItem = React117.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeNavigationMenu } = _a, groupProps = __objRest(_a, ["__scopeNavigationMenu"]);
    const getItems = useFocusGroupCollection(__scopeNavigationMenu);
    const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(FocusGroupCollection.ItemSlot, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({}, groupProps), {
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          const isFocusNavigationKey = ["Home", "End", ...ARROW_KEYS].includes(event.key);
          if (isFocusNavigationKey) {
            let candidateNodes = getItems().map((item) => item.ref.current);
            const prevItemKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
            const prevKeys = [prevItemKey, "ArrowUp", "End"];
            if (prevKeys.includes(event.key))
              candidateNodes.reverse();
            if (ARROW_KEYS.includes(event.key)) {
              const currentIndex = candidateNodes.indexOf(event.currentTarget);
              candidateNodes = candidateNodes.slice(currentIndex + 1);
            }
            setTimeout(() => focusFirst5(candidateNodes));
            event.preventDefault();
          }
        })
      })
    ) });
  }
);
function getTabbableCandidates3(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst5(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
function getOpenState2(open) {
  return open ? "open" : "closed";
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
function whenMouse2(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root29 = NavigationMenu;
var List = NavigationMenuList;
var Item4 = NavigationMenuItem;
var Trigger11 = NavigationMenuTrigger;
var Link = NavigationMenuLink;
var Indicator2 = NavigationMenuIndicator;
var Content7 = NavigationMenuContent;
var Viewport2 = NavigationMenuViewport;

// src/components/navigation-menu.tsx
var import_utils35 = require("@nubras/utils");
var import_jsx_runtime63 = require("react/jsx-runtime");
var NavigationMenu2 = React118.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(
    Root29,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils35.cn)(
        "relative z-10 flex max-w-max flex-1 items-center justify-center",
        className
      )
    }, props2), {
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(NavigationMenuViewport2, {})
      ]
    })
  );
});
NavigationMenu2.displayName = Root29.displayName;
var NavigationMenuList2 = React118.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
    List,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils35.cn)(
        "group flex flex-1 list-none items-center justify-center space-x-1",
        className
      )
    }, props2)
  );
});
NavigationMenuList2.displayName = List.displayName;
var NavigationMenuItem2 = Item4;
var navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
);
var NavigationMenuTrigger2 = React118.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(
    Trigger11,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils35.cn)(navigationMenuTriggerStyle(), "group", className)
    }, props2), {
      children: [
        children,
        " ",
        /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
          ChevronDown,
          {
            className: "relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180",
            "aria-hidden": "true"
          }
        )
      ]
    })
  );
});
NavigationMenuTrigger2.displayName = Trigger11.displayName;
var NavigationMenuContent2 = React118.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
    Content7,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils35.cn)(
        "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
        className
      )
    }, props2)
  );
});
NavigationMenuContent2.displayName = Content7.displayName;
var NavigationMenuLink2 = Link;
var NavigationMenuViewport2 = React118.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)("div", { className: (0, import_utils35.cn)("absolute left-0 top-full flex justify-center"), children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
    Viewport2,
    __spreadValues({
      className: (0, import_utils35.cn)(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      ),
      ref: ref2
    }, props2)
  ) });
});
NavigationMenuViewport2.displayName = Viewport2.displayName;
var NavigationMenuIndicator2 = React118.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
    Indicator2,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils35.cn)(
        "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
        className
      )
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)("div", { className: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" })
    })
  );
});
NavigationMenuIndicator2.displayName = Indicator2.displayName;

// src/components/pagination.tsx
var React119 = __toESM(require("react"));
var import_utils36 = require("@nubras/utils");
var import_jsx_runtime64 = require("react/jsx-runtime");
var Pagination = (_a) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
    "nav",
    __spreadValues({
      role: "navigation",
      "aria-label": "pagination",
      className: (0, import_utils36.cn)("mx-auto flex w-full justify-center", className)
    }, props2)
  );
};
Pagination.displayName = "Pagination";
var PaginationContent = React119.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
    "ul",
    __spreadValues({
      ref: ref2,
      className: (0, import_utils36.cn)("flex flex-row items-center gap-1", className)
    }, props2)
  );
});
PaginationContent.displayName = "PaginationContent";
var PaginationItem = React119.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("li", __spreadValues({ ref: ref2, className: (0, import_utils36.cn)("", className) }, props2));
});
PaginationItem.displayName = "PaginationItem";
var PaginationLink = (_a) => {
  var _b = _a, {
    className,
    isActive: isActive2,
    size: size4 = "icon"
  } = _b, props2 = __objRest(_b, [
    "className",
    "isActive",
    "size"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
    "a",
    __spreadValues({
      "aria-current": isActive2 ? "page" : void 0,
      className: (0, import_utils36.cn)(
        buttonVariants({
          variant: isActive2 ? "outline" : "ghost",
          size: size4
        }),
        className
      )
    }, props2)
  );
};
PaginationLink.displayName = "PaginationLink";
var PaginationPrevious = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(
    PaginationLink,
    __spreadProps(__spreadValues({
      "aria-label": "Go to previous page",
      size: "default",
      className: (0, import_utils36.cn)("gap-1 pl-2.5", className)
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ChevronLeft, { className: "h-4 w-4" }),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("span", { children: "Previous" })
      ]
    })
  );
};
PaginationPrevious.displayName = "PaginationPrevious";
var PaginationNext = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(
    PaginationLink,
    __spreadProps(__spreadValues({
      "aria-label": "Go to next page",
      size: "default",
      className: (0, import_utils36.cn)("gap-1 pr-2.5", className)
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("span", { children: "Next" }),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ChevronRight, { className: "h-4 w-4" })
      ]
    })
  );
};
PaginationNext.displayName = "PaginationNext";
var PaginationEllipsis = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(
    "span",
    __spreadProps(__spreadValues({
      "aria-hidden": true,
      className: (0, import_utils36.cn)("flex h-9 w-9 items-center justify-center", className)
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Ellipsis, { className: "h-4 w-4" }),
        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("span", { className: "sr-only", children: "More pages" })
      ]
    })
  );
};
PaginationEllipsis.displayName = "PaginationEllipsis";

// src/components/progress.tsx
var React121 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-progress@1.1.6_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1_q7mndnyothfyvbntvbj45c3y4e/node_modules/@radix-ui/react-progress/dist/index.mjs
var React120 = __toESM(require("react"), 1);
var import_jsx_runtime65 = require("react/jsx-runtime");
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope2(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress = React120.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeProgress,
      value: valueProp = null,
      max: maxProp,
      getValueLabel = defaultGetValueLabel
    } = _a, progressProps = __objRest(_a, [
      "__scopeProgress",
      "value",
      "max",
      "getValueLabel"
    ]);
    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
      console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
    }
    const max3 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
    if (valueProp !== null && !isValidValueNumber(valueProp, max3)) {
      console.error(getInvalidValueError(`${valueProp}`, "Progress"));
    }
    const value = isValidValueNumber(valueProp, max3) ? valueProp : null;
    const valueLabel = isNumber2(value) ? getValueLabel(value, max3) : void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(ProgressProvider, { scope: __scopeProgress, value, max: max3, children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
      Primitive2.div,
      __spreadProps(__spreadValues({
        "aria-valuemax": max3,
        "aria-valuemin": 0,
        "aria-valuenow": isNumber2(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": getProgressState(value, max3),
        "data-value": value != null ? value : void 0,
        "data-max": max3
      }, progressProps), {
        ref: forwardedRef
      })
    ) });
  }
);
Progress.displayName = PROGRESS_NAME;
var INDICATOR_NAME6 = "ProgressIndicator";
var ProgressIndicator = React120.forwardRef(
  (props2, forwardedRef) => {
    var _b;
    const _a = props2, { __scopeProgress } = _a, indicatorProps = __objRest(_a, ["__scopeProgress"]);
    const context = useProgressContext(INDICATOR_NAME6, __scopeProgress);
    return /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
      Primitive2.div,
      __spreadProps(__spreadValues({
        "data-state": getProgressState(context.value, context.max),
        "data-value": (_b = context.value) != null ? _b : void 0,
        "data-max": context.max
      }, indicatorProps), {
        ref: forwardedRef
      })
    );
  }
);
ProgressIndicator.displayName = INDICATOR_NAME6;
function defaultGetValueLabel(value, max3) {
  return `${Math.round(value / max3 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber2(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max3) {
  return isNumber2(max3) && !isNaN(max3) && max3 > 0;
}
function isValidValueNumber(value, max3) {
  return isNumber2(value) && !isNaN(value) && value <= max3 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var Root15 = Progress;
var Indicator3 = ProgressIndicator;

// src/components/progress.tsx
var import_utils37 = require("@nubras/utils");
var import_jsx_runtime66 = require("react/jsx-runtime");
var Progress2 = React121.forwardRef((_a, ref2) => {
  var _b = _a, { className, value } = _b, props2 = __objRest(_b, ["className", "value"]);
  return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
    Root15,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils37.cn)("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
        Indicator3,
        {
          className: "h-full w-full flex-1 bg-primary transition-all",
          style: { transform: `translateX(-${100 - (value || 0)}%)` }
        }
      )
    })
  );
});
Progress2.displayName = Root15.displayName;

// src/components/radio-group.tsx
var React123 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-radio-group@1.2.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@1_pgfyadm7snlp7hopbumhjrouga/node_modules/@radix-ui/react-radio-group/dist/index.mjs
var React212 = __toESM(require("react"), 1);
var React122 = __toESM(require("react"), 1);
var import_jsx_runtime67 = require("react/jsx-runtime");
var import_jsx_runtime68 = require("react/jsx-runtime");
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React122.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeRadio,
      name,
      checked = false,
      required: required2,
      disabled,
      value = "on",
      onCheck,
      form
    } = _a, radioProps = __objRest(_a, [
      "__scopeRadio",
      "name",
      "checked",
      "required",
      "disabled",
      "value",
      "onCheck",
      "form"
    ]);
    const [button, setButton] = React122.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React122.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    return /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
        Primitive.button,
        __spreadProps(__spreadValues({
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState7(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value
        }, radioProps), {
          ref: composedRefs,
          onClick: composeEventHandlers(props2.onClick, (event) => {
            if (!checked)
              onCheck == null ? void 0 : onCheck();
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        })
      ),
      isFormControl && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
        BubbleInput2,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required: required2,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME7 = "RadioIndicator";
var RadioIndicator = React122.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeRadio, forceMount } = _a, indicatorProps = __objRest(_a, ["__scopeRadio", "forceMount"]);
    const context = useRadioContext(INDICATOR_NAME7, __scopeRadio);
    return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(Presence, { present: forceMount || context.checked, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
      Primitive.span,
      __spreadProps(__spreadValues({
        "data-state": getState7(context.checked),
        "data-disabled": context.disabled ? "" : void 0
      }, indicatorProps), {
        ref: forwardedRef
      })
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME7;
var BubbleInput2 = (props2) => {
  const _a = props2, { control, checked, bubbles = true } = _a, inputProps = __objRest(_a, ["control", "checked", "bubbles"]);
  const ref2 = React122.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React122.useEffect(() => {
    const input = ref2.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
    "input",
    __spreadProps(__spreadValues({
      type: "radio",
      "aria-hidden": true,
      defaultChecked: checked
    }, inputProps), {
      tabIndex: -1,
      ref: ref2,
      style: __spreadProps(__spreadValues(__spreadValues({}, props2.style), controlSize), {
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      })
    })
  );
};
function getState7(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS2 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME5 = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME5, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope3 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider2, useRadioGroupContext2] = createRadioGroupContext(RADIO_GROUP_NAME5);
var RadioGroup3 = React212.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeRadioGroup,
      name,
      defaultValue,
      value: valueProp,
      required: required2 = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange
    } = _a, groupProps = __objRest(_a, [
      "__scopeRadioGroup",
      "name",
      "defaultValue",
      "value",
      "required",
      "disabled",
      "orientation",
      "dir",
      "loop",
      "onValueChange"
    ]);
    const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
      RadioGroupProvider2,
      {
        scope: __scopeRadioGroup,
        name,
        required: required2,
        disabled,
        value,
        onValueChange: setValue,
        children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
          Root12,
          __spreadProps(__spreadValues({
            asChild: true
          }, rovingFocusGroupScope), {
            orientation,
            dir: direction,
            loop,
            children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
              Primitive.div,
              __spreadProps(__spreadValues({
                role: "radiogroup",
                "aria-required": required2,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction
              }, groupProps), {
                ref: forwardedRef
              })
            )
          })
        )
      }
    );
  }
);
RadioGroup3.displayName = RADIO_GROUP_NAME5;
var ITEM_NAME9 = "RadioGroupItem";
var RadioGroupItem = React212.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeRadioGroup, disabled } = _a, itemProps = __objRest(_a, ["__scopeRadioGroup", "disabled"]);
    const context = useRadioGroupContext2(ITEM_NAME9, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref2 = React212.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = React212.useRef(false);
    React212.useEffect(() => {
      const handleKeyDown = (event) => {
        if (ARROW_KEYS2.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
      Item3,
      __spreadProps(__spreadValues({
        asChild: true
      }, rovingFocusGroupScope), {
        focusable: !isDisabled,
        active: checked,
        children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
          Radio,
          __spreadProps(__spreadValues(__spreadValues({
            disabled: isDisabled,
            required: context.required,
            checked
          }, radioScope), itemProps), {
            name: context.name,
            ref: composedRefs,
            onCheck: () => context.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter")
                event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              var _a2;
              if (isArrowKeyPressedRef.current)
                (_a2 = ref2.current) == null ? void 0 : _a2.click();
            })
          })
        )
      })
    );
  }
);
RadioGroupItem.displayName = ITEM_NAME9;
var INDICATOR_NAME22 = "RadioGroupIndicator";
var RadioGroupIndicator = React212.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeRadioGroup } = _a, indicatorProps = __objRest(_a, ["__scopeRadioGroup"]);
    const radioScope = useRadioScope(__scopeRadioGroup);
    return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(RadioIndicator, __spreadProps(__spreadValues(__spreadValues({}, radioScope), indicatorProps), { ref: forwardedRef }));
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME22;
var Root210 = RadioGroup3;
var Item25 = RadioGroupItem;
var Indicator4 = RadioGroupIndicator;

// src/components/radio-group.tsx
var import_utils38 = require("@nubras/utils");
var import_jsx_runtime69 = require("react/jsx-runtime");
var RadioGroup4 = React123.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
    Root210,
    __spreadProps(__spreadValues({
      className: (0, import_utils38.cn)("grid gap-2", className)
    }, props2), {
      ref: ref2
    })
  );
});
RadioGroup4.displayName = Root210.displayName;
var RadioGroupItem2 = React123.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
    Item25,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils38.cn)(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(Indicator4, { className: "flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(Circle, { className: "h-2.5 w-2.5 fill-current text-current" }) })
    })
  );
});
RadioGroupItem2.displayName = Item25.displayName;

// ../../node_modules/.pnpm/react-resizable-panels@2.1.9_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/react-resizable-panels/dist/react-resizable-panels.node.esm.js
var React124 = __toESM(require("react"));
var import_react43 = require("react");
var PanelGroupContext = (0, import_react43.createContext)(null);
PanelGroupContext.displayName = "PanelGroupContext";
var DATA_ATTRIBUTES = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
};
var PRECISION = 10;
var useId4 = React124["useId".toString()];
var wrappedUseId = typeof useId4 === "function" ? useId4 : () => null;
var counter = 0;
function useUniqueId2(idFromParams = null) {
  const idFromUseId = wrappedUseId();
  const idRef = (0, import_react43.useRef)(idFromParams || idFromUseId || null);
  if (idRef.current === null) {
    idRef.current = "" + counter++;
  }
  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;
}
function PanelWithForwardedRef(_a) {
  var _b = _a, {
    children,
    className: classNameFromProps = "",
    collapsedSize,
    collapsible,
    defaultSize,
    forwardedRef,
    id: idFromProps,
    maxSize,
    minSize,
    onCollapse,
    onExpand,
    onResize,
    order,
    style: styleFromProps,
    tagName: Type = "div"
  } = _b, rest = __objRest(_b, [
    "children",
    "className",
    "collapsedSize",
    "collapsible",
    "defaultSize",
    "forwardedRef",
    "id",
    "maxSize",
    "minSize",
    "onCollapse",
    "onExpand",
    "onResize",
    "order",
    "style",
    "tagName"
  ]);
  const context = (0, import_react43.useContext)(PanelGroupContext);
  if (context === null) {
    throw Error(`Panel components must be rendered within a PanelGroup container`);
  }
  const {
    collapsePanel,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    reevaluatePanelConstraints,
    registerPanel,
    resizePanel: resizePanel2,
    unregisterPanel
  } = context;
  const panelId = useUniqueId2(idFromProps);
  const panelDataRef = (0, import_react43.useRef)({
    callbacks: {
      onCollapse,
      onExpand,
      onResize
    },
    constraints: {
      collapsedSize,
      collapsible,
      defaultSize,
      maxSize,
      minSize
    },
    id: panelId,
    idIsFromProps: idFromProps !== void 0,
    order
  });
  (0, import_react43.useRef)({
    didLogMissingDefaultSizeWarning: false
  });
  (0, import_react43.useImperativeHandle)(forwardedRef, () => ({
    collapse: () => {
      collapsePanel(panelDataRef.current);
    },
    expand: (minSize2) => {
      expandPanel(panelDataRef.current, minSize2);
    },
    getId() {
      return panelId;
    },
    getSize() {
      return getPanelSize(panelDataRef.current);
    },
    isCollapsed() {
      return isPanelCollapsed(panelDataRef.current);
    },
    isExpanded() {
      return !isPanelCollapsed(panelDataRef.current);
    },
    resize: (size4) => {
      resizePanel2(panelDataRef.current, size4);
    }
  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel2]);
  const style2 = getPanelStyle(panelDataRef.current, defaultSize);
  return (0, import_react43.createElement)(Type, __spreadProps(__spreadValues({}, rest), {
    children,
    className: classNameFromProps,
    id: panelId,
    style: __spreadValues(__spreadValues({}, style2), styleFromProps),
    // CSS selectors
    [DATA_ATTRIBUTES.groupId]: groupId,
    [DATA_ATTRIBUTES.panel]: "",
    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || void 0,
    [DATA_ATTRIBUTES.panelId]: panelId,
    [DATA_ATTRIBUTES.panelSize]: parseFloat("" + style2.flexGrow).toFixed(1)
  }));
}
var Panel = (0, import_react43.forwardRef)((props2, ref2) => (0, import_react43.createElement)(PanelWithForwardedRef, __spreadProps(__spreadValues({}, props2), {
  forwardedRef: ref2
})));
PanelWithForwardedRef.displayName = "Panel";
Panel.displayName = "forwardRef(Panel)";
var nonce;
function getNonce2() {
  return nonce;
}
var currentCursorStyle = null;
var enabled = true;
var prevRuleIndex = -1;
var styleElement = null;
function getCursorStyle(state, constraintFlags) {
  if (constraintFlags) {
    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;
    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;
    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;
    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
    if (horizontalMin) {
      if (verticalMin) {
        return "se-resize";
      } else if (verticalMax) {
        return "ne-resize";
      } else {
        return "e-resize";
      }
    } else if (horizontalMax) {
      if (verticalMin) {
        return "sw-resize";
      } else if (verticalMax) {
        return "nw-resize";
      } else {
        return "w-resize";
      }
    } else if (verticalMin) {
      return "s-resize";
    } else if (verticalMax) {
      return "n-resize";
    }
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  if (styleElement !== null) {
    document.head.removeChild(styleElement);
    currentCursorStyle = null;
    styleElement = null;
    prevRuleIndex = -1;
  }
}
function setGlobalCursorStyle(state, constraintFlags) {
  var _styleElement$sheet$i, _styleElement$sheet2;
  if (!enabled) {
    return;
  }
  const style2 = getCursorStyle(state, constraintFlags);
  if (currentCursorStyle === style2) {
    return;
  }
  currentCursorStyle = style2;
  if (styleElement === null) {
    styleElement = document.createElement("style");
    const nonce2 = getNonce2();
    if (nonce2) {
      styleElement.setAttribute("nonce", nonce2);
    }
    document.head.appendChild(styleElement);
  }
  if (prevRuleIndex >= 0) {
    var _styleElement$sheet;
    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);
  }
  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style2} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isPointerEvent(event) {
  return event.type.startsWith("pointer");
}
function isMouseEvent2(event) {
  return event.type.startsWith("mouse");
}
function getResizeEventCoordinates(event) {
  if (isPointerEvent(event)) {
    if (event.isPrimary) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
  } else if (isMouseEvent2(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return {
    x: Infinity,
    y: Infinity
  };
}
function getInputType() {
  if (typeof matchMedia === "function") {
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
}
function intersects(rectOne, rectTwo, strict) {
  if (strict) {
    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
  } else {
    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;
  }
}
function compare(a, b) {
  if (a === b)
    throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: get_ancestors(a),
    b: get_ancestors(b)
  };
  let common_ancestor;
  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {
    a = ancestors.a.pop();
    b = ancestors.b.pop();
    common_ancestor = a;
  }
  assert(common_ancestor, "Stacking order can only be calculated for elements with a common ancestor");
  const z_indexes = {
    a: get_z_index(find_stacking_context(ancestors.a)),
    b: get_z_index(find_stacking_context(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes;
    const furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i = children.length;
    while (i--) {
      const child = children[i];
      if (child === furthest_ancestors.a)
        return 1;
      if (child === furthest_ancestors.b)
        return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
var props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function is_flex_item(node) {
  var _get_parent;
  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;
  return display === "flex" || display === "inline-flex";
}
function creates_stacking_context(node) {
  const style2 = getComputedStyle(node);
  if (style2.position === "fixed")
    return true;
  if (style2.zIndex !== "auto" && (style2.position !== "static" || is_flex_item(node)))
    return true;
  if (+style2.opacity < 1)
    return true;
  if ("transform" in style2 && style2.transform !== "none")
    return true;
  if ("webkitTransform" in style2 && style2.webkitTransform !== "none")
    return true;
  if ("mixBlendMode" in style2 && style2.mixBlendMode !== "normal")
    return true;
  if ("filter" in style2 && style2.filter !== "none")
    return true;
  if ("webkitFilter" in style2 && style2.webkitFilter !== "none")
    return true;
  if ("isolation" in style2 && style2.isolation === "isolate")
    return true;
  if (props.test(style2.willChange))
    return true;
  if (style2.webkitOverflowScrolling === "touch")
    return true;
  return false;
}
function find_stacking_context(nodes) {
  let i = nodes.length;
  while (i--) {
    const node = nodes[i];
    assert(node, "Missing node");
    if (creates_stacking_context(node))
      return node;
  }
  return null;
}
function get_z_index(node) {
  return node && Number(getComputedStyle(node).zIndex) || 0;
}
function get_ancestors(node) {
  const ancestors = [];
  while (node) {
    ancestors.push(node);
    node = get_parent(node);
  }
  return ancestors;
}
function get_parent(node) {
  const {
    parentNode
  } = node;
  if (parentNode && parentNode instanceof ShadowRoot) {
    return parentNode.host;
  }
  return parentNode;
}
var EXCEEDED_HORIZONTAL_MIN = 1;
var EXCEEDED_HORIZONTAL_MAX = 2;
var EXCEEDED_VERTICAL_MIN = 4;
var EXCEEDED_VERTICAL_MAX = 8;
var isCoarsePointer = getInputType() === "coarse";
var intersectingHandles = [];
var isPointerDown = false;
var ownerDocumentCounts = /* @__PURE__ */ new Map();
var panelConstraintFlags = /* @__PURE__ */ new Map();
var registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
  var _ownerDocumentCounts$;
  const {
    ownerDocument
  } = element;
  const data = {
    direction,
    element,
    hitAreaMargins,
    setResizeHandlerState
  };
  const count7 = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;
  ownerDocumentCounts.set(ownerDocument, count7 + 1);
  registeredResizeHandlers.add(data);
  updateListeners();
  return function unregisterResizeHandle() {
    var _ownerDocumentCounts$2;
    panelConstraintFlags.delete(resizeHandleId);
    registeredResizeHandlers.delete(data);
    const count8 = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;
    ownerDocumentCounts.set(ownerDocument, count8 - 1);
    updateListeners();
    if (count8 === 1) {
      ownerDocumentCounts.delete(ownerDocument);
    }
    if (intersectingHandles.includes(data)) {
      const index2 = intersectingHandles.indexOf(data);
      if (index2 >= 0) {
        intersectingHandles.splice(index2, 1);
      }
      updateCursor();
      setResizeHandlerState("up", true, null);
    }
  };
}
function handlePointerDown(event) {
  const {
    target
  } = event;
  const {
    x: x2,
    y
  } = getResizeEventCoordinates(event);
  isPointerDown = true;
  recalculateIntersectingHandles({
    target,
    x: x2,
    y
  });
  updateListeners();
  if (intersectingHandles.length > 0) {
    updateResizeHandlerStates("down", event);
    event.preventDefault();
    if (!isWithinResizeHandle(target)) {
      event.stopImmediatePropagation();
    }
  }
}
function handlePointerMove(event) {
  const {
    x: x2,
    y
  } = getResizeEventCoordinates(event);
  if (isPointerDown && event.buttons === 0) {
    isPointerDown = false;
    updateResizeHandlerStates("up", event);
  }
  if (!isPointerDown) {
    const {
      target
    } = event;
    recalculateIntersectingHandles({
      target,
      x: x2,
      y
    });
  }
  updateResizeHandlerStates("move", event);
  updateCursor();
  if (intersectingHandles.length > 0) {
    event.preventDefault();
  }
}
function handlePointerUp(event) {
  const {
    target
  } = event;
  const {
    x: x2,
    y
  } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear();
  isPointerDown = false;
  if (intersectingHandles.length > 0) {
    event.preventDefault();
    if (!isWithinResizeHandle(target)) {
      event.stopImmediatePropagation();
    }
  }
  updateResizeHandlerStates("up", event);
  recalculateIntersectingHandles({
    target,
    x: x2,
    y
  });
  updateCursor();
  updateListeners();
}
function isWithinResizeHandle(element) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {
      return true;
    }
    currentElement = currentElement.parentElement;
  }
  return false;
}
function recalculateIntersectingHandles({
  target,
  x: x2,
  y
}) {
  intersectingHandles.splice(0);
  let targetElement = null;
  if (target instanceof HTMLElement || target instanceof SVGElement) {
    targetElement = target;
  }
  registeredResizeHandlers.forEach((data) => {
    const {
      element: dragHandleElement,
      hitAreaMargins
    } = data;
    const dragHandleRect = dragHandleElement.getBoundingClientRect();
    const {
      bottom,
      left,
      right,
      top
    } = dragHandleRect;
    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    const eventIntersects = x2 >= left - margin && x2 <= right + margin && y >= top - margin && y <= bottom + margin;
    if (eventIntersects) {
      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      compare(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement;
        let didIntersect = false;
        while (currentElement) {
          if (currentElement.contains(dragHandleElement)) {
            break;
          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {
            didIntersect = true;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect) {
          return;
        }
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = false;
  let intersectsVertical = false;
  intersectingHandles.forEach((data) => {
    const {
      direction
    } = data;
    if (direction === "horizontal") {
      intersectsHorizontal = true;
    } else {
      intersectsVertical = true;
    }
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  });
  if (intersectsHorizontal && intersectsVertical) {
    setGlobalCursorStyle("intersection", constraintFlags);
  } else if (intersectsHorizontal) {
    setGlobalCursorStyle("horizontal", constraintFlags);
  } else if (intersectsVertical) {
    setGlobalCursorStyle("vertical", constraintFlags);
  } else {
    resetGlobalCursorStyle();
  }
}
var listenersAbortController = new AbortController();
function updateListeners() {
  listenersAbortController.abort();
  listenersAbortController = new AbortController();
  const options = {
    capture: true,
    signal: listenersAbortController.signal
  };
  if (!registeredResizeHandlers.size) {
    return;
  }
  if (isPointerDown) {
    if (intersectingHandles.length > 0) {
      ownerDocumentCounts.forEach((count7, ownerDocument) => {
        const {
          body
        } = ownerDocument;
        if (count7 > 0) {
          body.addEventListener("contextmenu", handlePointerUp, options);
          body.addEventListener("pointerleave", handlePointerMove, options);
          body.addEventListener("pointermove", handlePointerMove, options);
        }
      });
    }
    window.addEventListener("pointerup", handlePointerUp, options);
    window.addEventListener("pointercancel", handlePointerUp, options);
  } else {
    ownerDocumentCounts.forEach((count7, ownerDocument) => {
      const {
        body
      } = ownerDocument;
      if (count7 > 0) {
        body.addEventListener("pointerdown", handlePointerDown, options);
        body.addEventListener("pointermove", handlePointerMove, options);
      }
    });
  }
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const {
      setResizeHandlerState
    } = data;
    const isActive2 = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive2, event);
  });
}
function useForceUpdate() {
  const [_2, setCount] = (0, import_react43.useState)(0);
  return (0, import_react43.useCallback)(() => setCount((prevCount) => prevCount + 1), []);
}
function assert(expectedCondition, message2) {
  if (!expectedCondition) {
    console.error(message2);
    throw Error(message2);
  }
}
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {
    return 0;
  } else {
    return actual > expected ? 1 : -1;
  }
}
function fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyLayoutsEqual(actual, expected, fractionDigits) {
  if (actual.length !== expected.length) {
    return false;
  }
  for (let index2 = 0; index2 < actual.length; index2++) {
    const actualSize = actual[index2];
    const expectedSize = expected[index2];
    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {
      return false;
    }
  }
  return true;
}
function resizePanel({
  panelConstraints: panelConstraintsArray,
  panelIndex,
  size: size4
}) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);
  let {
    collapsedSize = 0,
    collapsible,
    maxSize = 100,
    minSize = 0
  } = panelConstraints;
  if (fuzzyCompareNumbers(size4, minSize) < 0) {
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      if (fuzzyCompareNumbers(size4, halfwayPoint) < 0) {
        size4 = collapsedSize;
      } else {
        size4 = minSize;
      }
    } else {
      size4 = minSize;
    }
  }
  size4 = Math.min(maxSize, size4);
  size4 = parseFloat(size4.toFixed(PRECISION));
  return size4;
}
function adjustLayoutByDelta({
  delta,
  initialLayout,
  panelConstraints: panelConstraintsArray,
  pivotIndices,
  prevLayout,
  trigger
}) {
  if (fuzzyNumbersEqual(delta, 0)) {
    return initialLayout;
  }
  const nextLayout = [...initialLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null, "Invalid first pivot index");
  assert(secondPivotIndex != null, "Invalid second pivot index");
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const panelConstraints = panelConstraintsArray[index2];
        assert(panelConstraints, `Panel constraints not found for index ${index2}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index2];
          assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index2 = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const panelConstraints = panelConstraintsArray[index2];
        assert(panelConstraints, `No panel constraints found for index ${index2}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index2];
          assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
          if (fuzzyNumbersEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = initialLayout[index2];
      assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
      const maxSafeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index2,
        size: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index2 += increment;
      if (index2 < 0 || index2 >= panelConstraintsArray.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index2 = pivotIndex;
    while (index2 >= 0 && index2 < panelConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = initialLayout[index2];
      assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index2,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index2] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index2--;
      } else {
        index2++;
      }
    }
  }
  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = initialLayout[pivotIndex];
    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index2 = pivotIndex2;
      while (index2 >= 0 && index2 < panelConstraintsArray.length) {
        const prevSize2 = nextLayout[index2];
        assert(prevSize2 != null, `Previous layout not found for panel index ${index2}`);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index2,
          size: unsafeSize2
        });
        if (!fuzzyNumbersEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index2] = safeSize2;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0)) {
          break;
        }
        if (delta > 0) {
          index2--;
        } else {
          index2++;
        }
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size4) => size4 + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100)) {
    return prevLayout;
  }
  return nextLayout;
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id="${groupId}"]`));
}
function getResizeHandleElementIndex(groupId, id, scope = document) {
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index2 = handles.findIndex((handle) => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);
  return index2 !== null && index2 !== void 0 ? index2 : null;
}
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index2 = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
  return index2 != null ? [index2, index2 + 1] : [-1, -1];
}
function getPanelGroupElement(id, rootElement = document) {
  var _dataset;
  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {
    return rootElement;
  }
  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandleElement(id, scope = document) {
  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;
  const handle = getResizeHandleElement(handleId, scope);
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index2 = handle ? handles.indexOf(handle) : -1;
  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index2]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;
  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index2 + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;
  return [idBefore, idAfter];
}
function useWindowSplitterPanelGroupBehavior({
  committedValuesRef,
  eagerValuesRef,
  groupId,
  layout,
  panelDataArray,
  panelGroupElement,
  setLayout
}) {
  (0, import_react43.useRef)({
    didWarnAboutMissingResizeHandle: false
  });
  (0, import_react43.useEffect)(() => {
    if (!panelGroupElement) {
      return;
    }
    const eagerValues = eagerValuesRef.current;
    assert(eagerValues, `Eager values not found`);
    const {
      panelDataArray: panelDataArray2
    } = eagerValues;
    const groupElement = getPanelGroupElement(groupId, panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    assert(handles, `No resize handles found for group id "${groupId}"`);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);
      assert(handleId, `Resize handle element has no handle id attribute`);
      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray2, panelGroupElement);
      if (idBefore == null || idAfter == null) {
        return () => {
        };
      }
      const onKeyDown = (event) => {
        if (event.defaultPrevented) {
          return;
        }
        switch (event.key) {
          case "Enter": {
            event.preventDefault();
            const index2 = panelDataArray2.findIndex((panelData) => panelData.id === idBefore);
            if (index2 >= 0) {
              const panelData = panelDataArray2[index2];
              assert(panelData, `No panel data found for index ${index2}`);
              const size4 = layout[index2];
              const {
                collapsedSize = 0,
                collapsible,
                minSize = 0
              } = panelData.constraints;
              if (size4 != null && collapsible) {
                const nextLayout = adjustLayoutByDelta({
                  delta: fuzzyNumbersEqual(size4, collapsedSize) ? minSize - collapsedSize : collapsedSize - size4,
                  initialLayout: layout,
                  panelConstraints: panelDataArray2.map((panelData2) => panelData2.constraints),
                  pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),
                  prevLayout: layout,
                  trigger: "keyboard"
                });
                if (layout !== nextLayout) {
                  setLayout(nextLayout);
                }
              }
            }
            break;
          }
        }
      };
      handle.addEventListener("keydown", onKeyDown);
      return () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    return () => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    };
  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);
}
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) {
    return false;
  }
  for (let index2 = 0; index2 < arrayA.length; index2++) {
    if (arrayA[index2] !== arrayB[index2]) {
      return false;
    }
  }
  return true;
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal";
  const {
    x: x2,
    y
  } = getResizeEventCoordinates(event);
  return isHorizontal ? x2 : y;
}
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement, `No resize handle element found for id "${dragHandleId}"`);
  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);
  assert(groupId, `Resize handle element has no group id attribute`);
  let {
    initialCursorPosition
  } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event);
  const groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement, `No group element found for id "${groupId}"`);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    if (event.shiftKey) {
      delta = 100;
    } else if (keyboardResizeBy != null) {
      delta = keyboardResizeBy;
    } else {
      delta = 10;
    }
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null) {
      return 0;
    }
    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
  }
}
function callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {
  layout.forEach((size4, index2) => {
    const panelData = panelsArray[index2];
    assert(panelData, `Panel data not found for index ${index2}`);
    const {
      callbacks,
      constraints,
      id: panelId
    } = panelData;
    const {
      collapsedSize = 0,
      collapsible
    } = constraints;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size4 !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size4;
      const {
        onCollapse,
        onExpand,
        onResize
      } = callbacks;
      if (onResize) {
        onResize(size4, lastNotifiedSize);
      }
      if (collapsible && (onCollapse || onExpand)) {
        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size4, collapsedSize)) {
          onExpand();
        }
        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size4, collapsedSize)) {
          onCollapse();
        }
      }
    }
  });
}
function compareLayouts(a, b) {
  if (a.length !== b.length) {
    return false;
  } else {
    for (let index2 = 0; index2 < a.length; index2++) {
      if (a[index2] != b[index2]) {
        return false;
      }
    }
  }
  return true;
}
function computePanelFlexBoxStyle({
  defaultSize,
  dragState,
  layout,
  panelData,
  panelIndex,
  precision = 3
}) {
  const size4 = layout[panelIndex];
  let flexGrow;
  if (size4 == null) {
    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : "1";
  } else if (panelData.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size4.toPrecision(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}
function debounce(callback, durationMs = 10) {
  let timeoutId = null;
  let callable = (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name) => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error2) {
    console.error(error2);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `react-resizable-panels:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel) => {
    const {
      constraints,
      id,
      idIsFromProps,
      order
    } = panel;
    if (idIsFromProps) {
      return id;
    } else {
      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
    }
  }).sort((a, b) => a.localeCompare(b)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId);
    const serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed === "object" && parsed != null) {
        return parsed;
      }
    }
  } catch (error2) {
  }
  return null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {
  var _loadSerializedPanelG2;
  const panelGroupKey = getPanelGroupKey(autoSaveId);
  const panelKey = getPanelKey(panels);
  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error2) {
    console.error(error2);
  }
}
function validatePanelGroupLayout({
  layout: prevLayout,
  panelConstraints
}) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== panelConstraints.length) {
    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size4) => `${size4}%`).join(", ")}`);
  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {
    for (let index2 = 0; index2 < panelConstraints.length; index2++) {
      const unsafeSize = nextLayout[index2];
      assert(unsafeSize != null, `No layout data found for index ${index2}`);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index2] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index2 = 0; index2 < panelConstraints.length; index2++) {
    const unsafeSize = nextLayout[index2];
    assert(unsafeSize != null, `No layout data found for index ${index2}`);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index2,
      size: unsafeSize
    });
    if (unsafeSize != safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index2] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) {
    for (let index2 = 0; index2 < panelConstraints.length; index2++) {
      const prevSize = nextLayout[index2];
      assert(prevSize != null, `No layout data found for index ${index2}`);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePanel({
        panelConstraints,
        panelIndex: index2,
        size: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index2] = safeSize;
        if (fuzzyNumbersEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextLayout;
}
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var defaultStorage = {
  getItem: (name) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var debounceMap = {};
function PanelGroupWithForwardedRef(_a) {
  var _b = _a, {
    autoSaveId = null,
    children,
    className: classNameFromProps = "",
    direction,
    forwardedRef,
    id: idFromProps = null,
    onLayout = null,
    keyboardResizeBy = null,
    storage = defaultStorage,
    style: styleFromProps,
    tagName: Type = "div"
  } = _b, rest = __objRest(_b, [
    "autoSaveId",
    "children",
    "className",
    "direction",
    "forwardedRef",
    "id",
    "onLayout",
    "keyboardResizeBy",
    "storage",
    "style",
    "tagName"
  ]);
  const groupId = useUniqueId2(idFromProps);
  const panelGroupElementRef = (0, import_react43.useRef)(null);
  const [dragState, setDragState] = (0, import_react43.useState)(null);
  const [layout, setLayout] = (0, import_react43.useState)([]);
  const forceUpdate = useForceUpdate();
  const panelIdToLastNotifiedSizeMapRef = (0, import_react43.useRef)({});
  const panelSizeBeforeCollapseRef = (0, import_react43.useRef)(/* @__PURE__ */ new Map());
  const prevDeltaRef = (0, import_react43.useRef)(0);
  const committedValuesRef = (0, import_react43.useRef)({
    autoSaveId,
    direction,
    dragState,
    id: groupId,
    keyboardResizeBy,
    onLayout,
    storage
  });
  const eagerValuesRef = (0, import_react43.useRef)({
    layout,
    panelDataArray: [],
    panelDataArrayChanged: false
  });
  (0, import_react43.useRef)({
    didLogIdAndOrderWarning: false,
    didLogPanelConstraintsWarning: false,
    prevPanelIds: []
  });
  (0, import_react43.useImperativeHandle)(forwardedRef, () => ({
    getId: () => committedValuesRef.current.id,
    getLayout: () => {
      const {
        layout: layout2
      } = eagerValuesRef.current;
      return layout2;
    },
    setLayout: (unsafeLayout) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const safeLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, safeLayout)) {
        setLayout(safeLayout);
        eagerValuesRef.current.layout = safeLayout;
        if (onLayout2) {
          onLayout2(safeLayout);
        }
        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  }), []);
  useWindowSplitterPanelGroupBehavior({
    committedValuesRef,
    eagerValuesRef,
    groupId,
    layout,
    panelDataArray: eagerValuesRef.current.panelDataArray,
    setLayout,
    panelGroupElement: panelGroupElementRef.current
  });
  (0, import_react43.useEffect)(() => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    if (autoSaveId) {
      if (layout.length === 0 || layout.length !== panelDataArray.length) {
        return;
      }
      let debouncedSave = debounceMap[autoSaveId];
      if (debouncedSave == null) {
        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
        debounceMap[autoSaveId] = debouncedSave;
      }
      const clonedPanelDataArray = [...panelDataArray];
      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);
      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);
    }
  }, [autoSaveId, layout, storage]);
  (0, import_react43.useEffect)(() => {
  });
  const collapsePanel = (0, import_react43.useCallback)((panelData) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const expandPanel = (0, import_react43.useCallback)((panelData, minSizeOverride) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize = 0,
        minSize: minSizeFromProps = 0,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;
      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);
        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const getPanelSize = (0, import_react43.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return panelSize;
  }, []);
  const getPanelStyle = (0, import_react43.useCallback)((panelData, defaultSize) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const panelIndex = findPanelDataIndex(panelDataArray, panelData);
    return computePanelFlexBoxStyle({
      defaultSize,
      dragState,
      layout,
      panelData: panelDataArray,
      panelIndex
    });
  }, [dragState, layout]);
  const isPanelCollapsed = (0, import_react43.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);
  }, []);
  const isPanelExpanded = (0, import_react43.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
  }, []);
  const registerPanel = (0, import_react43.useCallback)((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    panelDataArray.push(panelData);
    panelDataArray.sort((panelA, panelB) => {
      const orderA = panelA.order;
      const orderB = panelB.order;
      if (orderA == null && orderB == null) {
        return 0;
      } else if (orderA == null) {
        return -1;
      } else if (orderB == null) {
        return 1;
      } else {
        return orderA - orderB;
      }
    });
    eagerValuesRef.current.panelDataArrayChanged = true;
    forceUpdate();
  }, [forceUpdate]);
  const registerResizeHandle2 = (0, import_react43.useCallback)((dragHandleId) => {
    let isRTL2 = false;
    const panelGroupElement = panelGroupElementRef.current;
    if (panelGroupElement) {
      const style3 = window.getComputedStyle(panelGroupElement, null);
      if (style3.getPropertyValue("direction") === "rtl") {
        isRTL2 = true;
      }
    }
    return function resizeHandler(event) {
      event.preventDefault();
      const panelGroupElement2 = panelGroupElementRef.current;
      if (!panelGroupElement2) {
        return () => null;
      }
      const {
        direction: direction2,
        dragState: dragState2,
        id: groupId2,
        keyboardResizeBy: keyboardResizeBy2,
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const {
        initialLayout
      } = dragState2 !== null && dragState2 !== void 0 ? dragState2 : {};
      const pivotIndices = determinePivotIndices(groupId2, dragHandleId, panelGroupElement2);
      let delta = calculateDeltaPercentage(event, dragHandleId, direction2, dragState2, keyboardResizeBy2, panelGroupElement2);
      const isHorizontal = direction2 === "horizontal";
      if (isHorizontal && isRTL2) {
        delta = -delta;
      }
      const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
      const nextLayout = adjustLayoutByDelta({
        delta,
        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,
        panelConstraints,
        pivotIndices,
        prevLayout,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      });
      const layoutChanged = !compareLayouts(prevLayout, nextLayout);
      if (isPointerEvent(event) || isMouseEvent2(event)) {
        if (prevDeltaRef.current != delta) {
          prevDeltaRef.current = delta;
          if (!layoutChanged && delta !== 0) {
            if (isHorizontal) {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);
            } else {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);
            }
          } else {
            reportConstraintsViolation(dragHandleId, 0);
          }
        }
      }
      if (layoutChanged) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    };
  }, []);
  const resizePanel2 = (0, import_react43.useCallback)((panelData, unsafePanelSize) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
    const {
      panelSize,
      pivotIndices
    } = panelDataHelper(panelDataArray, panelData, prevLayout);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      initialLayout: prevLayout,
      panelConstraints: panelConstraintsArray,
      pivotIndices,
      prevLayout,
      trigger: "imperative-api"
    });
    if (!compareLayouts(prevLayout, nextLayout)) {
      setLayout(nextLayout);
      eagerValuesRef.current.layout = nextLayout;
      if (onLayout2) {
        onLayout2(nextLayout);
      }
      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
    }
  }, []);
  const reevaluatePanelConstraints = (0, import_react43.useCallback)((panelData, prevConstraints) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize: prevCollapsedSize = 0,
      collapsible: prevCollapsible
    } = prevConstraints;
    const {
      collapsedSize: nextCollapsedSize = 0,
      collapsible: nextCollapsible,
      maxSize: nextMaxSize = 100,
      minSize: nextMinSize = 0
    } = panelData.constraints;
    const {
      panelSize: prevPanelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    if (prevPanelSize == null) {
      return;
    }
    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {
      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {
        resizePanel2(panelData, nextCollapsedSize);
      }
    } else if (prevPanelSize < nextMinSize) {
      resizePanel2(panelData, nextMinSize);
    } else if (prevPanelSize > nextMaxSize) {
      resizePanel2(panelData, nextMaxSize);
    }
  }, [resizePanel2]);
  const startDragging = (0, import_react43.useCallback)((dragHandleId, event) => {
    const {
      direction: direction2
    } = committedValuesRef.current;
    const {
      layout: layout2
    } = eagerValuesRef.current;
    if (!panelGroupElementRef.current) {
      return;
    }
    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);
    assert(handleElement, `Drag handle element not found for id "${dragHandleId}"`);
    const initialCursorPosition = getResizeEventCursorPosition(direction2, event);
    setDragState({
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: layout2
    });
  }, []);
  const stopDragging = (0, import_react43.useCallback)(() => {
    setDragState(null);
  }, []);
  const unregisterPanel = (0, import_react43.useCallback)((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const index2 = findPanelDataIndex(panelDataArray, panelData);
    if (index2 >= 0) {
      panelDataArray.splice(index2, 1);
      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];
      eagerValuesRef.current.panelDataArrayChanged = true;
      forceUpdate();
    }
  }, [forceUpdate]);
  const context = (0, import_react43.useMemo)(() => ({
    collapsePanel,
    direction,
    dragState,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    isPanelExpanded,
    reevaluatePanelConstraints,
    registerPanel,
    registerResizeHandle: registerResizeHandle2,
    resizePanel: resizePanel2,
    startDragging,
    stopDragging,
    unregisterPanel,
    panelGroupElement: panelGroupElementRef.current
  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle2, resizePanel2, startDragging, stopDragging, unregisterPanel]);
  const style2 = {
    display: "flex",
    flexDirection: direction === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return (0, import_react43.createElement)(PanelGroupContext.Provider, {
    value: context
  }, (0, import_react43.createElement)(Type, __spreadProps(__spreadValues({}, rest), {
    children,
    className: classNameFromProps,
    id: idFromProps,
    ref: panelGroupElementRef,
    style: __spreadValues(__spreadValues({}, style2), styleFromProps),
    // CSS selectors
    [DATA_ATTRIBUTES.group]: "",
    [DATA_ATTRIBUTES.groupDirection]: direction,
    [DATA_ATTRIBUTES.groupId]: groupId
  })));
}
var PanelGroup = (0, import_react43.forwardRef)((props2, ref2) => (0, import_react43.createElement)(PanelGroupWithForwardedRef, __spreadProps(__spreadValues({}, props2), {
  forwardedRef: ref2
})));
PanelGroupWithForwardedRef.displayName = "PanelGroup";
PanelGroup.displayName = "forwardRef(PanelGroup)";
function findPanelDataIndex(panelDataArray, panelData) {
  return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
}
function panelDataHelper(panelDataArray, panelData, layout) {
  const panelIndex = findPanelDataIndex(panelDataArray, panelData);
  const isLastPanel = panelIndex === panelDataArray.length - 1;
  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];
  const panelSize = layout[panelIndex];
  return __spreadProps(__spreadValues({}, panelData.constraints), {
    panelSize,
    pivotIndices
  });
}
function useWindowSplitterResizeHandlerBehavior({
  disabled,
  handleId,
  resizeHandler,
  panelGroupElement
}) {
  (0, import_react43.useEffect)(() => {
    if (disabled || resizeHandler == null || panelGroupElement == null) {
      return;
    }
    const handleElement = getResizeHandleElement(handleId, panelGroupElement);
    if (handleElement == null) {
      return;
    }
    const onKeyDown = (event) => {
      if (event.defaultPrevented) {
        return;
      }
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home": {
          event.preventDefault();
          resizeHandler(event);
          break;
        }
        case "F6": {
          event.preventDefault();
          const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);
          assert(groupId, `No group element found for id "${groupId}"`);
          const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
          const index2 = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);
          assert(index2 !== null, `No resize element found for id "${handleId}"`);
          const nextIndex = event.shiftKey ? index2 > 0 ? index2 - 1 : handles.length - 1 : index2 + 1 < handles.length ? index2 + 1 : 0;
          const nextHandle = handles[nextIndex];
          nextHandle.focus();
          break;
        }
      }
    };
    handleElement.addEventListener("keydown", onKeyDown);
    return () => {
      handleElement.removeEventListener("keydown", onKeyDown);
    };
  }, [panelGroupElement, disabled, handleId, resizeHandler]);
}
function PanelResizeHandle(_a) {
  var _b = _a, {
    children = null,
    className: classNameFromProps = "",
    disabled = false,
    hitAreaMargins,
    id: idFromProps,
    onBlur,
    onClick,
    onDragging,
    onFocus,
    onPointerDown,
    onPointerUp,
    style: styleFromProps = {},
    tabIndex = 0,
    tagName: Type = "div"
  } = _b, rest = __objRest(_b, [
    "children",
    "className",
    "disabled",
    "hitAreaMargins",
    "id",
    "onBlur",
    "onClick",
    "onDragging",
    "onFocus",
    "onPointerDown",
    "onPointerUp",
    "style",
    "tabIndex",
    "tagName"
  ]);
  var _hitAreaMargins$coars, _hitAreaMargins$fine;
  const elementRef = (0, import_react43.useRef)(null);
  const callbacksRef = (0, import_react43.useRef)({
    onClick,
    onDragging,
    onPointerDown,
    onPointerUp
  });
  (0, import_react43.useEffect)(() => {
    callbacksRef.current.onClick = onClick;
    callbacksRef.current.onDragging = onDragging;
    callbacksRef.current.onPointerDown = onPointerDown;
    callbacksRef.current.onPointerUp = onPointerUp;
  });
  const panelGroupContext = (0, import_react43.useContext)(PanelGroupContext);
  if (panelGroupContext === null) {
    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);
  }
  const {
    direction,
    groupId,
    registerResizeHandle: registerResizeHandleWithParentGroup,
    startDragging,
    stopDragging,
    panelGroupElement
  } = panelGroupContext;
  const resizeHandleId = useUniqueId2(idFromProps);
  const [state, setState] = (0, import_react43.useState)("inactive");
  const [isFocused, setIsFocused] = (0, import_react43.useState)(false);
  const [resizeHandler, setResizeHandler] = (0, import_react43.useState)(null);
  const committedValuesRef = (0, import_react43.useRef)({
    state
  });
  (0, import_react43.useEffect)(() => {
    if (disabled) {
      setResizeHandler(null);
    } else {
      const resizeHandler2 = registerResizeHandleWithParentGroup(resizeHandleId);
      setResizeHandler(() => resizeHandler2);
    }
  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);
  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;
  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;
  (0, import_react43.useEffect)(() => {
    if (disabled || resizeHandler == null) {
      return;
    }
    const element = elementRef.current;
    assert(element, "Element ref not attached");
    let didMove = false;
    const setResizeHandlerState = (action, isActive2, event) => {
      if (!isActive2) {
        setState("inactive");
        return;
      }
      switch (action) {
        case "down": {
          setState("drag");
          didMove = false;
          assert(event, 'Expected event to be defined for "down" action');
          startDragging(resizeHandleId, event);
          const {
            onDragging: onDragging2,
            onPointerDown: onPointerDown2
          } = callbacksRef.current;
          onDragging2 === null || onDragging2 === void 0 ? void 0 : onDragging2(true);
          onPointerDown2 === null || onPointerDown2 === void 0 ? void 0 : onPointerDown2();
          break;
        }
        case "move": {
          const {
            state: state2
          } = committedValuesRef.current;
          didMove = true;
          if (state2 !== "drag") {
            setState("hover");
          }
          assert(event, 'Expected event to be defined for "move" action');
          resizeHandler(event);
          break;
        }
        case "up": {
          setState("hover");
          stopDragging();
          const {
            onClick: onClick2,
            onDragging: onDragging2,
            onPointerUp: onPointerUp2
          } = callbacksRef.current;
          onDragging2 === null || onDragging2 === void 0 ? void 0 : onDragging2(false);
          onPointerUp2 === null || onPointerUp2 === void 0 ? void 0 : onPointerUp2();
          if (!didMove) {
            onClick2 === null || onClick2 === void 0 ? void 0 : onClick2();
          }
          break;
        }
      }
    };
    return registerResizeHandle(resizeHandleId, element, direction, {
      coarse: coarseHitAreaMargins,
      fine: fineHitAreaMargins
    }, setResizeHandlerState);
  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);
  useWindowSplitterResizeHandlerBehavior({
    disabled,
    handleId: resizeHandleId,
    resizeHandler,
    panelGroupElement
  });
  const style2 = {
    touchAction: "none",
    userSelect: "none"
  };
  return (0, import_react43.createElement)(Type, __spreadProps(__spreadValues({}, rest), {
    children,
    className: classNameFromProps,
    id: idFromProps,
    onBlur: () => {
      setIsFocused(false);
      onBlur === null || onBlur === void 0 ? void 0 : onBlur();
    },
    onFocus: () => {
      setIsFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus();
    },
    ref: elementRef,
    role: "separator",
    style: __spreadValues(__spreadValues({}, style2), styleFromProps),
    tabIndex,
    // CSS selectors
    [DATA_ATTRIBUTES.groupDirection]: direction,
    [DATA_ATTRIBUTES.groupId]: groupId,
    [DATA_ATTRIBUTES.resizeHandle]: "",
    [DATA_ATTRIBUTES.resizeHandleActive]: state === "drag" ? "pointer" : isFocused ? "keyboard" : void 0,
    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,
    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,
    [DATA_ATTRIBUTES.resizeHandleState]: state
  }));
}
PanelResizeHandle.displayName = "PanelResizeHandle";

// src/components/resizable.tsx
var import_utils39 = require("@nubras/utils");
var import_jsx_runtime70 = require("react/jsx-runtime");
var ResizablePanelGroup = (_a) => {
  var _b = _a, {
    className
  } = _b, props2 = __objRest(_b, [
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
    PanelGroup,
    __spreadValues({
      className: (0, import_utils39.cn)(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )
    }, props2)
  );
};
var ResizablePanel = Panel;
var ResizableHandle = (_a) => {
  var _b = _a, {
    withHandle,
    className
  } = _b, props2 = __objRest(_b, [
    "withHandle",
    "className"
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
    PanelResizeHandle,
    __spreadProps(__spreadValues({
      className: (0, import_utils39.cn)(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )
    }, props2), {
      children: withHandle && /* @__PURE__ */ (0, import_jsx_runtime70.jsx)("div", { className: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border", children: /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(GripVertical, { className: "h-2.5 w-2.5" }) })
    })
  );
};

// src/components/scroll-area.tsx
var React126 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-scroll-area@1.2.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@1_g5ms2l5vfasryfybcmzwbg5x24/node_modules/@radix-ui/react-scroll-area/dist/index.mjs
var React213 = __toESM(require("react"), 1);
var React125 = __toESM(require("react"), 1);
var import_jsx_runtime71 = require("react/jsx-runtime");
function useStateMachine3(initialState, machine) {
  return React125.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState != null ? nextState : state;
  }, initialState);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea = React213.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeScrollArea,
      type = "hover",
      dir,
      scrollHideDelay = 600
    } = _a, scrollAreaProps = __objRest(_a, [
      "__scopeScrollArea",
      "type",
      "dir",
      "scrollHideDelay"
    ]);
    const [scrollArea, setScrollArea] = React213.useState(null);
    const [viewport, setViewport] = React213.useState(null);
    const [content, setContent] = React213.useState(null);
    const [scrollbarX, setScrollbarX] = React213.useState(null);
    const [scrollbarY, setScrollbarY] = React213.useState(null);
    const [cornerWidth, setCornerWidth] = React213.useState(0);
    const [cornerHeight, setCornerHeight] = React213.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = React213.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = React213.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
          Primitive.div,
          __spreadProps(__spreadValues({
            dir: direction
          }, scrollAreaProps), {
            ref: composedRefs,
            style: __spreadValues({
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px"
            }, props2.style)
          })
        )
      }
    );
  }
);
ScrollArea.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME3 = "ScrollAreaViewport";
var ScrollAreaViewport = React213.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeScrollArea, children, nonce: nonce2 } = _a, viewportProps = __objRest(_a, ["__scopeScrollArea", "children", "nonce"]);
    const context = useScrollAreaContext(VIEWPORT_NAME3, __scopeScrollArea);
    const ref2 = React213.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2, context.onViewportChange);
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce: nonce2
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
        Primitive.div,
        __spreadProps(__spreadValues({
          "data-radix-scroll-area-viewport": ""
        }, viewportProps), {
          ref: composedRefs,
          style: __spreadValues({
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden"
          }, props2.style),
          children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { ref: context.onContentChange, style: { minWidth: "100%", display: "table" }, children })
        })
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME3;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = React213.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { forceMount } = _a, scrollbarProps = __objRest(_a, ["forceMount"]);
    const context = useScrollAreaContext(SCROLLBAR_NAME, props2.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props2.orientation === "horizontal";
    React213.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ScrollAreaScrollbarHover, __spreadProps(__spreadValues({}, scrollbarProps), { ref: forwardedRef, forceMount })) : context.type === "scroll" ? /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ScrollAreaScrollbarScroll, __spreadProps(__spreadValues({}, scrollbarProps), { ref: forwardedRef, forceMount })) : context.type === "auto" ? /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ScrollAreaScrollbarAuto, __spreadProps(__spreadValues({}, scrollbarProps), { ref: forwardedRef, forceMount })) : context.type === "always" ? /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ScrollAreaScrollbarVisible, __spreadProps(__spreadValues({}, scrollbarProps), { ref: forwardedRef })) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = React213.forwardRef((props2, forwardedRef) => {
  const _a = props2, { forceMount } = _a, scrollbarProps = __objRest(_a, ["forceMount"]);
  const context = useScrollAreaContext(SCROLLBAR_NAME, props2.__scopeScrollArea);
  const [visible, setVisible] = React213.useState(false);
  React213.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(Presence, { present: forceMount || visible, children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
    ScrollAreaScrollbarAuto,
    __spreadProps(__spreadValues({
      "data-state": visible ? "visible" : "hidden"
    }, scrollbarProps), {
      ref: forwardedRef
    })
  ) });
});
var ScrollAreaScrollbarScroll = React213.forwardRef((props2, forwardedRef) => {
  const _a = props2, { forceMount } = _a, scrollbarProps = __objRest(_a, ["forceMount"]);
  const context = useScrollAreaContext(SCROLLBAR_NAME, props2.__scopeScrollArea);
  const isHorizontal = props2.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine3("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  React213.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  React213.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(Presence, { present: forceMount || state !== "hidden", children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
    ScrollAreaScrollbarVisible,
    __spreadProps(__spreadValues({
      "data-state": state === "hidden" ? "hidden" : "visible"
    }, scrollbarProps), {
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props2.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props2.onPointerLeave, () => send("POINTER_LEAVE"))
    })
  ) });
});
var ScrollAreaScrollbarAuto = React213.forwardRef((props2, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props2.__scopeScrollArea);
  const _a = props2, { forceMount } = _a, scrollbarProps = __objRest(_a, ["forceMount"]);
  const [visible, setVisible] = React213.useState(false);
  const isHorizontal = props2.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver2(context.viewport, handleResize);
  useResizeObserver2(context.content, handleResize);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(Presence, { present: forceMount || visible, children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
    ScrollAreaScrollbarVisible,
    __spreadProps(__spreadValues({
      "data-state": visible ? "visible" : "hidden"
    }, scrollbarProps), {
      ref: forwardedRef
    })
  ) });
});
var ScrollAreaScrollbarVisible = React213.forwardRef((props2, forwardedRef) => {
  const _a = props2, { orientation = "vertical" } = _a, scrollbarProps = __objRest(_a, ["orientation"]);
  const context = useScrollAreaContext(SCROLLBAR_NAME, props2.__scopeScrollArea);
  const thumbRef = React213.useRef(null);
  const pointerOffsetRef = React213.useRef(0);
  const [sizes, setSizes] = React213.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = __spreadProps(__spreadValues({}, scrollbarProps), {
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  });
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
      ScrollAreaScrollbarX,
      __spreadProps(__spreadValues({}, commonProps), {
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset6 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset6}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport)
            context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      })
    );
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
      ScrollAreaScrollbarY,
      __spreadProps(__spreadValues({}, commonProps), {
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset6 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset6}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport)
            context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport)
            context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      })
    );
  }
  return null;
});
var ScrollAreaScrollbarX = React213.forwardRef((props2, forwardedRef) => {
  const _a = props2, { sizes, onSizesChange } = _a, scrollbarProps = __objRest(_a, ["sizes", "onSizesChange"]);
  const context = useScrollAreaContext(SCROLLBAR_NAME, props2.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React213.useState();
  const ref2 = React213.useRef(null);
  const composeRefs4 = useComposedRefs(forwardedRef, ref2, context.onScrollbarXChange);
  React213.useEffect(() => {
    if (ref2.current)
      setComputedStyle(getComputedStyle(ref2.current));
  }, [ref2]);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
    ScrollAreaScrollbarImpl,
    __spreadProps(__spreadValues({
      "data-orientation": "horizontal"
    }, scrollbarProps), {
      ref: composeRefs4,
      sizes,
      style: __spreadValues({
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px"
      }, props2.style),
      onThumbPointerDown: (pointerPos) => props2.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props2.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props2.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref2.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref2.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    })
  );
});
var ScrollAreaScrollbarY = React213.forwardRef((props2, forwardedRef) => {
  const _a = props2, { sizes, onSizesChange } = _a, scrollbarProps = __objRest(_a, ["sizes", "onSizesChange"]);
  const context = useScrollAreaContext(SCROLLBAR_NAME, props2.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React213.useState();
  const ref2 = React213.useRef(null);
  const composeRefs4 = useComposedRefs(forwardedRef, ref2, context.onScrollbarYChange);
  React213.useEffect(() => {
    if (ref2.current)
      setComputedStyle(getComputedStyle(ref2.current));
  }, [ref2]);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
    ScrollAreaScrollbarImpl,
    __spreadProps(__spreadValues({
      "data-orientation": "vertical"
    }, scrollbarProps), {
      ref: composeRefs4,
      sizes,
      style: __spreadValues({
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px"
      }, props2.style),
      onThumbPointerDown: (pointerPos) => props2.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props2.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props2.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref2.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref2.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    })
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = React213.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize
  } = _a, scrollbarProps = __objRest(_a, [
    "__scopeScrollArea",
    "sizes",
    "hasThumb",
    "onThumbChange",
    "onThumbPointerUp",
    "onThumbPointerDown",
    "onThumbPositionChange",
    "onDragScroll",
    "onWheelScroll",
    "onResize"
  ]);
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = React213.useState(null);
  const composeRefs4 = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
  const rectRef = React213.useRef(null);
  const prevWebkitUserSelectRef = React213.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left;
      const y = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y });
    }
  }
  React213.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar == null ? void 0 : scrollbar.contains(element);
      if (isScrollbarWheel)
        handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  React213.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver2(scrollbar, handleResize);
  useResizeObserver2(context.content, handleResize);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef(onThumbChange),
      onThumbPointerUp: useCallbackRef(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef(onThumbPointerDown),
      children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
        Primitive.div,
        __spreadProps(__spreadValues({}, scrollbarProps), {
          ref: composeRefs4,
          style: __spreadValues({ position: "absolute" }, scrollbarProps.style),
          onPointerDown: composeEventHandlers(props2.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport)
                context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props2.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props2.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport)
              context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        })
      )
    }
  );
});
var THUMB_NAME = "ScrollAreaThumb";
var ScrollAreaThumb = React213.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { forceMount } = _a, thumbProps = __objRest(_a, ["forceMount"]);
    const scrollbarContext = useScrollbarContext(THUMB_NAME, props2.__scopeScrollArea);
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(Presence, { present: forceMount || scrollbarContext.hasThumb, children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ScrollAreaThumbImpl, __spreadValues({ ref: forwardedRef }, thumbProps)) });
  }
);
var ScrollAreaThumbImpl = React213.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeScrollArea, style: style2 } = _a, thumbProps = __objRest(_a, ["__scopeScrollArea", "style"]);
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node) => scrollbarContext.onThumbChange(node)
    );
    const removeUnlinkedScrollListenerRef = React213.useRef(void 0);
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    React213.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll2 = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
      Primitive.div,
      __spreadProps(__spreadValues({
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden"
      }, thumbProps), {
        ref: composedRef,
        style: __spreadValues({
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)"
        }, style2),
        onPointerDownCapture: composeEventHandlers(props2.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x2 = event.clientX - thumbRect.left;
          const y = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x: x2, y });
        }),
        onPointerUp: composeEventHandlers(props2.onPointerUp, scrollbarContext.onThumbPointerUp)
      })
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = React213.forwardRef(
  (props2, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props2.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ScrollAreaCornerImpl, __spreadProps(__spreadValues({}, props2), { ref: forwardedRef })) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = React213.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeScrollArea } = _a, cornerProps = __objRest(_a, ["__scopeScrollArea"]);
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = React213.useState(0);
  const [height, setHeight] = React213.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver2(context.scrollbarX, () => {
    var _a2;
    const height2 = ((_a2 = context.scrollbarX) == null ? void 0 : _a2.offsetHeight) || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver2(context.scrollbarY, () => {
    var _a2;
    const width2 = ((_a2 = context.scrollbarY) == null ? void 0 : _a2.offsetWidth) || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
    Primitive.div,
    __spreadProps(__spreadValues({}, cornerProps), {
      ref: forwardedRef,
      style: __spreadValues({
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0
      }, props2.style)
    })
  ) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset6 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset6;
  const minPointerPos = sizes.scrollbar.paddingStart + offset6;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {
}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position2 = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position2.left;
    const isVerticalScroll = prevPosition.top !== position2.top;
    if (isHorizontalScroll || isVerticalScroll)
      handler();
    prevPosition = position2;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef(callback);
  const debounceTimerRef = React213.useRef(0);
  React213.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return React213.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver2(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
var Root16 = ScrollArea;
var Viewport3 = ScrollAreaViewport;
var Corner = ScrollAreaCorner;

// src/components/scroll-area.tsx
var import_utils40 = require("@nubras/utils");
var import_jsx_runtime72 = require("react/jsx-runtime");
var ScrollArea2 = React126.forwardRef((_a, ref2) => {
  var _b = _a, { className, children } = _b, props2 = __objRest(_b, ["className", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)(
    Root16,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils40.cn)("relative overflow-hidden", className)
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(Viewport3, { className: "h-full w-full rounded-[inherit]", children }),
        /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(ScrollBar, {}),
        /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(Corner, {})
      ]
    })
  );
});
ScrollArea2.displayName = Root16.displayName;
var ScrollBar = React126.forwardRef((_a, ref2) => {
  var _b = _a, { className, orientation = "vertical" } = _b, props2 = __objRest(_b, ["className", "orientation"]);
  return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
    ScrollAreaScrollbar,
    __spreadProps(__spreadValues({
      ref: ref2,
      orientation,
      className: (0, import_utils40.cn)(
        "flex touch-none select-none transition-colors",
        orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
        orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
        className
      )
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(ScrollAreaThumb, { className: "relative flex-1 rounded-full bg-border" })
    })
  );
});
ScrollBar.displayName = ScrollAreaScrollbar.displayName;

// src/components/separator.tsx
var React128 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-separator@1.1.6_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19._6z6jnzjmjtoplcsepkfo6xrany/node_modules/@radix-ui/react-separator/dist/index.mjs
var React127 = __toESM(require("react"), 1);
var import_jsx_runtime73 = require("react/jsx-runtime");
var NAME5 = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator3 = React127.forwardRef((props2, forwardedRef) => {
  const _a = props2, { decorative, orientation: orientationProp = DEFAULT_ORIENTATION } = _a, domProps = __objRest(_a, ["decorative", "orientation"]);
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
    Primitive2.div,
    __spreadProps(__spreadValues(__spreadValues({
      "data-orientation": orientation
    }, semanticProps), domProps), {
      ref: forwardedRef
    })
  );
});
Separator3.displayName = NAME5;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root17 = Separator3;

// src/components/separator.tsx
var import_utils41 = require("@nubras/utils");
var import_jsx_runtime74 = require("react/jsx-runtime");
var Separator4 = React128.forwardRef((_a, ref2) => {
  var _b = _a, { className, orientation = "horizontal", decorative = true } = _b, props2 = __objRest(_b, ["className", "orientation", "decorative"]);
  return /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
    Root17,
    __spreadValues({
      ref: ref2,
      decorative,
      orientation,
      className: (0, import_utils41.cn)("shrink-0 bg-border", orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", className)
    }, props2)
  );
});
Separator4.displayName = Root17.displayName;

// src/components/sheet.tsx
var React129 = __toESM(require("react"));
var import_utils42 = require("@nubras/utils");
var import_jsx_runtime75 = require("react/jsx-runtime");
var Sheet = Root11;
var SheetTrigger = Trigger5;
var SheetClose = Close2;
var SheetPortal = Portal5;
var SheetOverlay = React129.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
    Overlay3,
    __spreadProps(__spreadValues({
      className: (0, import_utils42.cn)(
        "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        className
      )
    }, props2), {
      ref: ref2
    })
  );
});
SheetOverlay.displayName = Overlay3.displayName;
var sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom: "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right: "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm"
      }
    },
    defaultVariants: {
      side: "right"
    }
  }
);
var SheetContent = React129.forwardRef(
  (_a, ref2) => {
    var _b = _a, { side = "right", className, children } = _b, props2 = __objRest(_b, ["side", "className", "children"]);
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(SheetPortal, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(SheetOverlay, {}),
      /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(Content5, __spreadProps(__spreadValues({ ref: ref2, className: (0, import_utils42.cn)(sheetVariants({ side }), className) }, props2), { children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(Close2, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary", children: [
          /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(X, { className: "h-4 w-4" }),
          /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("span", { className: "sr-only", children: "Close" })
        ] })
      ] }))
    ] });
  }
);
SheetContent.displayName = Content5.displayName;
var SheetHeader = (_a) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", __spreadValues({ className: (0, import_utils42.cn)("flex flex-col space-y-2 text-center sm:text-left", className) }, props2));
};
SheetHeader.displayName = "SheetHeader";
var SheetFooter = (_a) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", __spreadValues({ className: (0, import_utils42.cn)("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className) }, props2));
};
SheetFooter.displayName = "SheetFooter";
var SheetTitle = React129.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Title3, __spreadValues({ ref: ref2, className: (0, import_utils42.cn)("text-lg font-semibold text-foreground", className) }, props2));
});
SheetTitle.displayName = Title3.displayName;
var SheetDescription = React129.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Description3, __spreadValues({ ref: ref2, className: (0, import_utils42.cn)("text-sm text-muted-foreground", className) }, props2));
});
SheetDescription.displayName = Description3.displayName;

// src/components/sidebar.tsx
var React133 = __toESM(require("react"));

// src/hooks/use-mobile.tsx
var React130 = __toESM(require("react"));
var MOBILE_BREAKPOINT = 768;
function useIsMobile() {
  const [isMobile, setIsMobile] = React130.useState(void 0);
  React130.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);
  return !!isMobile;
}

// src/components/sidebar.tsx
var import_utils45 = require("@nubras/utils");

// src/components/skeleton.tsx
var import_utils43 = require("@nubras/utils");
var import_jsx_runtime76 = require("react/jsx-runtime");
function Skeleton(_a) {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", __spreadValues({ className: (0, import_utils43.cn)("animate-pulse rounded-md bg-muted", className) }, props2));
}

// src/components/tooltip.tsx
var React132 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-tooltip@1.1.6_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1._oxyxrfc2sgsn4p6gozl2fceslq/node_modules/@radix-ui/react-tooltip/dist/index.mjs
var React131 = __toESM(require("react"), 1);
var import_jsx_runtime77 = require("react/jsx-runtime");
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope5 = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props2) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props2;
  const [isOpenDelayed, setIsOpenDelayed] = React131.useState(true);
  const isPointerInTransitRef = React131.useRef(false);
  const skipDelayTimerRef = React131.useRef(0);
  React131.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: React131.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: React131.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React131.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props2) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props2;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props2.__scopeTooltip);
  const popperScope = usePopperScope5(__scopeTooltip);
  const [trigger, setTrigger] = React131.useState(null);
  const contentId = useId();
  const openTimerRef = React131.useRef(0);
  const disableHoverableContent = disableHoverableContentProp != null ? disableHoverableContentProp : providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp != null ? delayDurationProp : providerContext.delayDuration;
  const wasOpenDelayedRef = React131.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    }
  });
  const stateAttribute = React131.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React131.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React131.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React131.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React131.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Root23, __spreadProps(__spreadValues({}, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React131.useCallback(() => {
        if (providerContext.isOpenDelayed)
          handleDelayedOpen();
        else
          handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React131.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) }));
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME13 = "TooltipTrigger";
var TooltipTrigger = React131.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeTooltip } = _a, triggerProps = __objRest(_a, ["__scopeTooltip"]);
    const context = useTooltipContext(TRIGGER_NAME13, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME13, __scopeTooltip);
    const popperScope = usePopperScope5(__scopeTooltip);
    const ref2 = React131.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2, context.onTriggerChange);
    const isPointerDownRef = React131.useRef(false);
    const hasPointerMoveOpenedRef = React131.useRef(false);
    const handlePointerUp2 = React131.useCallback(() => isPointerDownRef.current = false, []);
    React131.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp2);
    }, [handlePointerUp2]);
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Anchor, __spreadProps(__spreadValues({ asChild: true }, popperScope), { children: /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute
      }, triggerProps), {
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props2.onPointerMove, (event) => {
          if (event.pointerType === "touch")
            return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props2.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props2.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp2, { once: true });
        }),
        onFocus: composeEventHandlers(props2.onFocus, () => {
          if (!isPointerDownRef.current)
            context.onOpen();
        }),
        onBlur: composeEventHandlers(props2.onBlur, context.onClose),
        onClick: composeEventHandlers(props2.onClick, context.onClose)
      })
    ) }));
  }
);
TooltipTrigger.displayName = TRIGGER_NAME13;
var PORTAL_NAME13 = "TooltipPortal";
var [PortalProvider6, usePortalContext6] = createTooltipContext(PORTAL_NAME13, {
  forceMount: void 0
});
var TooltipPortal = (props2) => {
  const { __scopeTooltip, forceMount, children, container } = props2;
  const context = useTooltipContext(PORTAL_NAME13, __scopeTooltip);
  return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(PortalProvider6, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME13;
var CONTENT_NAME15 = "TooltipContent";
var TooltipContent = React131.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext6(CONTENT_NAME15, props2.__scopeTooltip);
    const _a = props2, { forceMount = portalContext.forceMount, side = "top" } = _a, contentProps = __objRest(_a, ["forceMount", "side"]);
    const context = useTooltipContext(CONTENT_NAME15, props2.__scopeTooltip);
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(TooltipContentImpl, __spreadProps(__spreadValues({ side }, contentProps), { ref: forwardedRef })) : /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(TooltipContentHoverable, __spreadProps(__spreadValues({ side }, contentProps), { ref: forwardedRef })) });
  }
);
var TooltipContentHoverable = React131.forwardRef((props2, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME15, props2.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME15, props2.__scopeTooltip);
  const ref2 = React131.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const [pointerGraceArea, setPointerGraceArea] = React131.useState(null);
  const { trigger, onClose } = context;
  const content = ref2.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React131.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React131.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React131.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React131.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React131.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger == null ? void 0 : trigger.contains(target)) || (content == null ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon2(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(TooltipContentImpl, __spreadProps(__spreadValues({}, props2), { ref: composedRefs }));
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = React131.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside
    } = _a, contentProps = __objRest(_a, [
      "__scopeTooltip",
      "children",
      "aria-label",
      "onEscapeKeyDown",
      "onPointerDownOutside"
    ]);
    const context = useTooltipContext(CONTENT_NAME15, __scopeTooltip);
    const popperScope = usePopperScope5(__scopeTooltip);
    const { onClose } = context;
    React131.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React131.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger))
            onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ (0, import_jsx_runtime77.jsxs)(
          Content4,
          __spreadProps(__spreadValues(__spreadValues({
            "data-state": context.stateAttribute
          }, popperScope), contentProps), {
            ref: forwardedRef,
            style: __spreadValues(__spreadValues({}, contentProps.style), {
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            }),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Slottable, { children }),
              /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Root9, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          })
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME15;
var ARROW_NAME9 = "TooltipArrow";
var TooltipArrow = React131.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeTooltip } = _a, arrowProps = __objRest(_a, ["__scopeTooltip"]);
    const popperScope = usePopperScope5(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME9,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Arrow2, __spreadProps(__spreadValues(__spreadValues({}, popperScope), arrowProps), { ref: forwardedRef }));
  }
);
TooltipArrow.displayName = ARROW_NAME9;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon2(point, polygon) {
  const { x: x2, y } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q.x - r2.x) * (p2.y - r2.y) >= (q.y - r2.y) * (p2.x - r2.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q.x - r2.x) * (p2.y - r2.y) >= (q.y - r2.y) * (p2.x - r2.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider2 = TooltipProvider;
var Root34 = Tooltip;
var Trigger12 = TooltipTrigger;
var Content210 = TooltipContent;

// src/components/tooltip.tsx
var import_utils44 = require("@nubras/utils");
var import_jsx_runtime78 = require("react/jsx-runtime");
var TooltipProvider2 = Provider2;
var Tooltip2 = Root34;
var TooltipTrigger2 = Trigger12;
var TooltipContent2 = React132.forwardRef((_a, ref2) => {
  var _b = _a, { className, sideOffset = 4 } = _b, props2 = __objRest(_b, ["className", "sideOffset"]);
  return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
    Content210,
    __spreadValues({
      ref: ref2,
      sideOffset,
      className: (0, import_utils44.cn)(
        "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )
    }, props2)
  );
});
TooltipContent2.displayName = Content210.displayName;

// src/components/sidebar.tsx
var import_jsx_runtime79 = require("react/jsx-runtime");
var SIDEBAR_COOKIE_NAME = "sidebar:state";
var SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
var SIDEBAR_WIDTH = "16rem";
var SIDEBAR_WIDTH_MOBILE = "18rem";
var SIDEBAR_WIDTH_ICON = "3rem";
var SIDEBAR_KEYBOARD_SHORTCUT = "b";
var SidebarContext = React133.createContext(null);
function useSidebar() {
  const context = React133.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }
  return context;
}
var SidebarProvider = React133.forwardRef((_a, ref2) => {
  var _b = _a, { defaultOpen = true, open: openProp, onOpenChange: setOpenProp, className, style: style2, children } = _b, props2 = __objRest(_b, ["defaultOpen", "open", "onOpenChange", "className", "style", "children"]);
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React133.useState(false);
  const [_open, _setOpen] = React133.useState(defaultOpen);
  const open = openProp != null ? openProp : _open;
  const setOpen = React133.useCallback(
    (value) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );
  const toggleSidebar = React133.useCallback(() => {
    return isMobile ? setOpenMobile((open2) => !open2) : setOpen((open2) => !open2);
  }, [isMobile, setOpen, setOpenMobile]);
  React133.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
        event.preventDefault();
        toggleSidebar();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);
  const state = open ? "expanded" : "collapsed";
  const contextValue = React133.useMemo(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(SidebarContext.Provider, { value: contextValue, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(TooltipProvider2, { delayDuration: 0, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
    "div",
    __spreadProps(__spreadValues({
      style: __spreadValues({
        "--sidebar-width": SIDEBAR_WIDTH,
        "--sidebar-width-icon": SIDEBAR_WIDTH_ICON
      }, style2),
      className: (0, import_utils45.cn)("group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar", className),
      ref: ref2
    }, props2), {
      children
    })
  ) }) });
});
SidebarProvider.displayName = "SidebarProvider";
var Sidebar = React133.forwardRef((_a, ref2) => {
  var _b = _a, { side = "left", variant = "sidebar", collapsible = "offcanvas", className, children } = _b, props2 = __objRest(_b, ["side", "variant", "collapsible", "className", "children"]);
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();
  if (collapsible === "none") {
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      "div",
      __spreadProps(__spreadValues({
        className: (0, import_utils45.cn)("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", className),
        ref: ref2
      }, props2), {
        children
      })
    );
  }
  if (isMobile) {
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(Sheet, __spreadProps(__spreadValues({ open: openMobile, onOpenChange: setOpenMobile }, props2), { children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      SheetContent,
      {
        "data-sidebar": "sidebar",
        "data-mobile": "true",
        className: "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
        style: {
          "--sidebar-width": SIDEBAR_WIDTH_MOBILE
        },
        side,
        children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("div", { className: "flex h-full w-full flex-col", children })
      }
    ) }));
  }
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsxs)(
    "div",
    {
      ref: ref2,
      className: "group peer hidden md:block text-sidebar-foreground",
      "data-state": state,
      "data-collapsible": state === "collapsed" ? collapsible : "",
      "data-variant": variant,
      "data-side": side,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
          "div",
          {
            className: (0, import_utils45.cn)(
              "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
              "group-data-[collapsible=offcanvas]:w-0",
              "group-data-[side=right]:rotate-180",
              variant === "floating" || variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
            )
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
          "div",
          __spreadProps(__spreadValues({
            className: (0, import_utils45.cn)(
              "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
              side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
              // Adjust the padding for floating and inset variants.
              variant === "floating" || variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
              className
            )
          }, props2), {
            children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
              "div",
              {
                "data-sidebar": "sidebar",
                className: "flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow",
                children
              }
            )
          })
        )
      ]
    }
  );
});
Sidebar.displayName = "Sidebar";
var SidebarTrigger = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className, onClick } = _b, props2 = __objRest(_b, ["className", "onClick"]);
    const { toggleSidebar } = useSidebar();
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsxs)(
      Button,
      __spreadProps(__spreadValues({
        ref: ref2,
        "data-sidebar": "trigger",
        variant: "ghost",
        size: "icon",
        className: (0, import_utils45.cn)("h-7 w-7", className),
        onClick: (event) => {
          onClick == null ? void 0 : onClick(event);
          toggleSidebar();
        }
      }, props2), {
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(PanelLeft, {}),
          /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("span", { className: "sr-only", children: "Toggle Sidebar" })
        ]
      })
    );
  }
);
SidebarTrigger.displayName = "SidebarTrigger";
var SidebarRail = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    const { toggleSidebar } = useSidebar();
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      "button",
      __spreadValues({
        ref: ref2,
        "data-sidebar": "rail",
        "aria-label": "Toggle Sidebar",
        tabIndex: -1,
        onClick: toggleSidebar,
        title: "Toggle Sidebar",
        className: (0, import_utils45.cn)(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          className
        )
      }, props2)
    );
  }
);
SidebarRail.displayName = "SidebarRail";
var SidebarInset = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("div", __spreadValues({ ref: ref2, className: (0, import_utils45.cn)("ml-[var(--sidebar-width)] transition-all duration-300", className) }, props2));
  }
);
SidebarInset.displayName = "SidebarInset";
var SidebarInput = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      Input,
      __spreadValues({
        ref: ref2,
        "data-sidebar": "input",
        className: (0, import_utils45.cn)(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          className
        )
      }, props2)
    );
  }
);
SidebarInput.displayName = "SidebarInput";
var SidebarHeader = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("div", __spreadValues({ ref: ref2, "data-sidebar": "header", className: (0, import_utils45.cn)("flex flex-col gap-2 p-2", className) }, props2));
});
SidebarHeader.displayName = "SidebarHeader";
var SidebarFooter = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("div", __spreadValues({ ref: ref2, "data-sidebar": "footer", className: (0, import_utils45.cn)("flex flex-col gap-2 p-2", className) }, props2));
});
SidebarFooter.displayName = "SidebarFooter";
var SidebarSeparator = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      Separator4,
      __spreadValues({
        ref: ref2,
        "data-sidebar": "separator",
        className: (0, import_utils45.cn)("mx-2 w-auto bg-sidebar-border", className)
      }, props2)
    );
  }
);
SidebarSeparator.displayName = "SidebarSeparator";
var SidebarContent = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      "data-sidebar": "content",
      className: (0, import_utils45.cn)(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )
    }, props2)
  );
});
SidebarContent.displayName = "SidebarContent";
var SidebarGroup = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
    "div",
    __spreadValues({
      ref: ref2,
      "data-sidebar": "group",
      className: (0, import_utils45.cn)("relative flex w-full min-w-0 flex-col p-2", className)
    }, props2)
  );
});
SidebarGroup.displayName = "SidebarGroup";
var SidebarGroupLabel = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className, asChild = false } = _b, props2 = __objRest(_b, ["className", "asChild"]);
    const Comp = asChild ? Slot2 : "div";
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      Comp,
      __spreadValues({
        ref: ref2,
        "data-sidebar": "group-label",
        className: (0, import_utils45.cn)(
          "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          className
        )
      }, props2)
    );
  }
);
SidebarGroupLabel.displayName = "SidebarGroupLabel";
var SidebarGroupAction = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className, asChild = false } = _b, props2 = __objRest(_b, ["className", "asChild"]);
    const Comp = asChild ? Slot2 : "button";
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      Comp,
      __spreadValues({
        ref: ref2,
        "data-sidebar": "group-action",
        className: (0, import_utils45.cn)(
          "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          // Increases the hit area of the button on mobile.
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          className
        )
      }, props2)
    );
  }
);
SidebarGroupAction.displayName = "SidebarGroupAction";
var SidebarGroupContent = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("div", __spreadValues({ ref: ref2, "data-sidebar": "group-content", className: (0, import_utils45.cn)("w-full text-sm", className) }, props2));
  }
);
SidebarGroupContent.displayName = "SidebarGroupContent";
var SidebarMenu = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("ul", __spreadValues({ ref: ref2, "data-sidebar": "menu", className: (0, import_utils45.cn)("flex w-full min-w-0 flex-col gap-1", className) }, props2));
});
SidebarMenu.displayName = "SidebarMenu";
var SidebarMenuItem = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("li", __spreadValues({ ref: ref2, "data-sidebar": "menu-item", className: (0, import_utils45.cn)("group/menu-item relative", className) }, props2));
});
SidebarMenuItem.displayName = "SidebarMenuItem";
var sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var SidebarMenuButton = React133.forwardRef((_a, ref2) => {
  var _b = _a, { asChild = false, isActive: isActive2 = false, variant = "default", size: size4 = "default", tooltip, className } = _b, props2 = __objRest(_b, ["asChild", "isActive", "variant", "size", "tooltip", "className"]);
  const Comp = asChild ? Slot2 : "button";
  const { isMobile, state } = useSidebar();
  const button = /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
    Comp,
    __spreadValues({
      ref: ref2,
      "data-sidebar": "menu-button",
      "data-size": size4,
      "data-active": isActive2,
      className: (0, import_utils45.cn)(sidebarMenuButtonVariants({ variant, size: size4 }), className)
    }, props2)
  );
  if (!tooltip) {
    return button;
  }
  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip
    };
  }
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsxs)(Tooltip2, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(TooltipTrigger2, { asChild: true, children: button }),
    /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(TooltipContent2, __spreadValues({ side: "right", align: "center", hidden: state !== "collapsed" || isMobile }, tooltip))
  ] });
});
SidebarMenuButton.displayName = "SidebarMenuButton";
var SidebarMenuAction = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className, asChild = false, showOnHover = false } = _b, props2 = __objRest(_b, ["className", "asChild", "showOnHover"]);
  const Comp = asChild ? Slot2 : "button";
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
    Comp,
    __spreadValues({
      ref: ref2,
      "data-sidebar": "menu-action",
      className: (0, import_utils45.cn)(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )
    }, props2)
  );
});
SidebarMenuAction.displayName = "SidebarMenuAction";
var SidebarMenuBadge = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      "div",
      __spreadValues({
        ref: ref2,
        "data-sidebar": "menu-badge",
        className: (0, import_utils45.cn)(
          "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
          "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          className
        )
      }, props2)
    );
  }
);
SidebarMenuBadge.displayName = "SidebarMenuBadge";
var SidebarMenuSkeleton = React133.forwardRef((_a, ref2) => {
  var _b = _a, { className, showIcon = false } = _b, props2 = __objRest(_b, ["className", "showIcon"]);
  const width = React133.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsxs)(
    "div",
    __spreadProps(__spreadValues({
      ref: ref2,
      "data-sidebar": "menu-skeleton",
      className: (0, import_utils45.cn)("rounded-md h-8 flex gap-2 px-2 items-center", className)
    }, props2), {
      children: [
        showIcon && /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(Skeleton, { className: "size-4 rounded-md", "data-sidebar": "menu-skeleton-icon" }),
        /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
          Skeleton,
          {
            className: "h-4 flex-1 max-w-[--skeleton-width]",
            "data-sidebar": "menu-skeleton-text",
            style: {
              "--skeleton-width": width
            }
          }
        )
      ]
    })
  );
});
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton";
var SidebarMenuSub = React133.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      "ul",
      __spreadValues({
        ref: ref2,
        "data-sidebar": "menu-sub",
        className: (0, import_utils45.cn)(
          "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
          "group-data-[collapsible=icon]:hidden",
          className
        )
      }, props2)
    );
  }
);
SidebarMenuSub.displayName = "SidebarMenuSub";
var SidebarMenuSubItem = React133.forwardRef((_a, ref2) => {
  var props2 = __objRest(_a, []);
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("li", __spreadValues({ ref: ref2 }, props2));
});
SidebarMenuSubItem.displayName = "SidebarMenuSubItem";
var SidebarMenuSubButton = React133.forwardRef((_a, ref2) => {
  var _b = _a, { asChild = false, size: size4 = "md", isActive: isActive2, className } = _b, props2 = __objRest(_b, ["asChild", "size", "isActive", "className"]);
  const Comp = asChild ? Slot2 : "a";
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
    Comp,
    __spreadValues({
      ref: ref2,
      "data-sidebar": "menu-sub-button",
      "data-size": size4,
      "data-active": isActive2,
      className: (0, import_utils45.cn)(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size4 === "sm" && "text-xs",
        size4 === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )
    }, props2)
  );
});
SidebarMenuSubButton.displayName = "SidebarMenuSubButton";

// src/components/slider.tsx
var React135 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-slider@1.2.2_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_qcotidl4s2cggro22nk234goim/node_modules/@radix-ui/react-slider/dist/index.mjs
var React134 = __toESM(require("react"), 1);
var import_jsx_runtime80 = require("react/jsx-runtime");
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS3 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection7, useCollection7, createCollectionScope7] = createCollection(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [
  createCollectionScope7
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider = React134.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      name,
      min: min3 = 0,
      max: max3 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min3],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form
    } = _a, sliderProps = __objRest(_a, [
      "name",
      "min",
      "max",
      "step",
      "orientation",
      "disabled",
      "minStepsBetweenThumbs",
      "defaultValue",
      "value",
      "onValueChange",
      "onValueCommit",
      "inverted",
      "form"
    ]);
    const thumbRefs = React134.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = React134.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        var _a2;
        const thumbs = [...thumbRefs.current];
        (_a2 = thumbs[valueIndexToChangeRef.current]) == null ? void 0 : _a2.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = React134.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged)
        onValueCommit(values);
    }
    function updateValues(value2, atIndex2, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min3) / step) * step + min3, decimalCount);
      const nextValue = clamp(snapToStep, [min3, max3]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex2);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit)
            onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
      SliderProvider,
      {
        scope: props2.__scopeSlider,
        name,
        disabled,
        min: min3,
        max: max3,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Collection7.Provider, { scope: props2.__scopeSlider, children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Collection7.Slot, { scope: props2.__scopeSlider, children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
          SliderOrientation,
          __spreadProps(__spreadValues({
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0
          }, sliderProps), {
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled)
                valuesBeforeSlideStartRef.current = values;
            }),
            min: min3,
            max: max3,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min3, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max3, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS3.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex2 = valueIndexToChangeRef.current;
                const value2 = values[atIndex2];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex2, { commit: true });
              }
            }
          })
        ) }) })
      }
    );
  }
);
Slider.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = React134.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      min: min3,
      max: max3,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown
    } = _a, sliderProps = __objRest(_a, [
      "min",
      "max",
      "dir",
      "inverted",
      "onSlideStart",
      "onSlideMove",
      "onSlideEnd",
      "onStepKeyDown"
    ]);
    const [slider, setSlider] = React134.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = React134.useRef(void 0);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min3, max3] : [max3, min3];
      const value = linearScale2(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
      SliderOrientationProvider,
      {
        scope: props2.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
          SliderImpl,
          __spreadProps(__spreadValues({
            dir: direction,
            "data-orientation": "horizontal"
          }, sliderProps), {
            ref: composedRefs,
            style: __spreadProps(__spreadValues({}, sliderProps.style), {
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            }),
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart == null ? void 0 : onSlideStart(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove == null ? void 0 : onSlideMove(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd == null ? void 0 : onSlideEnd();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          })
        )
      }
    );
  }
);
var SliderVertical = React134.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      min: min3,
      max: max3,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown
    } = _a, sliderProps = __objRest(_a, [
      "min",
      "max",
      "inverted",
      "onSlideStart",
      "onSlideMove",
      "onSlideEnd",
      "onStepKeyDown"
    ]);
    const sliderRef = React134.useRef(null);
    const ref2 = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = React134.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max3, min3] : [min3, max3];
      const value = linearScale2(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
      SliderOrientationProvider,
      {
        scope: props2.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
          SliderImpl,
          __spreadProps(__spreadValues({
            "data-orientation": "vertical"
          }, sliderProps), {
            ref: ref2,
            style: __spreadProps(__spreadValues({}, sliderProps.style), {
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            }),
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart == null ? void 0 : onSlideStart(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove == null ? void 0 : onSlideMove(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd == null ? void 0 : onSlideEnd();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          })
        )
      }
    );
  }
);
var SliderImpl = React134.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown
    } = _a, sliderProps = __objRest(_a, [
      "__scopeSlider",
      "onSlideStart",
      "onSlideMove",
      "onSlideEnd",
      "onHomeKeyDown",
      "onEndKeyDown",
      "onStepKeyDown"
    ]);
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
      Primitive.span,
      __spreadProps(__spreadValues({}, sliderProps), {
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS3).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props2.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props2.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId))
            onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props2.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      })
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = React134.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSlider } = _a, trackProps = __objRest(_a, ["__scopeSlider"]);
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
      Primitive.span,
      __spreadProps(__spreadValues({
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation
      }, trackProps), {
        ref: forwardedRef
      })
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = React134.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSlider } = _a, rangeProps = __objRest(_a, ["__scopeSlider"]);
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref2 = React134.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
      Primitive.span,
      __spreadProps(__spreadValues({
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0
      }, rangeProps), {
        ref: composedRefs,
        style: __spreadProps(__spreadValues({}, props2.style), {
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        })
      })
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME2 = "SliderThumb";
var SliderThumb = React134.forwardRef(
  (props2, forwardedRef) => {
    const getItems = useCollection7(props2.__scopeSlider);
    const [thumb, setThumb] = React134.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index2 = React134.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(SliderThumbImpl, __spreadProps(__spreadValues({}, props2), { ref: composedRefs, index: index2 }));
  }
);
var SliderThumbImpl = React134.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSlider, index: index2, name } = _a, thumbProps = __objRest(_a, ["__scopeSlider", "index", "name"]);
    const context = useSliderContext(THUMB_NAME2, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME2, __scopeSlider);
    const [thumb, setThumb] = React134.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size4 = useSize(thumb);
    const value = context.values[index2];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index2, context.values.length);
    const orientationSize = size4 == null ? void 0 : size4[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    React134.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Collection7.ItemSlot, { scope: props2.__scopeSlider, children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
            Primitive.span,
            __spreadProps(__spreadValues({
              role: "slider",
              "aria-label": props2["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0
            }, thumbProps), {
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props2.style,
              onFocus: composeEventHandlers(props2.onFocus, () => {
                context.valueIndexToChangeRef.current = index2;
              })
            })
          ) }),
          isFormControl && /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
            BubbleInput3,
            {
              name: name != null ? name : context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0,
              form: context.form,
              value
            },
            index2
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME2;
var BubbleInput3 = (props2) => {
  const _a = props2, { value } = _a, inputProps = __objRest(_a, ["value"]);
  const ref2 = React134.useRef(null);
  const prevValue = usePrevious(value);
  React134.useEffect(() => {
    const input = ref2.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
    const setValue = descriptor.set;
    if (prevValue !== value && setValue) {
      const event = new Event("input", { bubbles: true });
      setValue.call(input, value);
      input.dispatchEvent(event);
    }
  }, [prevValue, value]);
  return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("input", __spreadProps(__spreadValues({ style: { display: "none" } }, inputProps), { ref: ref2, defaultValue: value }));
};
function getNextSortedValues(prevValues = [], nextValue, atIndex2) {
  const nextValues = [...prevValues];
  nextValues[atIndex2] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min3, max3) {
  const maxSteps = max3 - min3;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min3);
  return clamp(percentage, [0, 100]);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1)
    return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset6 = linearScale2([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset6(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale2(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root18 = Slider;
var Track = SliderTrack;
var Range = SliderRange;
var Thumb = SliderThumb;

// src/components/slider.tsx
var import_utils46 = require("@nubras/utils");
var import_jsx_runtime81 = require("react/jsx-runtime");
var Slider2 = React135.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(
    Root18,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils46.cn)(
        "relative flex w-full touch-none select-none items-center",
        className
      )
    }, props2), {
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Track, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-secondary", children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Range, { className: "absolute h-full bg-primary" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Thumb, { className: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" })
      ]
    })
  );
});
Slider2.displayName = Root18.displayName;

// ../../node_modules/.pnpm/next-themes@0.4.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next-themes/dist/index.mjs
var t = __toESM(require("react"), 1);
var M2 = (e, i, s, u2, m2, a, l, h) => {
  let d = document.documentElement, w = ["light", "dark"];
  function p2(n3) {
    (Array.isArray(e) ? e : [e]).forEach((y) => {
      let k3 = y === "class", S2 = k3 && a ? m2.map((f) => a[f] || f) : m2;
      k3 ? (d.classList.remove(...S2), d.classList.add(a && a[n3] ? a[n3] : n3)) : d.setAttribute(y, n3);
    }), R(n3);
  }
  function R(n3) {
    h && w.includes(n3) && (d.style.colorScheme = n3);
  }
  function c() {
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  if (u2)
    p2(u2);
  else
    try {
      let n3 = localStorage.getItem(i) || s, y = l && n3 === "system" ? c() : n3;
      p2(y);
    } catch (n3) {
    }
};
var x = t.createContext(void 0);
var U3 = { setTheme: (e) => {
}, themes: [] };
var z = () => {
  var e;
  return (e = t.useContext(x)) != null ? e : U3;
};
var _ = t.memo(({ forcedTheme: e, storageKey: i, attribute: s, enableSystem: u2, enableColorScheme: m2, defaultTheme: a, value: l, themes: h, nonce: d, scriptProps: w }) => {
  let p2 = JSON.stringify([s, i, a, e, h, l, u2, m2]).slice(1, -1);
  return t.createElement("script", __spreadProps(__spreadValues({}, w), { suppressHydrationWarning: true, nonce: typeof window == "undefined" ? d : "", dangerouslySetInnerHTML: { __html: `(${M2.toString()})(${p2})` } }));
});

// ../../node_modules/.pnpm/sonner@1.7.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/sonner/dist/index.mjs
var import_react44 = __toESM(require("react"), 1);
var import_react_dom6 = __toESM(require("react-dom"), 1);
var import_react45 = __toESM(require("react"), 1);
var import_react46 = __toESM(require("react"), 1);
var import_react47 = __toESM(require("react"), 1);
var jt2 = (n3) => {
  switch (n3) {
    case "success":
      return ee2;
    case "info":
      return ae;
    case "warning":
      return oe;
    case "error":
      return se;
    default:
      return null;
  }
};
var te = Array(12).fill(0);
var Yt = ({ visible: n3, className: e }) => import_react45.default.createElement("div", { className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "), "data-visible": n3 }, import_react45.default.createElement("div", { className: "sonner-spinner" }, te.map((t2, a) => import_react45.default.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${a}` }))));
var ee2 = import_react45.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, import_react45.default.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" }));
var oe = import_react45.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, import_react45.default.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" }));
var ae = import_react45.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, import_react45.default.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" }));
var se = import_react45.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, import_react45.default.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" }));
var Ot2 = import_react45.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, import_react45.default.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), import_react45.default.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }));
var Ft = () => {
  let [n3, e] = import_react46.default.useState(document.hidden);
  return import_react46.default.useEffect(() => {
    let t2 = () => {
      e(document.hidden);
    };
    return document.addEventListener("visibilitychange", t2), () => window.removeEventListener("visibilitychange", t2);
  }, []), n3;
};
var bt2 = 1;
var yt = class {
  constructor() {
    this.subscribe = (e) => (this.subscribers.push(e), () => {
      let t2 = this.subscribers.indexOf(e);
      this.subscribers.splice(t2, 1);
    });
    this.publish = (e) => {
      this.subscribers.forEach((t2) => t2(e));
    };
    this.addToast = (e) => {
      this.publish(e), this.toasts = [...this.toasts, e];
    };
    this.create = (e) => {
      var S2;
      let _a = e, { message: t2 } = _a, a = __objRest(_a, ["message"]), u2 = typeof (e == null ? void 0 : e.id) == "number" || ((S2 = e.id) == null ? void 0 : S2.length) > 0 ? e.id : bt2++, f = this.toasts.find((g) => g.id === u2), w = e.dismissible === void 0 ? true : e.dismissible;
      return this.dismissedToasts.has(u2) && this.dismissedToasts.delete(u2), f ? this.toasts = this.toasts.map((g) => g.id === u2 ? (this.publish(__spreadProps(__spreadValues(__spreadValues({}, g), e), { id: u2, title: t2 })), __spreadProps(__spreadValues(__spreadValues({}, g), e), { id: u2, dismissible: w, title: t2 })) : g) : this.addToast(__spreadProps(__spreadValues({ title: t2 }, a), { dismissible: w, id: u2 })), u2;
    };
    this.dismiss = (e) => (this.dismissedToasts.add(e), e || this.toasts.forEach((t2) => {
      this.subscribers.forEach((a) => a({ id: t2.id, dismiss: true }));
    }), this.subscribers.forEach((t2) => t2({ id: e, dismiss: true })), e);
    this.message = (e, t2) => this.create(__spreadProps(__spreadValues({}, t2), { message: e }));
    this.error = (e, t2) => this.create(__spreadProps(__spreadValues({}, t2), { message: e, type: "error" }));
    this.success = (e, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "success", message: e }));
    this.info = (e, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "info", message: e }));
    this.warning = (e, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "warning", message: e }));
    this.loading = (e, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "loading", message: e }));
    this.promise = (e, t2) => {
      if (!t2)
        return;
      let a;
      t2.loading !== void 0 && (a = this.create(__spreadProps(__spreadValues({}, t2), { promise: e, type: "loading", message: t2.loading, description: typeof t2.description != "function" ? t2.description : void 0 })));
      let u2 = e instanceof Promise ? e : e(), f = a !== void 0, w, S2 = u2.then((i) => __async(this, null, function* () {
        if (w = ["resolve", i], import_react47.default.isValidElement(i))
          f = false, this.create({ id: a, type: "default", message: i });
        else if (ie(i) && !i.ok) {
          f = false;
          let T2 = typeof t2.error == "function" ? yield t2.error(`HTTP error! status: ${i.status}`) : t2.error, F = typeof t2.description == "function" ? yield t2.description(`HTTP error! status: ${i.status}`) : t2.description;
          this.create({ id: a, type: "error", message: T2, description: F });
        } else if (t2.success !== void 0) {
          f = false;
          let T2 = typeof t2.success == "function" ? yield t2.success(i) : t2.success, F = typeof t2.description == "function" ? yield t2.description(i) : t2.description;
          this.create({ id: a, type: "success", message: T2, description: F });
        }
      })).catch((i) => __async(this, null, function* () {
        if (w = ["reject", i], t2.error !== void 0) {
          f = false;
          let D2 = typeof t2.error == "function" ? yield t2.error(i) : t2.error, T2 = typeof t2.description == "function" ? yield t2.description(i) : t2.description;
          this.create({ id: a, type: "error", message: D2, description: T2 });
        }
      })).finally(() => {
        var i;
        f && (this.dismiss(a), a = void 0), (i = t2.finally) == null || i.call(t2);
      }), g = () => new Promise((i, D2) => S2.then(() => w[0] === "reject" ? D2(w[1]) : i(w[1])).catch(D2));
      return typeof a != "string" && typeof a != "number" ? { unwrap: g } : Object.assign(a, { unwrap: g });
    };
    this.custom = (e, t2) => {
      let a = (t2 == null ? void 0 : t2.id) || bt2++;
      return this.create(__spreadValues({ jsx: e(a), id: a }, t2)), a;
    };
    this.getActiveToasts = () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
var v = new yt();
var ne = (n3, e) => {
  let t2 = (e == null ? void 0 : e.id) || bt2++;
  return v.addToast(__spreadProps(__spreadValues({ title: n3 }, e), { id: t2 })), t2;
};
var ie = (n3) => n3 && typeof n3 == "object" && "ok" in n3 && typeof n3.ok == "boolean" && "status" in n3 && typeof n3.status == "number";
var le2 = ne;
var ce = () => v.toasts;
var de2 = () => v.getActiveToasts();
var ue2 = Object.assign(le2, { success: v.success, info: v.info, warning: v.warning, error: v.error, custom: v.custom, message: v.message, promise: v.promise, dismiss: v.dismiss, loading: v.loading }, { getHistory: ce, getToasts: de2 });
function wt2(n3, { insertAt: e } = {}) {
  if (!n3 || typeof document == "undefined")
    return;
  let t2 = document.head || document.getElementsByTagName("head")[0], a = document.createElement("style");
  a.type = "text/css", e === "top" && t2.firstChild ? t2.insertBefore(a, t2.firstChild) : t2.appendChild(a), a.styleSheet ? a.styleSheet.cssText = n3 : a.appendChild(document.createTextNode(n3));
}
wt2(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function tt(n3) {
  return n3.label !== void 0;
}
var pe2 = 3;
var me2 = "32px";
var ge = "16px";
var Wt = 4e3;
var he2 = 356;
var be2 = 14;
var ye2 = 20;
var we2 = 200;
function M3(...n3) {
  return n3.filter(Boolean).join(" ");
}
function xe2(n3) {
  let [e, t2] = n3.split("-"), a = [];
  return e && a.push(e), t2 && a.push(t2), a;
}
var ve2 = (n3) => {
  var Dt, Pt2, Nt2, Bt2, Ct, kt2, It, Mt, Ht, At2, Lt2;
  let { invert: e, toast: t2, unstyled: a, interacting: u2, setHeights: f, visibleToasts: w, heights: S2, index: g, toasts: i, expanded: D2, removeToast: T2, defaultRichColors: F, closeButton: et, style: ut, cancelButtonStyle: ft, actionButtonStyle: l, className: ot = "", descriptionClassName: at = "", duration: X3, position: st, gap: pt, loadingIcon: rt, expandByDefault: B2, classNames: s, icons: P, closeButtonAriaLabel: nt = "Close toast", pauseWhenPageIsHidden: it } = n3, [Y4, C] = import_react44.default.useState(null), [lt, J2] = import_react44.default.useState(null), [W2, H2] = import_react44.default.useState(false), [A, mt] = import_react44.default.useState(false), [L, z2] = import_react44.default.useState(false), [ct, d] = import_react44.default.useState(false), [h, y] = import_react44.default.useState(false), [R, j2] = import_react44.default.useState(0), [p2, _2] = import_react44.default.useState(0), O = import_react44.default.useRef(t2.duration || X3 || Wt), G3 = import_react44.default.useRef(null), k3 = import_react44.default.useRef(null), Vt = g === 0, Ut = g + 1 <= w, N2 = t2.type, V = t2.dismissible !== false, Kt = t2.className || "", Xt = t2.descriptionClassName || "", dt = import_react44.default.useMemo(() => S2.findIndex((r2) => r2.toastId === t2.id) || 0, [S2, t2.id]), Jt = import_react44.default.useMemo(() => {
    var r2;
    return (r2 = t2.closeButton) != null ? r2 : et;
  }, [t2.closeButton, et]), Tt2 = import_react44.default.useMemo(() => t2.duration || X3 || Wt, [t2.duration, X3]), gt2 = import_react44.default.useRef(0), U4 = import_react44.default.useRef(0), St2 = import_react44.default.useRef(0), K3 = import_react44.default.useRef(null), [Gt2, Qt] = st.split("-"), Rt = import_react44.default.useMemo(() => S2.reduce((r2, m2, c) => c >= dt ? r2 : r2 + m2.height, 0), [S2, dt]), Et2 = Ft(), qt = t2.invert || e, ht2 = N2 === "loading";
  U4.current = import_react44.default.useMemo(() => dt * pt + Rt, [dt, Rt]), import_react44.default.useEffect(() => {
    O.current = Tt2;
  }, [Tt2]), import_react44.default.useEffect(() => {
    H2(true);
  }, []), import_react44.default.useEffect(() => {
    let r2 = k3.current;
    if (r2) {
      let m2 = r2.getBoundingClientRect().height;
      return _2(m2), f((c) => [{ toastId: t2.id, height: m2, position: t2.position }, ...c]), () => f((c) => c.filter((b) => b.toastId !== t2.id));
    }
  }, [f, t2.id]), import_react44.default.useLayoutEffect(() => {
    if (!W2)
      return;
    let r2 = k3.current, m2 = r2.style.height;
    r2.style.height = "auto";
    let c = r2.getBoundingClientRect().height;
    r2.style.height = m2, _2(c), f((b) => b.find((x2) => x2.toastId === t2.id) ? b.map((x2) => x2.toastId === t2.id ? __spreadProps(__spreadValues({}, x2), { height: c }) : x2) : [{ toastId: t2.id, height: c, position: t2.position }, ...b]);
  }, [W2, t2.title, t2.description, f, t2.id]);
  let $3 = import_react44.default.useCallback(() => {
    mt(true), j2(U4.current), f((r2) => r2.filter((m2) => m2.toastId !== t2.id)), setTimeout(() => {
      T2(t2);
    }, we2);
  }, [t2, T2, f, U4]);
  import_react44.default.useEffect(() => {
    if (t2.promise && N2 === "loading" || t2.duration === 1 / 0 || t2.type === "loading")
      return;
    let r2;
    return D2 || u2 || it && Et2 ? (() => {
      if (St2.current < gt2.current) {
        let b = (/* @__PURE__ */ new Date()).getTime() - gt2.current;
        O.current = O.current - b;
      }
      St2.current = (/* @__PURE__ */ new Date()).getTime();
    })() : (() => {
      O.current !== 1 / 0 && (gt2.current = (/* @__PURE__ */ new Date()).getTime(), r2 = setTimeout(() => {
        var b;
        (b = t2.onAutoClose) == null || b.call(t2, t2), $3();
      }, O.current));
    })(), () => clearTimeout(r2);
  }, [D2, u2, t2, N2, it, Et2, $3]), import_react44.default.useEffect(() => {
    t2.delete && $3();
  }, [$3, t2.delete]);
  function Zt() {
    var r2, m2, c;
    return P != null && P.loading ? import_react44.default.createElement("div", { className: M3(s == null ? void 0 : s.loader, (r2 = t2 == null ? void 0 : t2.classNames) == null ? void 0 : r2.loader, "sonner-loader"), "data-visible": N2 === "loading" }, P.loading) : rt ? import_react44.default.createElement("div", { className: M3(s == null ? void 0 : s.loader, (m2 = t2 == null ? void 0 : t2.classNames) == null ? void 0 : m2.loader, "sonner-loader"), "data-visible": N2 === "loading" }, rt) : import_react44.default.createElement(Yt, { className: M3(s == null ? void 0 : s.loader, (c = t2 == null ? void 0 : t2.classNames) == null ? void 0 : c.loader), visible: N2 === "loading" });
  }
  return import_react44.default.createElement("li", { tabIndex: 0, ref: k3, className: M3(ot, Kt, s == null ? void 0 : s.toast, (Dt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Dt.toast, s == null ? void 0 : s.default, s == null ? void 0 : s[N2], (Pt2 = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Pt2[N2]), "data-sonner-toast": "", "data-rich-colors": (Nt2 = t2.richColors) != null ? Nt2 : F, "data-styled": !(t2.jsx || t2.unstyled || a), "data-mounted": W2, "data-promise": !!t2.promise, "data-swiped": h, "data-removed": A, "data-visible": Ut, "data-y-position": Gt2, "data-x-position": Qt, "data-index": g, "data-front": Vt, "data-swiping": L, "data-dismissible": V, "data-type": N2, "data-invert": qt, "data-swipe-out": ct, "data-swipe-direction": lt, "data-expanded": !!(D2 || B2 && W2), style: __spreadValues(__spreadValues({ "--index": g, "--toasts-before": g, "--z-index": i.length - g, "--offset": `${A ? R : U4.current}px`, "--initial-height": B2 ? "auto" : `${p2}px` }, ut), t2.style), onDragEnd: () => {
    z2(false), C(null), K3.current = null;
  }, onPointerDown: (r2) => {
    ht2 || !V || (G3.current = /* @__PURE__ */ new Date(), j2(U4.current), r2.target.setPointerCapture(r2.pointerId), r2.target.tagName !== "BUTTON" && (z2(true), K3.current = { x: r2.clientX, y: r2.clientY }));
  }, onPointerUp: () => {
    var x2, Q2, q, Z2;
    if (ct || !V)
      return;
    K3.current = null;
    let r2 = Number(((x2 = k3.current) == null ? void 0 : x2.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), m2 = Number(((Q2 = k3.current) == null ? void 0 : Q2.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), c = (/* @__PURE__ */ new Date()).getTime() - ((q = G3.current) == null ? void 0 : q.getTime()), b = Y4 === "x" ? r2 : m2, I2 = Math.abs(b) / c;
    if (Math.abs(b) >= ye2 || I2 > 0.11) {
      j2(U4.current), (Z2 = t2.onDismiss) == null || Z2.call(t2, t2), J2(Y4 === "x" ? r2 > 0 ? "right" : "left" : m2 > 0 ? "down" : "up"), $3(), d(true), y(false);
      return;
    }
    z2(false), C(null);
  }, onPointerMove: (r2) => {
    var Q2, q, Z2, zt;
    if (!K3.current || !V || ((Q2 = window.getSelection()) == null ? void 0 : Q2.toString().length) > 0)
      return;
    let c = r2.clientY - K3.current.y, b = r2.clientX - K3.current.x, I2 = (q = n3.swipeDirections) != null ? q : xe2(st);
    !Y4 && (Math.abs(b) > 1 || Math.abs(c) > 1) && C(Math.abs(b) > Math.abs(c) ? "x" : "y");
    let x2 = { x: 0, y: 0 };
    Y4 === "y" ? (I2.includes("top") || I2.includes("bottom")) && (I2.includes("top") && c < 0 || I2.includes("bottom") && c > 0) && (x2.y = c) : Y4 === "x" && (I2.includes("left") || I2.includes("right")) && (I2.includes("left") && b < 0 || I2.includes("right") && b > 0) && (x2.x = b), (Math.abs(x2.x) > 0 || Math.abs(x2.y) > 0) && y(true), (Z2 = k3.current) == null || Z2.style.setProperty("--swipe-amount-x", `${x2.x}px`), (zt = k3.current) == null || zt.style.setProperty("--swipe-amount-y", `${x2.y}px`);
  } }, Jt && !t2.jsx ? import_react44.default.createElement("button", { "aria-label": nt, "data-disabled": ht2, "data-close-button": true, onClick: ht2 || !V ? () => {
  } : () => {
    var r2;
    $3(), (r2 = t2.onDismiss) == null || r2.call(t2, t2);
  }, className: M3(s == null ? void 0 : s.closeButton, (Bt2 = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Bt2.closeButton) }, (Ct = P == null ? void 0 : P.close) != null ? Ct : Ot2) : null, t2.jsx || (0, import_react44.isValidElement)(t2.title) ? t2.jsx ? t2.jsx : typeof t2.title == "function" ? t2.title() : t2.title : import_react44.default.createElement(import_react44.default.Fragment, null, N2 || t2.icon || t2.promise ? import_react44.default.createElement("div", { "data-icon": "", className: M3(s == null ? void 0 : s.icon, (kt2 = t2 == null ? void 0 : t2.classNames) == null ? void 0 : kt2.icon) }, t2.promise || t2.type === "loading" && !t2.icon ? t2.icon || Zt() : null, t2.type !== "loading" ? t2.icon || (P == null ? void 0 : P[N2]) || jt2(N2) : null) : null, import_react44.default.createElement("div", { "data-content": "", className: M3(s == null ? void 0 : s.content, (It = t2 == null ? void 0 : t2.classNames) == null ? void 0 : It.content) }, import_react44.default.createElement("div", { "data-title": "", className: M3(s == null ? void 0 : s.title, (Mt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Mt.title) }, typeof t2.title == "function" ? t2.title() : t2.title), t2.description ? import_react44.default.createElement("div", { "data-description": "", className: M3(at, Xt, s == null ? void 0 : s.description, (Ht = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Ht.description) }, typeof t2.description == "function" ? t2.description() : t2.description) : null), (0, import_react44.isValidElement)(t2.cancel) ? t2.cancel : t2.cancel && tt(t2.cancel) ? import_react44.default.createElement("button", { "data-button": true, "data-cancel": true, style: t2.cancelButtonStyle || ft, onClick: (r2) => {
    var m2, c;
    tt(t2.cancel) && V && ((c = (m2 = t2.cancel).onClick) == null || c.call(m2, r2), $3());
  }, className: M3(s == null ? void 0 : s.cancelButton, (At2 = t2 == null ? void 0 : t2.classNames) == null ? void 0 : At2.cancelButton) }, t2.cancel.label) : null, (0, import_react44.isValidElement)(t2.action) ? t2.action : t2.action && tt(t2.action) ? import_react44.default.createElement("button", { "data-button": true, "data-action": true, style: t2.actionButtonStyle || l, onClick: (r2) => {
    var m2, c;
    tt(t2.action) && ((c = (m2 = t2.action).onClick) == null || c.call(m2, r2), !r2.defaultPrevented && $3());
  }, className: M3(s == null ? void 0 : s.actionButton, (Lt2 = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Lt2.actionButton) }, t2.action.label) : null));
};
function _t2() {
  if (typeof window == "undefined" || typeof document == "undefined")
    return "ltr";
  let n3 = document.documentElement.getAttribute("dir");
  return n3 === "auto" || !n3 ? window.getComputedStyle(document.documentElement).direction : n3;
}
function Te2(n3, e) {
  let t2 = {};
  return [n3, e].forEach((a, u2) => {
    let f = u2 === 1, w = f ? "--mobile-offset" : "--offset", S2 = f ? ge : me2;
    function g(i) {
      ["top", "right", "bottom", "left"].forEach((D2) => {
        t2[`${w}-${D2}`] = typeof i == "number" ? `${i}px` : i;
      });
    }
    typeof a == "number" || typeof a == "string" ? g(a) : typeof a == "object" ? ["top", "right", "bottom", "left"].forEach((i) => {
      a[i] === void 0 ? t2[`${w}-${i}`] = S2 : t2[`${w}-${i}`] = typeof a[i] == "number" ? `${a[i]}px` : a[i];
    }) : g(S2);
  }), t2;
}
var $e = (0, import_react44.forwardRef)(function(e, t2) {
  let { invert: a, position: u2 = "bottom-right", hotkey: f = ["altKey", "KeyT"], expand: w, closeButton: S2, className: g, offset: i, mobileOffset: D2, theme: T2 = "light", richColors: F, duration: et, style: ut, visibleToasts: ft = pe2, toastOptions: l, dir: ot = _t2(), gap: at = be2, loadingIcon: X3, icons: st, containerAriaLabel: pt = "Notifications", pauseWhenPageIsHidden: rt } = e, [B2, s] = import_react44.default.useState([]), P = import_react44.default.useMemo(() => Array.from(new Set([u2].concat(B2.filter((d) => d.position).map((d) => d.position)))), [B2, u2]), [nt, it] = import_react44.default.useState([]), [Y4, C] = import_react44.default.useState(false), [lt, J2] = import_react44.default.useState(false), [W2, H2] = import_react44.default.useState(T2 !== "system" ? T2 : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), A = import_react44.default.useRef(null), mt = f.join("+").replace(/Key/g, "").replace(/Digit/g, ""), L = import_react44.default.useRef(null), z2 = import_react44.default.useRef(false), ct = import_react44.default.useCallback((d) => {
    s((h) => {
      var y;
      return (y = h.find((R) => R.id === d.id)) != null && y.delete || v.dismiss(d.id), h.filter(({ id: R }) => R !== d.id);
    });
  }, []);
  return import_react44.default.useEffect(() => v.subscribe((d) => {
    if (d.dismiss) {
      s((h) => h.map((y) => y.id === d.id ? __spreadProps(__spreadValues({}, y), { delete: true }) : y));
      return;
    }
    setTimeout(() => {
      import_react_dom6.default.flushSync(() => {
        s((h) => {
          let y = h.findIndex((R) => R.id === d.id);
          return y !== -1 ? [...h.slice(0, y), __spreadValues(__spreadValues({}, h[y]), d), ...h.slice(y + 1)] : [d, ...h];
        });
      });
    });
  }), []), import_react44.default.useEffect(() => {
    if (T2 !== "system") {
      H2(T2);
      return;
    }
    if (T2 === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? H2("dark") : H2("light")), typeof window == "undefined")
      return;
    let d = window.matchMedia("(prefers-color-scheme: dark)");
    try {
      d.addEventListener("change", ({ matches: h }) => {
        H2(h ? "dark" : "light");
      });
    } catch (h) {
      d.addListener(({ matches: y }) => {
        try {
          H2(y ? "dark" : "light");
        } catch (R) {
          console.error(R);
        }
      });
    }
  }, [T2]), import_react44.default.useEffect(() => {
    B2.length <= 1 && C(false);
  }, [B2]), import_react44.default.useEffect(() => {
    let d = (h) => {
      var R, j2;
      f.every((p2) => h[p2] || h.code === p2) && (C(true), (R = A.current) == null || R.focus()), h.code === "Escape" && (document.activeElement === A.current || (j2 = A.current) != null && j2.contains(document.activeElement)) && C(false);
    };
    return document.addEventListener("keydown", d), () => document.removeEventListener("keydown", d);
  }, [f]), import_react44.default.useEffect(() => {
    if (A.current)
      return () => {
        L.current && (L.current.focus({ preventScroll: true }), L.current = null, z2.current = false);
      };
  }, [A.current]), import_react44.default.createElement("section", { ref: t2, "aria-label": `${pt} ${mt}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: true }, P.map((d, h) => {
    var j2;
    let [y, R] = d.split("-");
    return B2.length ? import_react44.default.createElement("ol", { key: d, dir: ot === "auto" ? _t2() : ot, tabIndex: -1, ref: A, className: g, "data-sonner-toaster": true, "data-theme": W2, "data-y-position": y, "data-lifted": Y4 && B2.length > 1 && !w, "data-x-position": R, style: __spreadValues(__spreadValues({ "--front-toast-height": `${((j2 = nt[0]) == null ? void 0 : j2.height) || 0}px`, "--width": `${he2}px`, "--gap": `${at}px` }, ut), Te2(i, D2)), onBlur: (p2) => {
      z2.current && !p2.currentTarget.contains(p2.relatedTarget) && (z2.current = false, L.current && (L.current.focus({ preventScroll: true }), L.current = null));
    }, onFocus: (p2) => {
      p2.target instanceof HTMLElement && p2.target.dataset.dismissible === "false" || z2.current || (z2.current = true, L.current = p2.relatedTarget);
    }, onMouseEnter: () => C(true), onMouseMove: () => C(true), onMouseLeave: () => {
      lt || C(false);
    }, onDragEnd: () => C(false), onPointerDown: (p2) => {
      p2.target instanceof HTMLElement && p2.target.dataset.dismissible === "false" || J2(true);
    }, onPointerUp: () => J2(false) }, B2.filter((p2) => !p2.position && h === 0 || p2.position === d).map((p2, _2) => {
      var O, G3;
      return import_react44.default.createElement(ve2, { key: p2.id, icons: st, index: _2, toast: p2, defaultRichColors: F, duration: (O = l == null ? void 0 : l.duration) != null ? O : et, className: l == null ? void 0 : l.className, descriptionClassName: l == null ? void 0 : l.descriptionClassName, invert: a, visibleToasts: ft, closeButton: (G3 = l == null ? void 0 : l.closeButton) != null ? G3 : S2, interacting: lt, position: d, style: l == null ? void 0 : l.style, unstyled: l == null ? void 0 : l.unstyled, classNames: l == null ? void 0 : l.classNames, cancelButtonStyle: l == null ? void 0 : l.cancelButtonStyle, actionButtonStyle: l == null ? void 0 : l.actionButtonStyle, removeToast: ct, toasts: B2.filter((k3) => k3.position == p2.position), heights: nt.filter((k3) => k3.position == p2.position), setHeights: it, expandByDefault: w, gap: at, loadingIcon: X3, expanded: Y4, pauseWhenPageIsHidden: rt, swipeDirections: e.swipeDirections });
    })) : null;
  }));
});

// src/components/sonner.tsx
var import_jsx_runtime82 = require("react/jsx-runtime");
var Toaster = (_a) => {
  var props2 = __objRest(_a, []);
  const { theme = "system" } = z();
  return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
    $e,
    __spreadValues({
      theme,
      className: "toaster group",
      toastOptions: {
        classNames: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, props2)
  );
};

// src/components/switch.tsx
var React139 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-switch@1.2.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_bpziggcvedzzwtlg4kl3b5o32a/node_modules/@radix-ui/react-switch/dist/index.mjs
var React138 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-use-previous@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-previous/dist/index.mjs
var React136 = __toESM(require("react"), 1);
function usePrevious3(value) {
  const ref2 = React136.useRef({ value, previous: value });
  return React136.useMemo(() => {
    if (ref2.current.value !== value) {
      ref2.current.previous = ref2.current.value;
      ref2.current.value = value;
    }
    return ref2.current.previous;
  }, [value]);
}

// ../../node_modules/.pnpm/@radix-ui+react-use-size@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-use-size/dist/index.mjs
var React137 = __toESM(require("react"), 1);
function useSize2(element) {
  const [size4, setSize] = React137.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// ../../node_modules/.pnpm/@radix-ui+react-switch@1.2.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_bpziggcvedzzwtlg4kl3b5o32a/node_modules/@radix-ui/react-switch/dist/index.mjs
var import_jsx_runtime83 = require("react/jsx-runtime");
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope2(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch = React138.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeSwitch,
      name,
      checked: checkedProp,
      defaultChecked,
      required: required2,
      disabled,
      value = "on",
      onCheckedChange,
      form
    } = _a, switchProps = __objRest(_a, [
      "__scopeSwitch",
      "name",
      "checked",
      "defaultChecked",
      "required",
      "disabled",
      "value",
      "onCheckedChange",
      "form"
    ]);
    const [button, setButton] = React138.useState(null);
    const composedRefs = useComposedRefs2(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React138.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState2({
      prop: checkedProp,
      defaultProp: defaultChecked != null ? defaultChecked : false,
      onChange: onCheckedChange,
      caller: SWITCH_NAME
    });
    return /* @__PURE__ */ (0, import_jsx_runtime83.jsxs)(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
        Primitive2.button,
        __spreadProps(__spreadValues({
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required2,
          "data-state": getState8(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value
        }, switchProps), {
          ref: composedRefs,
          onClick: composeEventHandlers2(props2.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        })
      ),
      isFormControl && /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
        SwitchBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required: required2,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch.displayName = SWITCH_NAME;
var THUMB_NAME3 = "SwitchThumb";
var SwitchThumb = React138.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeSwitch } = _a, thumbProps = __objRest(_a, ["__scopeSwitch"]);
    const context = useSwitchContext(THUMB_NAME3, __scopeSwitch);
    return /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
      Primitive2.span,
      __spreadProps(__spreadValues({
        "data-state": getState8(context.checked),
        "data-disabled": context.disabled ? "" : void 0
      }, thumbProps), {
        ref: forwardedRef
      })
    );
  }
);
SwitchThumb.displayName = THUMB_NAME3;
var BUBBLE_INPUT_NAME = "SwitchBubbleInput";
var SwitchBubbleInput = React138.forwardRef(
  (_a, forwardedRef) => {
    var _b = _a, {
      __scopeSwitch,
      control,
      checked,
      bubbles = true
    } = _b, props2 = __objRest(_b, [
      "__scopeSwitch",
      "control",
      "checked",
      "bubbles"
    ]);
    const ref2 = React138.useRef(null);
    const composedRefs = useComposedRefs2(ref2, forwardedRef);
    const prevChecked = usePrevious3(checked);
    const controlSize = useSize2(control);
    React138.useEffect(() => {
      const input = ref2.current;
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
      "input",
      __spreadProps(__spreadValues({
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked
      }, props2), {
        tabIndex: -1,
        ref: composedRefs,
        style: __spreadProps(__spreadValues(__spreadValues({}, props2.style), controlSize), {
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      })
    );
  }
);
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME;
function getState8(checked) {
  return checked ? "checked" : "unchecked";
}
var Root19 = Switch;
var Thumb2 = SwitchThumb;

// src/components/switch.tsx
var import_utils47 = require("@nubras/utils");
var import_jsx_runtime84 = require("react/jsx-runtime");
var Switch2 = React139.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
    Root19,
    __spreadProps(__spreadValues({
      className: (0, import_utils47.cn)(
        "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
        className
      )
    }, props2), {
      ref: ref2,
      children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
        Thumb2,
        {
          className: (0, import_utils47.cn)(
            "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
          )
        }
      )
    })
  );
});
Switch2.displayName = Root19.displayName;

// src/components/table.tsx
var React140 = __toESM(require("react"));
var import_utils48 = require("@nubras/utils");
var import_jsx_runtime85 = require("react/jsx-runtime");
var Table = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("table", __spreadValues({ ref: ref2, className: (0, import_utils48.cn)("w-full caption-bottom text-sm", className) }, props2)) });
  }
);
Table.displayName = "Table";
var TableHeader = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("thead", __spreadValues({ ref: ref2, className: (0, import_utils48.cn)("[&_tr]:border-b", className) }, props2));
  }
);
TableHeader.displayName = "TableHeader";
var TableBody = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("tbody", __spreadValues({ ref: ref2, className: (0, import_utils48.cn)("[&_tr:last-child]:border-0", className) }, props2));
  }
);
TableBody.displayName = "TableBody";
var TableFooter = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("tfoot", __spreadValues({ ref: ref2, className: (0, import_utils48.cn)("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className) }, props2));
  }
);
TableFooter.displayName = "TableFooter";
var TableRow = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(
      "tr",
      __spreadValues({
        ref: ref2,
        className: (0, import_utils48.cn)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className)
      }, props2)
    );
  }
);
TableRow.displayName = "TableRow";
var TableHead = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(
      "th",
      __spreadValues({
        ref: ref2,
        className: (0, import_utils48.cn)(
          "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
          className
        )
      }, props2)
    );
  }
);
TableHead.displayName = "TableHead";
var TableCell = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("td", __spreadValues({ ref: ref2, className: (0, import_utils48.cn)("p-4 align-middle [&:has([role=checkbox])]:pr-0", className) }, props2));
  }
);
TableCell.displayName = "TableCell";
var TableCaption = React140.forwardRef(
  (_a, ref2) => {
    var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("caption", __spreadValues({ ref: ref2, className: (0, import_utils48.cn)("mt-4 text-sm text-muted-foreground", className) }, props2));
  }
);
TableCaption.displayName = "TableCaption";

// src/components/tabs.tsx
var React145 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-tabs@1.1.11_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3__z7n2ihnhv7q37ih6qizxp5vlei/node_modules/@radix-ui/react-tabs/dist/index.mjs
var React144 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-roving-focus@1.1.9_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_exusxoa2i6cwic3sydwmtmvtmi/node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React143 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-collection@1.1.6_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19_vgr2bpzr2a6pqxnqimgx35v6zm/node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react48 = __toESM(require("react"), 1);
var import_jsx_runtime86 = require("react/jsx-runtime");
var import_react49 = __toESM(require("react"), 1);
var import_jsx_runtime87 = require("react/jsx-runtime");
function createCollection2(name) {
  const PROVIDER_NAME3 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope10] = createContextScope2(PROVIDER_NAME3);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME3,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props2) => {
    const { scope, children } = props2;
    const ref2 = import_react48.default.useRef(null);
    const itemMap = import_react48.default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref2, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME3;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react48.default.forwardRef(
    (props2, forwardedRef) => {
      const { scope, children } = props2;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs2(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react48.default.forwardRef(
    (props2, forwardedRef) => {
      const _a = props2, { scope, children } = _a, itemData = __objRest(_a, ["scope", "children"]);
      const ref2 = import_react48.default.useRef(null);
      const composedRefs = useComposedRefs2(forwardedRef, ref2);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react48.default.useEffect(() => {
        context.itemMap.set(ref2, __spreadValues({ ref: ref2 }, itemData));
        return () => void context.itemMap.delete(ref2);
      });
      return /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(CollectionItemSlotImpl, __spreadProps(__spreadValues({}, { [ITEM_DATA_ATTR]: "" }), { ref: composedRefs, children }));
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection10(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react48.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection10,
    createCollectionScope10
  ];
}

// ../../node_modules/.pnpm/@radix-ui+react-direction@1.1.1_@types+react@19.1.3_react@19.1.0/node_modules/@radix-ui/react-direction/dist/index.mjs
var React142 = __toESM(require("react"), 1);
var import_jsx_runtime88 = require("react/jsx-runtime");
var DirectionContext2 = React142.createContext(void 0);
function useDirection2(localDir) {
  const globalDir = React142.useContext(DirectionContext2);
  return localDir || globalDir || "ltr";
}

// ../../node_modules/.pnpm/@radix-ui+react-roving-focus@1.1.9_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_exusxoa2i6cwic3sydwmtmvtmi/node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var import_jsx_runtime89 = require("react/jsx-runtime");
var ENTRY_FOCUS2 = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS4 = { bubbles: false, cancelable: true };
var GROUP_NAME7 = "RovingFocusGroup";
var [Collection8, useCollection8, createCollectionScope8] = createCollection2(GROUP_NAME7);
var [createRovingFocusGroupContext2, createRovingFocusGroupScope2] = createContextScope2(
  GROUP_NAME7,
  [createCollectionScope8]
);
var [RovingFocusProvider2, useRovingFocusContext2] = createRovingFocusGroupContext2(GROUP_NAME7);
var RovingFocusGroup2 = React143.forwardRef(
  (props2, forwardedRef) => {
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Collection8.Provider, { scope: props2.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Collection8.Slot, { scope: props2.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(RovingFocusGroupImpl2, __spreadProps(__spreadValues({}, props2), { ref: forwardedRef })) }) });
  }
);
RovingFocusGroup2.displayName = GROUP_NAME7;
var RovingFocusGroupImpl2 = React143.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false
  } = _a, groupProps = __objRest(_a, [
    "__scopeRovingFocusGroup",
    "orientation",
    "loop",
    "dir",
    "currentTabStopId",
    "defaultCurrentTabStopId",
    "onCurrentTabStopIdChange",
    "onEntryFocus",
    "preventScrollOnEntryFocus"
  ]);
  const ref2 = React143.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, ref2);
  const direction = useDirection2(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState2({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId != null ? defaultCurrentTabStopId : null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME7
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React143.useState(false);
  const handleEntryFocus = useCallbackRef3(onEntryFocus);
  const getItems = useCollection8(__scopeRovingFocusGroup);
  const isClickFocusRef = React143.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React143.useState(0);
  React143.useEffect(() => {
    const node = ref2.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS2, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS2, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
    RovingFocusProvider2,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React143.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React143.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React143.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React143.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
        Primitive2.div,
        __spreadProps(__spreadValues({
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation
        }, groupProps), {
          ref: composedRefs,
          style: __spreadValues({ outline: "none" }, props2.style),
          onMouseDown: composeEventHandlers2(props2.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers2(props2.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS2, EVENT_OPTIONS4);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst6(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers2(props2.onBlur, () => setIsTabbingBackOut(false))
        })
      )
    }
  );
});
var ITEM_NAME10 = "RovingFocusGroupItem";
var RovingFocusGroupItem2 = React143.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children
    } = _a, itemProps = __objRest(_a, [
      "__scopeRovingFocusGroup",
      "focusable",
      "active",
      "tabStopId",
      "children"
    ]);
    const autoId = useId2();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext2(ITEM_NAME10, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection8(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React143.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
      Collection8.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
          Primitive2.span,
          __spreadProps(__spreadValues({
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation
          }, itemProps), {
            ref: forwardedRef,
            onMouseDown: composeEventHandlers2(props2.onMouseDown, (event) => {
              if (!focusable)
                event.preventDefault();
              else
                context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers2(props2.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers2(props2.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget)
                return;
              const focusIntent = getFocusIntent2(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
                  return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last")
                  candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev")
                    candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray5(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst6(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          })
        )
      }
    );
  }
);
RovingFocusGroupItem2.displayName = ITEM_NAME10;
var MAP_KEY_TO_FOCUS_INTENT2 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey2(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent2(event, orientation, dir) {
  const key = getDirectionAwareKey2(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT2[key];
}
function focusFirst6(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray5(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root20 = RovingFocusGroup2;
var Item5 = RovingFocusGroupItem2;

// ../../node_modules/.pnpm/@radix-ui+react-tabs@1.1.11_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3__z7n2ihnhv7q37ih6qizxp5vlei/node_modules/@radix-ui/react-tabs/dist/index.mjs
var import_jsx_runtime90 = require("react/jsx-runtime");
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope2(TABS_NAME, [
  createRovingFocusGroupScope2
]);
var useRovingFocusGroupScope4 = createRovingFocusGroupScope2();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs = React144.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic"
    } = _a, tabsProps = __objRest(_a, [
      "__scopeTabs",
      "value",
      "onValueChange",
      "defaultValue",
      "orientation",
      "dir",
      "activationMode"
    ]);
    const direction = useDirection2(dir);
    const [value, setValue] = useControllableState2({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue != null ? defaultValue : "",
      caller: TABS_NAME
    });
    return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId2(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
          Primitive2.div,
          __spreadProps(__spreadValues({
            dir: direction,
            "data-orientation": orientation
          }, tabsProps), {
            ref: forwardedRef
          })
        )
      }
    );
  }
);
Tabs.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList = React144.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeTabs, loop = true } = _a, listProps = __objRest(_a, ["__scopeTabs", "loop"]);
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeTabs);
    return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      Root20,
      __spreadProps(__spreadValues({
        asChild: true
      }, rovingFocusGroupScope), {
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
          Primitive2.div,
          __spreadProps(__spreadValues({
            role: "tablist",
            "aria-orientation": context.orientation
          }, listProps), {
            ref: forwardedRef
          })
        )
      })
    );
  }
);
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME14 = "TabsTrigger";
var TabsTrigger = React144.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeTabs, value, disabled = false } = _a, triggerProps = __objRest(_a, ["__scopeTabs", "value", "disabled"]);
    const context = useTabsContext(TRIGGER_NAME14, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeTabs);
    const triggerId = makeTriggerId2(context.baseId, value);
    const contentId = makeContentId2(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      Item5,
      __spreadProps(__spreadValues({
        asChild: true
      }, rovingFocusGroupScope), {
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
          Primitive2.button,
          __spreadProps(__spreadValues({
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId
          }, triggerProps), {
            ref: forwardedRef,
            onMouseDown: composeEventHandlers2(props2.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers2(props2.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key))
                context.onValueChange(value);
            }),
            onFocus: composeEventHandlers2(props2.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          })
        )
      })
    );
  }
);
TabsTrigger.displayName = TRIGGER_NAME14;
var CONTENT_NAME16 = "TabsContent";
var TabsContent = React144.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeTabs, value, forceMount, children } = _a, contentProps = __objRest(_a, ["__scopeTabs", "value", "forceMount", "children"]);
    const context = useTabsContext(CONTENT_NAME16, __scopeTabs);
    const triggerId = makeTriggerId2(context.baseId, value);
    const contentId = makeContentId2(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React144.useRef(isSelected);
    React144.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Presence2, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      Primitive2.div,
      __spreadProps(__spreadValues({
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0
      }, contentProps), {
        ref: forwardedRef,
        style: __spreadProps(__spreadValues({}, props2.style), {
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        }),
        children: present && children
      })
    ) });
  }
);
TabsContent.displayName = CONTENT_NAME16;
function makeTriggerId2(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId2(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root211 = Tabs;
var List2 = TabsList;
var Trigger13 = TabsTrigger;
var Content8 = TabsContent;

// src/components/tabs.tsx
var import_utils49 = require("@nubras/utils");
var import_jsx_runtime91 = require("react/jsx-runtime");
var Tabs2 = Root211;
var TabsList2 = React145.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
    List2,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils49.cn)(
        "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
        className
      )
    }, props2)
  );
});
TabsList2.displayName = List2.displayName;
var TabsTrigger2 = React145.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
    Trigger13,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils49.cn)(
        "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
        className
      )
    }, props2)
  );
});
TabsTrigger2.displayName = Trigger13.displayName;
var TabsContent2 = React145.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
    Content8,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils49.cn)(
        "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
        className
      )
    }, props2)
  );
});
TabsContent2.displayName = Content8.displayName;

// src/components/textarea.tsx
var React146 = __toESM(require("react"));
var import_utils50 = require("@nubras/utils");
var import_jsx_runtime92 = require("react/jsx-runtime");
var Textarea = React146.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
    "textarea",
    __spreadValues({
      className: (0, import_utils50.cn)(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      ),
      ref: ref2
    }, props2)
  );
});
Textarea.displayName = "Textarea";

// src/components/toast.tsx
var React148 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-toast@1.2.4_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3__we7kvgzwmmexvm5jcb2fzhicnq/node_modules/@radix-ui/react-toast/dist/index.mjs
var React147 = __toESM(require("react"), 1);
var ReactDOM9 = __toESM(require("react-dom"), 1);
var import_jsx_runtime93 = require("react/jsx-runtime");
var PROVIDER_NAME2 = "ToastProvider";
var [Collection9, useCollection9, createCollectionScope9] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope9]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME2);
var ToastProvider = (props2) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props2;
  const [viewport, setViewport] = React147.useState(null);
  const [toastCount, setToastCount] = React147.useState(0);
  const isFocusedToastEscapeKeyDownRef = React147.useRef(false);
  const isClosePausedRef = React147.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME2}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Collection9.Provider, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: React147.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: React147.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider.displayName = PROVIDER_NAME2;
var VIEWPORT_NAME4 = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})"
    } = _a, viewportProps = __objRest(_a, [
      "__scopeToast",
      "hotkey",
      "label"
    ]);
    const context = useToastProviderContext(VIEWPORT_NAME4, __scopeToast);
    const getItems = useCollection9(__scopeToast);
    const wrapperRef = React147.useRef(null);
    const headFocusProxyRef = React147.useRef(null);
    const tailFocusProxyRef = React147.useRef(null);
    const ref2 = React147.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    React147.useEffect(() => {
      const handleKeyDown = (event) => {
        var _a2;
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed)
          (_a2 = ref2.current) == null ? void 0 : _a2.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    React147.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref2.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside)
            handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside)
            handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = React147.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates4(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    React147.useEffect(() => {
      const viewport = ref2.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          var _a2, _b, _c;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              (_a2 = headFocusProxyRef.current) == null ? void 0 : _a2.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst7(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b = headFocusProxyRef.current) == null ? void 0 : _b.focus() : (_c = tailFocusProxyRef.current) == null ? void 0 : _c.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsxs)(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst7(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Collection9.Slot, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Primitive.ol, __spreadProps(__spreadValues({ tabIndex: -1 }, viewportProps), { ref: composedRefs })) }),
          hasToasts && /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst7(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport.displayName = VIEWPORT_NAME4;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeToast, onFocusFromOutsideViewport } = _a, proxyProps = __objRest(_a, ["__scopeToast", "onFocusFromOutsideViewport"]);
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
      VisuallyHidden,
      __spreadProps(__spreadValues({
        "aria-hidden": true,
        tabIndex: 0
      }, proxyProps), {
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a2;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a2 = context.viewport) == null ? void 0 : _a2.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport)
            onFocusFromOutsideViewport();
        }
      })
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { forceMount, open: openProp, defaultOpen, onOpenChange } = _a, toastProps = __objRest(_a, ["forceMount", "open", "defaultOpen", "onOpenChange"]);
    const [open = true, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Presence, { present: forceMount || open, children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
      ToastImpl,
      __spreadProps(__spreadValues({
        open
      }, toastProps), {
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef(props2.onPause),
        onResume: useCallbackRef(props2.onResume),
        onSwipeStart: composeEventHandlers(props2.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props2.onSwipeMove, (event) => {
          const { x: x2, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: composeEventHandlers(props2.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props2.onSwipeEnd, (event) => {
          const { x: x2, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
          setOpen(false);
        })
      })
    ) });
  }
);
Toast.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd
    } = _a, toastProps = __objRest(_a, [
      "__scopeToast",
      "type",
      "duration",
      "open",
      "onClose",
      "onEscapeKeyDown",
      "onPause",
      "onResume",
      "onSwipeStart",
      "onSwipeMove",
      "onSwipeCancel",
      "onSwipeEnd"
    ]);
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = React147.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = React147.useRef(null);
    const swipeDeltaRef = React147.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React147.useRef(0);
    const closeTimerRemainingTimeRef = React147.useRef(duration);
    const closeTimerRef = React147.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef(() => {
      var _a2;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast)
        (_a2 = context.viewport) == null ? void 0 : _a2.focus();
      onClose();
    });
    const startTimer = React147.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity)
          return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    React147.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    React147.useEffect(() => {
      if (open && !context.isClosePausedRef.current)
        startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React147.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React147.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsxs)(import_jsx_runtime93.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM9.createPortal(
        /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Collection9.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
          Root3,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current)
                handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
              Primitive.li,
              __spreadProps(__spreadValues({
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection
              }, toastProps), {
                ref: composedRefs,
                style: __spreadValues({ userSelect: "none", touchAction: "none" }, props2.style),
                onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
                  if (event.key !== "Escape")
                    return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props2.onPointerDown, (event) => {
                  if (event.button !== 0)
                    return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props2.onPointerMove, (event) => {
                  if (!pointerStartRef.current)
                    return;
                  const x2 = event.clientX - pointerStartRef.current.x;
                  const y = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp3 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp3(0, x2) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp3(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent3(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent3(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x2) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props2.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast3 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent3(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent3(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast3.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              })
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props2) => {
  const _a = props2, { __scopeToast, children } = _a, announceProps = __objRest(_a, ["__scopeToast", "children"]);
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = React147.useState(false);
  const [isAnnounced, setIsAnnounced] = React147.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  React147.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Portal, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(VisuallyHidden, __spreadProps(__spreadValues({}, announceProps), { children: renderAnnounceText && /* @__PURE__ */ (0, import_jsx_runtime93.jsxs)(import_jsx_runtime93.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) })) });
};
var TITLE_NAME4 = "ToastTitle";
var ToastTitle = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeToast } = _a, titleProps = __objRest(_a, ["__scopeToast"]);
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Primitive.div, __spreadProps(__spreadValues({}, titleProps), { ref: forwardedRef }));
  }
);
ToastTitle.displayName = TITLE_NAME4;
var DESCRIPTION_NAME4 = "ToastDescription";
var ToastDescription = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeToast } = _a, descriptionProps = __objRest(_a, ["__scopeToast"]);
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Primitive.div, __spreadProps(__spreadValues({}, descriptionProps), { ref: forwardedRef }));
  }
);
ToastDescription.displayName = DESCRIPTION_NAME4;
var ACTION_NAME2 = "ToastAction";
var ToastAction = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { altText } = _a, actionProps = __objRest(_a, ["altText"]);
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME2}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(ToastClose, __spreadProps(__spreadValues({}, actionProps), { ref: forwardedRef })) });
  }
);
ToastAction.displayName = ACTION_NAME2;
var CLOSE_NAME4 = "ToastClose";
var ToastClose = React147.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeToast } = _a, closeProps = __objRest(_a, ["__scopeToast"]);
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME4, __scopeToast);
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
      Primitive.button,
      __spreadProps(__spreadValues({
        type: "button"
      }, closeProps), {
        ref: forwardedRef,
        onClick: composeEventHandlers(props2.onClick, interactiveContext.onClose)
      })
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME4;
var ToastAnnounceExclude = React147.forwardRef((props2, forwardedRef) => {
  const _a = props2, { __scopeToast, altText } = _a, announceExcludeProps = __objRest(_a, ["__scopeToast", "altText"]);
  return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
    Primitive.div,
    __spreadProps(__spreadValues({
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0
    }, announceExcludeProps), {
      ref: forwardedRef
    })
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement2(node)) {
      const isHidden3 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden3) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent3(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler)
    currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement2(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates4(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst7(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider3 = ToastProvider;
var Viewport4 = ToastViewport;
var Root212 = Toast;
var Title4 = ToastTitle;
var Description4 = ToastDescription;
var Action2 = ToastAction;
var Close3 = ToastClose;

// src/components/toast.tsx
var import_utils51 = require("@nubras/utils");
var import_jsx_runtime94 = require("react/jsx-runtime");
var ToastProvider2 = Provider3;
var ToastViewport2 = React148.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    Viewport4,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils51.cn)(
        "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
        className
      )
    }, props2)
  );
});
ToastViewport2.displayName = Viewport4.displayName;
var toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
var Toast2 = React148.forwardRef((_a, ref2) => {
  var _b = _a, { className, variant } = _b, props2 = __objRest(_b, ["className", "variant"]);
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    Root212,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils51.cn)(toastVariants({ variant }), className)
    }, props2)
  );
});
Toast2.displayName = Root212.displayName;
var ToastAction2 = React148.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    Action2,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils51.cn)(
        "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
        className
      )
    }, props2)
  );
});
ToastAction2.displayName = Action2.displayName;
var ToastClose2 = React148.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    Close3,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils51.cn)(
        "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
        className
      ),
      "toast-close": ""
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(X, { className: "h-4 w-4" })
    })
  );
});
ToastClose2.displayName = Close3.displayName;
var ToastTitle2 = React148.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    Title4,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils51.cn)("text-sm font-semibold", className)
    }, props2)
  );
});
ToastTitle2.displayName = Title4.displayName;
var ToastDescription2 = React148.forwardRef((_a, ref2) => {
  var _b = _a, { className } = _b, props2 = __objRest(_b, ["className"]);
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    Description4,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils51.cn)("text-sm opacity-90", className)
    }, props2)
  );
});
ToastDescription2.displayName = Description4.displayName;

// src/hooks/use-toast.ts
var React149 = __toESM(require("react"));
var TOAST_LIMIT = 1;
var TOAST_REMOVE_DELAY = 1e6;
var count5 = 0;
function genId() {
  count5 = (count5 + 1) % Number.MAX_SAFE_INTEGER;
  return count5.toString();
}
var toastTimeouts = /* @__PURE__ */ new Map();
var addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId
    });
  }, TOAST_REMOVE_DELAY);
  toastTimeouts.set(toastId, timeout);
};
var reducer2 = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return __spreadProps(__spreadValues({}, state), {
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      });
    case "UPDATE_TOAST":
      return __spreadProps(__spreadValues({}, state), {
        toasts: state.toasts.map(
          (t2) => t2.id === action.toast.id ? __spreadValues(__spreadValues({}, t2), action.toast) : t2
        )
      });
    case "DISMISS_TOAST": {
      const { toastId } = action;
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast3) => {
          addToRemoveQueue(toast3.id);
        });
      }
      return __spreadProps(__spreadValues({}, state), {
        toasts: state.toasts.map(
          (t2) => t2.id === toastId || toastId === void 0 ? __spreadProps(__spreadValues({}, t2), {
            open: false
          }) : t2
        )
      });
    }
    case "REMOVE_TOAST":
      if (action.toastId === void 0) {
        return __spreadProps(__spreadValues({}, state), {
          toasts: []
        });
      }
      return __spreadProps(__spreadValues({}, state), {
        toasts: state.toasts.filter((t2) => t2.id !== action.toastId)
      });
  }
};
var listeners = [];
var memoryState = { toasts: [] };
function dispatch(action) {
  memoryState = reducer2(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}
function toast(_a) {
  var props2 = __objRest(_a, []);
  const id = genId();
  const update2 = (props3) => dispatch({
    type: "UPDATE_TOAST",
    toast: __spreadProps(__spreadValues({}, props3), { id })
  });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });
  dispatch({
    type: "ADD_TOAST",
    toast: __spreadProps(__spreadValues({}, props2), {
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open)
          dismiss();
      }
    })
  });
  return {
    id,
    dismiss,
    update: update2
  };
}
function useToast() {
  const [state, setState] = React149.useState(memoryState);
  React149.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index2 = listeners.indexOf(setState);
      if (index2 > -1) {
        listeners.splice(index2, 1);
      }
    };
  }, [state]);
  return __spreadProps(__spreadValues({}, state), {
    toast,
    dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId })
  });
}

// src/components/toaster.tsx
var import_jsx_runtime95 = require("react/jsx-runtime");
function ToasterProvider() {
  const { toasts } = useToast();
  return /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)(ToastProvider2, { children: [
    toasts.map(function(_a) {
      var _b = _a, { id, title, description, action } = _b, props2 = __objRest(_b, ["id", "title", "description", "action"]);
      return /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)(Toast2, __spreadProps(__spreadValues({}, props2), { children: [
        /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)("div", { className: "grid gap-1", children: [
          title && /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(ToastTitle2, { children: title }),
          description && /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(ToastDescription2, { children: description })
        ] }),
        action,
        /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(ToastClose2, {})
      ] }), id);
    }),
    /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(ToastViewport2, {})
  ] });
}

// src/components/toggle-group.tsx
var React153 = __toESM(require("react"));

// ../../node_modules/.pnpm/@radix-ui+react-toggle-group@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_j7x25kftyyazd6rfnrf4ntn7fm/node_modules/@radix-ui/react-toggle-group/dist/index.mjs
var import_react50 = __toESM(require("react"), 1);

// ../../node_modules/.pnpm/@radix-ui+react-toggle@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@19.1.3_fymybupnfopun6sctcxmlj4aba/node_modules/@radix-ui/react-toggle/dist/index.mjs
var React150 = __toESM(require("react"), 1);
var import_jsx_runtime96 = require("react/jsx-runtime");
var NAME6 = "Toggle";
var Toggle = React150.forwardRef((props2, forwardedRef) => {
  const _a = props2, { pressed: pressedProp, defaultPressed = false, onPressedChange } = _a, buttonProps = __objRest(_a, ["pressed", "defaultPressed", "onPressedChange"]);
  const [pressed = false, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed
  });
  return /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
    Primitive.button,
    __spreadProps(__spreadValues({
      type: "button",
      "aria-pressed": pressed,
      "data-state": pressed ? "on" : "off",
      "data-disabled": props2.disabled ? "" : void 0
    }, buttonProps), {
      ref: forwardedRef,
      onClick: composeEventHandlers(props2.onClick, () => {
        if (!props2.disabled) {
          setPressed(!pressed);
        }
      })
    })
  );
});
Toggle.displayName = NAME6;
var Root21 = Toggle;

// ../../node_modules/.pnpm/@radix-ui+react-toggle-group@1.1.1_@types+react-dom@19.1.3_@types+react@19.1.3__@types+react@_j7x25kftyyazd6rfnrf4ntn7fm/node_modules/@radix-ui/react-toggle-group/dist/index.mjs
var import_jsx_runtime97 = require("react/jsx-runtime");
var TOGGLE_GROUP_NAME = "ToggleGroup";
var [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope5 = createRovingFocusGroupScope();
var ToggleGroup = import_react50.default.forwardRef((props2, forwardedRef) => {
  const _a = props2, { type } = _a, toggleGroupProps = __objRest(_a, ["type"]);
  if (type === "single") {
    const singleProps = toggleGroupProps;
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ToggleGroupImplSingle, __spreadProps(__spreadValues({}, singleProps), { ref: forwardedRef }));
  }
  if (type === "multiple") {
    const multipleProps = toggleGroupProps;
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ToggleGroupImplMultiple, __spreadProps(__spreadValues({}, multipleProps), { ref: forwardedRef }));
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImplSingle = import_react50.default.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    }
  } = _a, toggleGroupSingleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange"
  ]);
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props2.__scopeToggleGroup,
      type: "single",
      value: value ? [value] : [],
      onItemActivate: setValue,
      onItemDeactivate: import_react50.default.useCallback(() => setValue(""), [setValue]),
      children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ToggleGroupImpl, __spreadProps(__spreadValues({}, toggleGroupSingleProps), { ref: forwardedRef }))
    }
  );
});
var ToggleGroupImplMultiple = import_react50.default.forwardRef((props2, forwardedRef) => {
  const _a = props2, {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    }
  } = _a, toggleGroupMultipleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange"
  ]);
  const [value = [], setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const handleButtonActivate = import_react50.default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleButtonDeactivate = import_react50.default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props2.__scopeToggleGroup,
      type: "multiple",
      value,
      onItemActivate: handleButtonActivate,
      onItemDeactivate: handleButtonDeactivate,
      children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ToggleGroupImpl, __spreadProps(__spreadValues({}, toggleGroupMultipleProps), { ref: forwardedRef }))
    }
  );
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImpl = import_react50.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, {
      __scopeToggleGroup,
      disabled = false,
      rovingFocus = true,
      orientation,
      dir,
      loop = true
    } = _a, toggleGroupProps = __objRest(_a, [
      "__scopeToggleGroup",
      "disabled",
      "rovingFocus",
      "orientation",
      "dir",
      "loop"
    ]);
    const rovingFocusGroupScope = useRovingFocusGroupScope5(__scopeToggleGroup);
    const direction = useDirection(dir);
    const commonProps = __spreadValues({ role: "group", dir: direction }, toggleGroupProps);
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
      Root12,
      __spreadProps(__spreadValues({
        asChild: true
      }, rovingFocusGroupScope), {
        orientation,
        dir: direction,
        loop,
        children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Primitive.div, __spreadProps(__spreadValues({}, commonProps), { ref: forwardedRef }))
      })
    ) : /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Primitive.div, __spreadProps(__spreadValues({}, commonProps), { ref: forwardedRef })) });
  }
);
var ITEM_NAME11 = "ToggleGroupItem";
var ToggleGroupItem = import_react50.default.forwardRef(
  (props2, forwardedRef) => {
    const valueContext = useToggleGroupValueContext(ITEM_NAME11, props2.__scopeToggleGroup);
    const context = useToggleGroupContext(ITEM_NAME11, props2.__scopeToggleGroup);
    const rovingFocusGroupScope = useRovingFocusGroupScope5(props2.__scopeToggleGroup);
    const pressed = valueContext.value.includes(props2.value);
    const disabled = context.disabled || props2.disabled;
    const commonProps = __spreadProps(__spreadValues({}, props2), { pressed, disabled });
    const ref2 = import_react50.default.useRef(null);
    return context.rovingFocus ? /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
      Item3,
      __spreadProps(__spreadValues({
        asChild: true
      }, rovingFocusGroupScope), {
        focusable: !disabled,
        active: pressed,
        ref: ref2,
        children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ToggleGroupItemImpl, __spreadProps(__spreadValues({}, commonProps), { ref: forwardedRef }))
      })
    ) : /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ToggleGroupItemImpl, __spreadProps(__spreadValues({}, commonProps), { ref: forwardedRef }));
  }
);
ToggleGroupItem.displayName = ITEM_NAME11;
var ToggleGroupItemImpl = import_react50.default.forwardRef(
  (props2, forwardedRef) => {
    const _a = props2, { __scopeToggleGroup, value } = _a, itemProps = __objRest(_a, ["__scopeToggleGroup", "value"]);
    const valueContext = useToggleGroupValueContext(ITEM_NAME11, __scopeToggleGroup);
    const singleProps = { role: "radio", "aria-checked": props2.pressed, "aria-pressed": void 0 };
    const typeProps = valueContext.type === "single" ? singleProps : void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
      Toggle,
      __spreadProps(__spreadValues(__spreadValues({}, typeProps), itemProps), {
        ref: forwardedRef,
        onPressedChange: (pressed) => {
          if (pressed) {
            valueContext.onItemActivate(value);
          } else {
            valueContext.onItemDeactivate(value);
          }
        }
      })
    );
  }
);
var Root213 = ToggleGroup;
var Item26 = ToggleGroupItem;

// src/components/toggle-group.tsx
var import_utils53 = require("@nubras/utils");

// src/components/toggle.tsx
var React152 = __toESM(require("react"));
var import_utils52 = require("@nubras/utils");
var import_jsx_runtime98 = require("react/jsx-runtime");
var toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var Toggle2 = React152.forwardRef((_a, ref2) => {
  var _b = _a, { className, variant, size: size4 } = _b, props2 = __objRest(_b, ["className", "variant", "size"]);
  return /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
    Root21,
    __spreadValues({
      ref: ref2,
      className: (0, import_utils52.cn)(toggleVariants({ variant, size: size4, className }))
    }, props2)
  );
});
Toggle2.displayName = Root21.displayName;

// src/components/toggle-group.tsx
var import_jsx_runtime99 = require("react/jsx-runtime");
var ToggleGroupContext2 = React153.createContext({
  size: "default",
  variant: "default"
});
var ToggleGroup2 = React153.forwardRef((_a, ref2) => {
  var _b = _a, { className, variant, size: size4, children } = _b, props2 = __objRest(_b, ["className", "variant", "size", "children"]);
  return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(
    Root213,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils53.cn)("flex items-center justify-center gap-1", className)
    }, props2), {
      children: /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(ToggleGroupContext2.Provider, { value: { variant, size: size4 }, children })
    })
  );
});
ToggleGroup2.displayName = Root213.displayName;
var ToggleGroupItem2 = React153.forwardRef((_a, ref2) => {
  var _b = _a, { className, children, variant, size: size4 } = _b, props2 = __objRest(_b, ["className", "children", "variant", "size"]);
  const context = React153.useContext(ToggleGroupContext2);
  return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(
    Item26,
    __spreadProps(__spreadValues({
      ref: ref2,
      className: (0, import_utils53.cn)(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size4
        }),
        className
      )
    }, props2), {
      children
    })
  );
});
ToggleGroupItem2.displayName = Item26.displayName;

// src/components/tree-view.tsx
var React154 = __toESM(require("react"));
var import_utils54 = require("@nubras/utils");
var import_jsx_runtime100 = require("react/jsx-runtime");
function TreeView({ data, onNodeSelect, defaultExpanded = false, className }) {
  return /* @__PURE__ */ (0, import_jsx_runtime100.jsx)("div", { className: (0, import_utils54.cn)("text-sm", className), children: /* @__PURE__ */ (0, import_jsx_runtime100.jsx)("ul", { className: "space-y-1", children: data.map((node) => /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(TreeNode, { node, onNodeSelect, defaultExpanded, level: 0 }, node.id)) }) });
}
function TreeNode({ node, onNodeSelect, defaultExpanded, level }) {
  const [expanded, setExpanded] = React154.useState(defaultExpanded);
  const hasChildren = node.children && node.children.length > 0;
  const handleToggle = (e) => {
    e.stopPropagation();
    setExpanded(!expanded);
  };
  const handleSelect = () => {
    onNodeSelect == null ? void 0 : onNodeSelect(node);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime100.jsxs)("li", { className: "select-none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime100.jsxs)(
      "div",
      {
        className: (0, import_utils54.cn)(
          "flex items-center gap-2 rounded-md px-2 py-1.5 hover:bg-muted",
          level > 0 && "ml-4",
          onNodeSelect && "cursor-pointer"
        ),
        onClick: handleSelect,
        children: [
          hasChildren ? /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(
            "button",
            {
              type: "button",
              className: "h-4 w-4 shrink-0 text-muted-foreground",
              onClick: handleToggle,
              "aria-label": expanded ? "Collapse" : "Expand",
              children: expanded ? /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(ChevronDown, { className: "h-4 w-4" }) : /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(ChevronRight, { className: "h-4 w-4" })
            }
          ) : /* @__PURE__ */ (0, import_jsx_runtime100.jsx)("span", { className: "h-4 w-4 shrink-0" }),
          node.icon && /* @__PURE__ */ (0, import_jsx_runtime100.jsx)("span", { className: "shrink-0", children: node.icon }),
          /* @__PURE__ */ (0, import_jsx_runtime100.jsx)("span", { className: "truncate", children: node.name })
        ]
      }
    ),
    hasChildren && expanded && /* @__PURE__ */ (0, import_jsx_runtime100.jsx)("ul", { className: "mt-1", children: node.children.map((childNode) => /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(
      TreeNode,
      {
        node: childNode,
        onNodeSelect,
        defaultExpanded,
        level: level + 1
      },
      childNode.id
    )) })
  ] });
}

// src/components/use-mobile.tsx
var React155 = __toESM(require("react"));
var MOBILE_BREAKPOINT2 = 768;
function useIsMobile2() {
  const [isMobile, setIsMobile] = React155.useState(void 0);
  React155.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT2 - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT2);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT2);
    return () => mql.removeEventListener("change", onChange);
  }, []);
  return !!isMobile;
}

// src/components/use-toast.ts
var React156 = __toESM(require("react"));
var TOAST_LIMIT2 = 1;
var TOAST_REMOVE_DELAY2 = 1e6;
var count6 = 0;
function genId2() {
  count6 = (count6 + 1) % Number.MAX_SAFE_INTEGER;
  return count6.toString();
}
var toastTimeouts2 = /* @__PURE__ */ new Map();
var addToRemoveQueue2 = (toastId) => {
  if (toastTimeouts2.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts2.delete(toastId);
    dispatch2({
      type: "REMOVE_TOAST",
      toastId
    });
  }, TOAST_REMOVE_DELAY2);
  toastTimeouts2.set(toastId, timeout);
};
var reducer3 = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return __spreadProps(__spreadValues({}, state), {
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT2)
      });
    case "UPDATE_TOAST":
      return __spreadProps(__spreadValues({}, state), {
        toasts: state.toasts.map(
          (t2) => t2.id === action.toast.id ? __spreadValues(__spreadValues({}, t2), action.toast) : t2
        )
      });
    case "DISMISS_TOAST": {
      const { toastId } = action;
      if (toastId) {
        addToRemoveQueue2(toastId);
      } else {
        state.toasts.forEach((toast3) => {
          addToRemoveQueue2(toast3.id);
        });
      }
      return __spreadProps(__spreadValues({}, state), {
        toasts: state.toasts.map(
          (t2) => t2.id === toastId || toastId === void 0 ? __spreadProps(__spreadValues({}, t2), {
            open: false
          }) : t2
        )
      });
    }
    case "REMOVE_TOAST":
      if (action.toastId === void 0) {
        return __spreadProps(__spreadValues({}, state), {
          toasts: []
        });
      }
      return __spreadProps(__spreadValues({}, state), {
        toasts: state.toasts.filter((t2) => t2.id !== action.toastId)
      });
  }
};
var listeners2 = [];
var memoryState2 = { toasts: [] };
function dispatch2(action) {
  memoryState2 = reducer3(memoryState2, action);
  listeners2.forEach((listener) => {
    listener(memoryState2);
  });
}
function toast2(_a) {
  var props2 = __objRest(_a, []);
  const id = genId2();
  const update2 = (props3) => dispatch2({
    type: "UPDATE_TOAST",
    toast: __spreadProps(__spreadValues({}, props3), { id })
  });
  const dismiss = () => dispatch2({ type: "DISMISS_TOAST", toastId: id });
  dispatch2({
    type: "ADD_TOAST",
    toast: __spreadProps(__spreadValues({}, props2), {
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open)
          dismiss();
      }
    })
  });
  return {
    id,
    dismiss,
    update: update2
  };
}
function useToast2() {
  const [state, setState] = React156.useState(memoryState2);
  React156.useEffect(() => {
    listeners2.push(setState);
    return () => {
      const index2 = listeners2.indexOf(setState);
      if (index2 > -1) {
        listeners2.splice(index2, 1);
      }
    };
  }, [state]);
  return __spreadProps(__spreadValues({}, state), {
    toast: toast2,
    dismiss: (toastId) => dispatch2({ type: "DISMISS_TOAST", toastId })
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
  Alert,
  AlertDescription,
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  AlertDialogPortal,
  AlertDialogTitle,
  AlertDialogTrigger,
  AlertTitle,
  AspectRatio,
  Avatar,
  AvatarFallback,
  AvatarImage,
  Badge,
  Breadcrumb,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
  Button,
  Calendar,
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
  Chart,
  ChartContainer,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
  ChartTooltip,
  ChartTooltipContent,
  Checkbox,
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
  CommandShortcut,
  ContextMenu,
  ContextMenuCheckboxItem,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuLabel,
  ContextMenuPortal,
  ContextMenuRadioGroup,
  ContextMenuRadioItem,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
  DatePicker,
  DatePickerWithRange,
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerOverlay,
  DrawerPortal,
  DrawerTitle,
  DrawerTrigger,
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  HoverCard,
  HoverCardContent,
  HoverCardTrigger,
  Input,
  InputOTP,
  InputOTPGroup,
  InputOTPSeparator,
  InputOTPSlot,
  Kanban,
  Label,
  Menubar,
  MenubarCheckboxItem,
  MenubarContent,
  MenubarGroup,
  MenubarItem,
  MenubarLabel,
  MenubarMenu,
  MenubarPortal,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSeparator,
  MenubarShortcut,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarTrigger,
  NavigationMenu,
  NavigationMenuContent,
  NavigationMenuIndicator,
  NavigationMenuItem,
  NavigationMenuLink,
  NavigationMenuList,
  NavigationMenuTrigger,
  NavigationMenuViewport,
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
  Popover,
  PopoverContent,
  PopoverTrigger,
  Progress,
  RadioGroup,
  RadioGroupItem,
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
  ScrollArea,
  ScrollBar,
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
  Separator,
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  Skeleton,
  Slider,
  Switch,
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
  Textarea,
  Toast,
  ToastAction,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
  Toaster,
  ToasterProvider,
  Toggle,
  ToggleGroup,
  ToggleGroupItem,
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
  TreeView,
  badgeVariants,
  buttonVariants,
  navigationMenuTriggerStyle,
  reducer,
  toast,
  toggleVariants,
  useFormField,
  useIsMobile,
  useSidebar,
  useToast
});
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/defaultAttributes.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/Icon.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/createLucideIcon.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/arrow-left.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/arrow-right.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/calendar.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/check.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-down.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-left.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-right.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-up.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/circle.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/dot.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/ellipsis.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/grip-vertical.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/panel-left.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/plus.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/search.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/x.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
